export const __webpack_id__ = "vendors-node_modules_arcgis_lumina_dist_controllers_index_js";
export const __webpack_ids__ = ["vendors-node_modules_arcgis_lumina_dist_controllers_index_js"];
export const __webpack_modules__ = {

/***/ "./node_modules/@arcgis/lumina/dist/controllers/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@arcgis/lumina/dist/controllers/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Controller: () => (/* reexport safe */ _Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.C),
/* harmony export */   GenericController: () => (/* reexport safe */ _Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.G),
/* harmony export */   bypassReadOnly: () => (/* reexport safe */ _ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__.f),
/* harmony export */   bypassSetter: () => (/* reexport safe */ _ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__.e),
/* harmony export */   controllerSymbol: () => (/* reexport safe */ _ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__.c),
/* harmony export */   getControllersCount: () => (/* reexport safe */ _ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__.h),
/* harmony export */   isController: () => (/* reexport safe */ _ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__.g),
/* harmony export */   keyTrackResolve: () => (/* binding */ keyTrackResolve),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   makeController: () => (/* binding */ makeController),
/* harmony export */   makeGenericController: () => (/* binding */ makeGenericController),
/* harmony export */   makeT9nController: () => (/* binding */ makeT9nController),
/* harmony export */   propertyTrackResolve: () => (/* reexport safe */ _Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.p),
/* harmony export */   proxyExports: () => (/* reexport safe */ _proxyExports_D906TEtL_js__WEBPACK_IMPORTED_MODULE_2__.p),
/* harmony export */   retrieveComponent: () => (/* reexport safe */ _ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__.r),
/* harmony export */   toFunction: () => (/* binding */ toFunction),
/* harmony export */   trackKey: () => (/* reexport safe */ _Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.t),
/* harmony export */   trackPropKey: () => (/* reexport safe */ _Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.d),
/* harmony export */   trackPropertyKey: () => (/* reexport safe */ _Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.b),
/* harmony export */   useDirection: () => (/* binding */ useDirection),
/* harmony export */   useMedia: () => (/* binding */ useMedia),
/* harmony export */   usePropertyChange: () => (/* binding */ usePropertyChange),
/* harmony export */   useWatchAttributes: () => (/* binding */ useWatchAttributes)
/* harmony export */ });
/* harmony import */ var _Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Controller-ftAEcdmI.js */ "./node_modules/@arcgis/lumina/dist/Controller-ftAEcdmI.js");
/* harmony import */ var _ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ControllerInternals-CWQrfEA8.js */ "./node_modules/@arcgis/lumina/dist/ControllerInternals-CWQrfEA8.js");
/* harmony import */ var _proxyExports_D906TEtL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proxyExports-D906TEtL.js */ "./node_modules/@arcgis/lumina/dist/proxyExports-D906TEtL.js");
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _arcgis_toolkit_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @arcgis/toolkit/error */ "./node_modules/@arcgis/toolkit/dist/error/index.js");
/* harmony import */ var _arcgis_toolkit_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @arcgis/toolkit/dom */ "./node_modules/@arcgis/toolkit/dist/dom/index.js");
/* harmony import */ var _arcgis_toolkit_intl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @arcgis/toolkit/intl */ "./node_modules/@arcgis/toolkit/dist/intl/index.js");









const makeController = (constructor) => proxy(void 0, constructor);
const makeGenericController = (constructor) => (component) => proxy(
  component,
  /**
   * GenericController is identical to Controller, in all except for typing.
   * So doing a type-cast here so as not to needlessly add one more object
   * to the prototype chain
   */
  constructor
);
class FunctionalController extends _Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.C {
  constructor(component, constructor) {
    super(component);
    const originalExports = this.exports;
    try {
      (0,_ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__.s)(this.component);
      const value = constructor(this.component, this);
      const constructorChangedExports = this.exports !== originalExports;
      if ((0,_ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__.i)(value)) {
        if (!constructorChangedExports) {
          this.setProvisionalExports(value);
        }
        const resolved = value.then((result) => {
          this.exports = result;
          super.catchUpLifecycle();
        }).catch((error) => {
          this.P.reject(error);
          console.error(error);
        });
        this.onLoad(async () => await resolved);
      } else {
        if (!constructorChangedExports || value !== void 0) {
          this.exports = value;
        }
        queueMicrotask(() => super.catchUpLifecycle());
      }
    } catch (error) {
      this.P.reject(error);
      console.error(error);
    }
  }
  /** Noop - will be called in the constructor instead */
  catchUpLifecycle() {
    return;
  }
}
const proxy = (0,_proxyExports_D906TEtL_js__WEBPACK_IMPORTED_MODULE_2__.p)(FunctionalController);
const useWatchAttributes = (attributes, callback) => new AttributeWatchController(attributes, callback);
class AttributeWatchController extends _Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.C {
  #observer;
  #attributes;
  #callback;
  constructor(attributes, callback) {
    super();
    if (lit__WEBPACK_IMPORTED_MODULE_3__.isServer) {
      return;
    }
    this.#attributes = attributes;
    this.#callback = callback;
    this.#observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (attributes.includes(mutation.attributeName)) {
          callback.call(
            this.component,
            this.component.el.getAttribute(mutation.attributeName),
            mutation.oldValue,
            mutation.attributeName
          );
        }
      });
    });
  }
  hostConnected() {
    this.#attributes.forEach((attribute) => {
      if (this.component.el.hasAttribute(attribute)) {
        this.#callback.call(this.component, null, this.component.el.getAttribute(attribute), attribute);
      }
    });
    this.#observer.observe(this.component.el, {
      attributes: true,
      attributeOldValue: true,
      attributeFilter: this.#attributes
    });
  }
  hostDisconnected() {
    this.#observer.disconnect();
  }
}
const load = makeController;
const toFunction = (Class) => (...args) => {
  const ambientControllers = (0,_ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__.d)();
  const instance = new Class(...args);
  (0,_ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__.b)(ambientControllers.at(-1));
  return instance;
};
const useMedia = (query) => makeController((_component, controller) => {
  const media = globalThis.matchMedia(query);
  const changed = () => {
    controller.exports = media.matches;
  };
  changed();
  controller.onLifecycle(() => {
    media.addEventListener("change", changed);
    return () => media.removeEventListener("change", changed);
  });
  return void 0;
});
const defaultDirection = "ltr";
const useDirection = () => makeController((component, controller) => {
  controller.exports = defaultDirection;
  controller.onLifecycle(() => {
    const callback = () => {
      const dir = (0,_arcgis_toolkit_dom__WEBPACK_IMPORTED_MODULE_4__.getElementAttribute)(component.el, "dir", defaultDirection);
      controller.exports = dir === "rtl" ? "rtl" : "ltr";
    };
    callback();
    return (0,_arcgis_toolkit_dom__WEBPACK_IMPORTED_MODULE_4__.observeAncestorsMutation)(component.el, ["dir"], callback);
  });
  if ( true && (0,_arcgis_toolkit_error__WEBPACK_IMPORTED_MODULE_5__.isEsriInternalEnv)()) {
    (0,_Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.t)(
      component,
      (resolved) => {
        if (resolved?.key === "dir") {
          throw new Error(
            "Do not assign this controller to a prop called `dir` as that will overwrite the HTMLElement's built-in `dir` attribute - component should not be setting the `dir` attribute on itself. Instead, assign this controller to a property called `direction`."
          );
        }
      },
      controller.exports
    );
  }
  return void 0;
});
const makeT9nController = (getAssetPath) => (options = {}) => (
  // eslint-disable-next-line @typescript-eslint/promise-function-async
  makeController((component, controller) => {
    const locale = (0,_arcgis_toolkit_intl__WEBPACK_IMPORTED_MODULE_6__.getElementLocale)(component.el);
    const pending = { ["_lang"]: locale.lang, ["_t9nLocale"]: locale.t9nLocale, ["_loading"]: true };
    const componentWithOverrides = component;
    controller.onLifecycle(
      () => (0,_arcgis_toolkit_intl__WEBPACK_IMPORTED_MODULE_6__.startLocaleObserver)(
        component.el,
        () => getAssetPath("./assets"),
        ({ t9nLocale, t9nStrings, lang }) => {
          const withoutOverrides = {
            ...t9nStrings,
            ["_lang"]: lang,
            ["_t9nLocale"]: t9nLocale,
            ["_loading"]: false
          };
          controller.exports = withoutOverrides;
          const label = t9nStrings.componentLabel;
          if (typeof label === "string" && "label" in component && component.label == null) {
            component.label ??= label;
          }
          applyOverrides(componentWithOverrides.messageOverrides);
        },
        options.name
      )
    );
    const applyOverrides = (messageOverrides) => {
      const currentValue = controller.exports;
      const rawMessages = currentValue["_original"] ?? currentValue;
      const updated = deepMerge(rawMessages, messageOverrides);
      if (messageOverrides) {
        updated["_original"] = rawMessages;
      }
      controller.exports = updated;
    };
    if ("messageOverrides" in componentWithOverrides) {
      controller.onUpdate((changes) => {
        if (changes.has("messageOverrides")) {
          applyOverrides(componentWithOverrides.messageOverrides);
        }
      });
    }
    if (options.blocking) {
      controller.setProvisionalExports(pending, false);
      return controller.ready;
    } else {
      return pending;
    }
  })
);
const deepMerge = (original, overwrites) => {
  if (!overwrites) {
    return original;
  }
  const merged = { ...original };
  Object.entries(overwrites).forEach(([key, value]) => {
    if (typeof value === "object") {
      merged[key] = deepMerge(original[key], value);
    } else {
      merged[key] = value ?? original[key];
    }
  });
  return merged;
};
const usePropertyChange = (_component) => propertyChangeController;
const eventName = "arcgisPropertyChange";
const propertyChangeController = (...toWatch) => {
  const component = (0,_ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_1__.r)();
  const eventEmitter = (0,_Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.a)(eventName, void 0, component);
  if ( true && (0,_arcgis_toolkit_error__WEBPACK_IMPORTED_MODULE_5__.isEsriInternalEnv)()) {
    toWatch.forEach((prop) => {
      const descriptor = component.constructor.elementProperties.get(prop);
      const isProp = descriptor !== void 0 && descriptor.state !== true;
      if (!isProp) {
        throw new Error(
          `For usePropertyChange to emit event on "${prop}" property change, you should add @property() to ${prop} in ${component.el.localName}`
        );
      }
    });
  }
  let isFirst = true;
  component.manager.onUpdated((changes) => {
    if (isFirst || !component.el.isConnected) {
      isFirst = false;
      return;
    }
    for (const name of toWatch) {
      if (changes.has(name)) {
        eventEmitter.emit({ name });
      }
    }
  });
  if ( true && (0,_arcgis_toolkit_error__WEBPACK_IMPORTED_MODULE_5__.isEsriInternalEnv)()) {
    (0,_Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.t)(
      component,
      (resolution) => {
        if (resolution === void 0 || resolution.isReactive || resolution.key !== eventName) {
          throw new Error(
            `For consistency, usePropertyChange must be assigned to an arcgisPropertyChange property and that property should not have @property() or @state() decorators: arcgisPropertyChange = usePropertyChange<this>()("prop1", "prop2");`
          );
        }
      },
      eventEmitter
    );
  }
  return eventEmitter;
};
const keyTrackResolve = _Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_0__.p;



/***/ }),

/***/ "./node_modules/@arcgis/lumina/dist/proxyExports-D906TEtL.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@arcgis/lumina/dist/proxyExports-D906TEtL.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   p: () => (/* binding */ proxyExports)
/* harmony export */ });
/* harmony import */ var _ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ControllerInternals-CWQrfEA8.js */ "./node_modules/@arcgis/lumina/dist/ControllerInternals-CWQrfEA8.js");
/* harmony import */ var _Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Controller-ftAEcdmI.js */ "./node_modules/@arcgis/lumina/dist/Controller-ftAEcdmI.js");


const proxyExports = (Class) => (...args) => {
  const ambientControllers = (0,_ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_0__.d)();
  const instance = new Class(...args);
  const initialExports = instance.exports;
  (0,_ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_0__.b)(ambientControllers.at(-1));
  const manager = instance.component.manager;
  manager.W(instance, initialExports);
  instance.watchExports(manager.W.bind(manager, instance));
  (0,_ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_0__.j)(instance);
  const hostCandidates = [instance.component, ...ambientControllers].reverse();
  return (0,_Controller_ftAEcdmI_js__WEBPACK_IMPORTED_MODULE_1__.t)(
    hostCandidates,
    (resolution) => resolution === void 0 ? void 0 : setProxy(instance, resolution, initialExports),
    initialExports
  );
};
const setProxy = (controller, { host, key, isReactive: assignedToProp }, initialExports) => {
  const genericHost = host;
  const controllerValueChanged = genericHost[key] !== controller.exports;
  const hostValueChanged = genericHost[key] !== initialExports;
  const controllerUpdatedExports = initialExports !== controller.exports;
  if (controllerValueChanged && !hostValueChanged && controllerUpdatedExports) {
    genericHost[key] = controller.exports;
  }
  const isProxyExportsOnComponent = host === controller.component;
  if (isProxyExportsOnComponent) {
    if (assignedToProp) {
      const manager = controller.component.manager;
      if (hostValueChanged) {
        manager.W(controller, genericHost[key]);
      }
      controller.onUpdate((changes) => {
        if (changes.has(key)) {
          const value = genericHost[key];
          if (value !== controller.exports) {
            manager.W(controller, value);
          }
        }
      });
    }
    controller.O = assignedToProp ? void 0 : key;
  }
  const isReadOnly = controller.component.constructor.elementProperties.get(key)?.readOnly;
  controller.watchExports(() => {
    if (genericHost[key] === controller.exports) {
      return;
    }
    if (isReadOnly) {
      (0,_ControllerInternals_CWQrfEA8_js__WEBPACK_IMPORTED_MODULE_0__.f)(() => {
        genericHost[key] = controller.exports;
      });
    } else {
      genericHost[key] = controller.exports;
    }
  });
};



/***/ }),

/***/ "./node_modules/@arcgis/toolkit/dist/dom/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@arcgis/toolkit/dist/dom/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   classes: () => (/* binding */ classes),
/* harmony export */   focusElement: () => (/* binding */ focusElement),
/* harmony export */   getClosestElement: () => (/* binding */ getClosestElement),
/* harmony export */   getElementAttribute: () => (/* binding */ getElementAttribute),
/* harmony export */   getSlotAssignedElements: () => (/* binding */ getSlotAssignedElements),
/* harmony export */   observeAncestorsMutation: () => (/* binding */ observeAncestorsMutation),
/* harmony export */   setFocusOnElement: () => (/* binding */ setFocusOnElement),
/* harmony export */   slotChangeGetAssignedElements: () => (/* binding */ slotChangeGetAssignedElements),
/* harmony export */   slotChangeGetAssignedNodes: () => (/* binding */ slotChangeGetAssignedNodes),
/* harmony export */   slotChangeGetTextContent: () => (/* binding */ slotChangeGetTextContent),
/* harmony export */   slotChangeHasAssignedElement: () => (/* binding */ slotChangeHasAssignedElement),
/* harmony export */   slotChangeHasAssignedNode: () => (/* binding */ slotChangeHasAssignedNode),
/* harmony export */   slotChangeHasContent: () => (/* binding */ slotChangeHasContent),
/* harmony export */   slotChangeHasTextContent: () => (/* binding */ slotChangeHasTextContent),
/* harmony export */   unsafeGetCalciteModeName: () => (/* binding */ unsafeGetCalciteModeName),
/* harmony export */   unsafeGetElementDirection: () => (/* binding */ unsafeGetElementDirection)
/* harmony export */ });
function slotChangeHasContent(event) {
  return slotChangeHasAssignedElement(event) || slotChangeHasTextContent(event);
}
function slotChangeGetTextContent(event) {
  return slotChangeGetAssignedNodes(event).filter((node) => node.nodeType === Node.TEXT_NODE).map((node) => node.textContent).join("").trim();
}
function slotChangeHasTextContent(event) {
  return slotChangeGetTextContent(event).length > 0;
}
function slotChangeHasAssignedNode(event) {
  return slotChangeGetAssignedNodes(event).length > 0;
}
function slotChangeGetAssignedNodes(event) {
  return event.currentTarget.assignedNodes({
    flatten: true
  });
}
function slotChangeHasAssignedElement(event) {
  return slotChangeGetAssignedElements(event).length > 0;
}
function slotChangeGetAssignedElements(event, selector) {
  return getSlotAssignedElements(event.target, selector);
}
function getSlotAssignedElements(slot, selector) {
  const assignedElements = slot.assignedElements({
    flatten: true
  });
  return selector ? assignedElements.filter((element) => element.matches(selector)) : assignedElements;
}
const classes = (...classes2) => {
  const effectiveClasses = [];
  for (let i = 0; i < classes2.length; i++) {
    const arg = classes2[i];
    if (typeof arg === "string") {
      effectiveClasses.push(arg);
    } else if (Array.isArray(arg)) {
      effectiveClasses.push.apply(effectiveClasses, arg);
    } else if (typeof arg === "object") {
      for (const prop in arg) {
        if (arg[prop]) {
          effectiveClasses.push(prop);
        }
      }
    }
  }
  const className = effectiveClasses.join(" ");
  effectiveClasses.length = 0;
  return className;
};
const inTargetElement = (element, targetElement) => {
  let currentElement = element;
  while (currentElement) {
    if (currentElement === targetElement) {
      return true;
    }
    if (!currentElement.parentNode) {
      return false;
    }
    if (currentElement.parentNode instanceof ShadowRoot) {
      currentElement = currentElement.parentNode.host;
    } else {
      currentElement = currentElement.parentNode;
    }
  }
  return false;
};
const observeAncestorsMutation = (element, attributeFilter, callback) => {
  const subscribe = observe(attributeFilter).subscribe;
  return subscribe((mutations) => {
    const matched = mutations.some((mutation) => inTargetElement(element, mutation.target));
    if (matched) {
      callback();
    }
  });
};
const observers = {};
const observe = (attributeFilter) => {
  const attributes = attributeFilter.join(",");
  const previousObserver = observers[attributes];
  if (previousObserver !== void 0) {
    return previousObserver;
  }
  const subscribers = /* @__PURE__ */ new Set();
  const mutationObserver = new MutationObserver((mutations) => subscribers.forEach((callback) => callback(mutations)));
  if (globalThis.document) {
    mutationObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter,
      subtree: true
    });
  }
  const observer = {
    subscribe: (callback) => {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
        if (subscribers.size === 0) {
          mutationObserver.disconnect();
          observers[attributes] = void 0;
        }
      };
    }
  };
  observers[attributes] = observer;
  return observer;
};
const getClosestElement = (base, selector) => {
  let currentElement = base;
  while (currentElement) {
    const element = currentElement.closest?.(selector);
    if (element) {
      return element;
    }
    const rootElement = currentElement.getRootNode?.();
    if (rootElement === globalThis.document) {
      return;
    }
    currentElement = rootElement.host;
  }
  return;
};
function unsafeGetCalciteModeName(el) {
  const closestElWithMode = getClosestElement(el, `.calcite-mode-dark, .calcite-mode-light, .calcite-mode-auto`);
  return closestElWithMode?.classList.contains("calcite-mode-dark") || closestElWithMode?.classList.contains("calcite-mode-auto") && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}
const unsafeGetElementDirection = (el) => (
  //#endregion unsafeGetElementDirection
  getElementAttribute(el, "dir", "ltr")
);
const getElementAttribute = (el, attributeName, fallbackValue) => {
  const closest = getClosestElement(el, `[${attributeName}]`);
  return closest?.getAttribute(attributeName) ?? fallbackValue;
};
const focusElement = async (el) => {
  if (el == null) {
    return;
  }
  if (hasSetFocus(el)) {
    await el.setFocus();
  } else {
    el.focus();
  }
};
const hasSetFocus = (ref) => typeof ref.setFocus === "function";
const setFocusOnElement = (ref, selector) => {
  if (!ref?.shadowRoot) {
    return;
  }
  if (ref.hasAttribute("hydrated") || ref.hasAttribute("calcite-hydrated")) {
    setFocus(ref, selector);
    return;
  }
  void Promise.resolve(ref.componentOnReady?.()).then(() => setFocus(ref, selector));
};
const isElement = (ref) => ref.nodeType === Node.ELEMENT_NODE;
const setFocus = (ref, selector = "") => {
  if (!isElement(ref)) {
    return false;
  }
  if (ref.matches(selector)) {
    if (hasSetFocus(ref)) {
      setTimeout(() => void ref.setFocus(), 0);
    }
    return true;
  }
  for (const child of ref.children) {
    if (setFocus(child, selector)) {
      return true;
    }
  }
  const shadowRoot = ref.shadowRoot;
  if (shadowRoot) {
    for (const child of shadowRoot.children) {
      if (setFocus(child, selector)) {
        return true;
      }
    }
  }
  return false;
};



/***/ }),

/***/ "./node_modules/@arcgis/toolkit/dist/intl/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@arcgis/toolkit/dist/intl/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultLocale: () => (/* binding */ defaultLocale),
/* harmony export */   fetchT9nStringsBundle: () => (/* binding */ fetchT9nStringsBundle),
/* harmony export */   getElementLocale: () => (/* binding */ getElementLocale),
/* harmony export */   normalizeLocale: () => (/* binding */ normalizeLocale),
/* harmony export */   startLocaleObserver: () => (/* binding */ startLocaleObserver),
/* harmony export */   supportedLocales: () => (/* binding */ supportedLocales)
/* harmony export */ });
/* harmony import */ var _dom_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom/index.js */ "./node_modules/@arcgis/toolkit/dist/dom/index.js");

const supportedLocalesArray = "ar,bg,bs,ca,cs,da,de,el,en,es,et,fi,fr,he,hr,hu,id,it,ja,ko,lt,lv,nl,nb,no,pl,pt-BR,pt-PT,ro,ru,sk,sl,sr,sv,th,tr,uk,vi,zh-CN,zh-HK,zh-TW".split(
  ","
);
const supportedLocales = (
  //#endregion supportedLocales
  /* @__PURE__ */ new Set(supportedLocalesArray)
);
const defaultLocale = "en";
const localeEquivalencies = {
  //#region localeEquivalencies
  // We use `pt-PT` as it will have the same translations as `pt`, which has no corresponding bundle
  pt: "pt-PT",
  // We support both 'nb' and 'no' (BCP 47) for Norwegian but only `no` has corresponding bundle
  nb: "no",
  // We support both 'nn' and 'no' (BCP 47) for Norwegian but only `no` has corresponding bundle
  // See https://devtopia.esri.com/WebGIS/arcgis-web-components/issues/4667
  nn: "no",
  // We use `zh-CN` as base translation for chinese locales which has no corresponding bundle.
  zh: "zh-CN"
  //#endregion localeEquivalencies
};
const fetchT9nStringsBundle = async (locale, assetsPath, prefix = "") => {
  const path = `${assetsPath}/${prefix}`;
  const filePath = `${path}${locale}.json`;
  t9nStringsCache[filePath] ?? (t9nStringsCache[filePath] = fetchBundle(locale, path));
  return await t9nStringsCache[filePath];
};
const t9nStringsCache = {};
const fetchBundle = async (locale, path) => {
  const filePath = `${path}${locale}.json`;
  try {
    const response = await fetch(filePath);
    if (response.ok) {
      return await response.json();
    }
  } catch (error) {
    if (true) {
      const is404ViteFallback = String(error).includes(`Unexpected token '<', "<!doctype "... is not valid JSON`);
      if (is404ViteFallback) {
        console.error(`[404] Localization strings not found at ${filePath}`);
      } else {
        console.error(`Error fetching localization strings at ${filePath}`, error);
      }
    } else // removed by dead control flow
{}
    return {};
  }
  if (locale === defaultLocale) {
    return {};
  }
  return await fetchBundle(defaultLocale, path);
};
const getElementLocale = (element) => {
  const lang = (0,_dom_index_js__WEBPACK_IMPORTED_MODULE_0__.getElementAttribute)(element, "lang", globalThis.navigator?.language || defaultLocale);
  return { lang, t9nLocale: normalizeLocale(lang) };
};
const normalizeLocale = (lang) => {
  const [rawLanguageCode, regionCode] = lang.split("-");
  const languageCode = rawLanguageCode.toLowerCase();
  let normalizedLocale = languageCode;
  if (regionCode) {
    normalizedLocale = `${languageCode}-${regionCode.toUpperCase()}`;
  }
  normalizedLocale = localeEquivalencies[normalizedLocale] ?? normalizedLocale;
  if (supportedLocales.has(normalizedLocale)) {
    return normalizedLocale;
  }
  if (regionCode) {
    return normalizeLocale(languageCode);
  }
  return defaultLocale;
};
const startLocaleObserver = (element, getAssetsPath, onUpdated, assetName) => {
  let result = void 0;
  const callback = () => updateComponentLocaleState(element, getAssetsPath(), assetName).then((newResult) => {
    if (result?.lang !== newResult.lang || result.t9nLocale !== newResult.t9nLocale || result.t9nStrings !== newResult.t9nStrings) {
      onUpdated(newResult);
    }
    result = newResult;
  }).catch(console.error);
  queueMicrotask(callback);
  return (0,_dom_index_js__WEBPACK_IMPORTED_MODULE_0__.observeAncestorsMutation)(element, ["lang"], callback);
};
const updateComponentLocaleState = async (element, assetsPath, assetName = element.localName.split("-").slice(1).join("-")) => {
  const { lang, t9nLocale } = getElementLocale(element);
  const t9nAssetsPath = `${assetsPath}/${assetName}/t9n`;
  const prefix = `messages.`;
  const t9nStrings = (
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    assetName === null ? {} : await fetchT9nStringsBundle(t9nLocale, t9nAssetsPath, prefix)
  );
  return { lang, t9nLocale, t9nStrings };
};



/***/ })

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYXJjZ2lzX2x1bWluYV9kaXN0X2NvbnRyb2xsZXJzX2luZGV4X2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0g7QUFDM0U7QUFDNEg7QUFDN0c7QUFDSDtBQUNqQztBQUMyQjtBQUMwQjtBQUNQO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNEQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtRUFBbUI7QUFDekI7QUFDQTtBQUNBLFVBQVUsbUVBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDREQUFZO0FBQzFCO0FBQ0EsdUNBQXVDLHNEQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtRUFBeUI7QUFDdEQ7QUFDQSxFQUFFLG1FQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0VBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkVBQXdCO0FBQ25DLEdBQUc7QUFDSCxNQUFNLEtBQXFDLElBQUksd0VBQWlCO0FBQ2hFLElBQUksMERBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLG1CQUFtQixzRUFBZ0I7QUFDbkMsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLHlFQUFtQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQWlCO0FBQ3JDLHVCQUF1QiwwREFBa0I7QUFDekMsTUFBTSxLQUFxQyxJQUFJLHdFQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUssbURBQW1ELE1BQU0sS0FBSyx1QkFBdUI7QUFDL0k7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0EsR0FBRztBQUNILE1BQU0sS0FBcUMsSUFBSSx3RUFBaUI7QUFDaEUsSUFBSSwwREFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOE9BQThPO0FBQzlPO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBb0I7QUF5QjFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25SZ0s7QUFDekc7QUFDekQ7QUFDQSw2QkFBNkIsbUVBQXlCO0FBQ3REO0FBQ0E7QUFDQSxFQUFFLG1FQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1FQUF5QjtBQUMzQjtBQUNBLFNBQVMsMERBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1Q0FBdUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUVBQWM7QUFDcEI7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFHRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNURGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0JFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyTThFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsR0FBRyxPQUFPO0FBQ3ZDLHNCQUFzQixLQUFLLEVBQUUsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUssRUFBRSxPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0EsaUVBQWlFLFNBQVM7QUFDMUUsUUFBUTtBQUNSLGdFQUFnRSxTQUFTO0FBQ3pFO0FBQ0EsTUFBTSxLQUFLO0FBQUEsRUFFTjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtFQUFtQjtBQUNsQyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWEsR0FBRyx5QkFBeUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFNBQVMsdUVBQXdCO0FBQ2pDO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QiwyQkFBMkIsV0FBVyxHQUFHLFVBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsV0FBVztBQUNYO0FBUUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVjaXNpb25mYXJtcy8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2x1bWluYS9kaXN0L2NvbnRyb2xsZXJzL2luZGV4LmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvbHVtaW5hL2Rpc3QvcHJveHlFeHBvcnRzLUQ5MDZURXRMLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvdG9vbGtpdC9kaXN0L2RvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wcmVjaXNpb25mYXJtcy8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL3Rvb2xraXQvZGlzdC9pbnRsL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEMgYXMgQ29udHJvbGxlciwgdCBhcyB0cmFja0tleSwgYSBhcyBjcmVhdGVFdmVudEZhY3RvcnksIHAgYXMgcHJvcGVydHlUcmFja1Jlc29sdmUgfSBmcm9tIFwiLi4vQ29udHJvbGxlci1mdEFFY2RtSS5qc1wiO1xuaW1wb3J0IHsgRywgZCwgYiB9IGZyb20gXCIuLi9Db250cm9sbGVyLWZ0QUVjZG1JLmpzXCI7XG5pbXBvcnQgeyBzIGFzIHNldEFtYmllbnRDb21wb25lbnQsIGkgYXMgaXNQcm9taXNlLCBiIGFzIHNldFBhcmVudENvbnRyb2xsZXIsIGQgYXMgcmV0cmlldmVQYXJlbnRDb250cm9sbGVycywgciBhcyByZXRyaWV2ZUNvbXBvbmVudCB9IGZyb20gXCIuLi9Db250cm9sbGVySW50ZXJuYWxzLUNXUXJmRUE4LmpzXCI7XG5pbXBvcnQgeyBmLCBlLCBjLCBoLCBnIH0gZnJvbSBcIi4uL0NvbnRyb2xsZXJJbnRlcm5hbHMtQ1dRcmZFQTguanNcIjtcbmltcG9ydCB7IHAgYXMgcHJveHlFeHBvcnRzIH0gZnJvbSBcIi4uL3Byb3h5RXhwb3J0cy1EOTA2VEV0TC5qc1wiO1xuaW1wb3J0IHsgaXNTZXJ2ZXIgfSBmcm9tIFwibGl0XCI7XG5pbXBvcnQgeyBpc0VzcmlJbnRlcm5hbEVudiB9IGZyb20gXCJAYXJjZ2lzL3Rvb2xraXQvZXJyb3JcIjtcbmltcG9ydCB7IG9ic2VydmVBbmNlc3RvcnNNdXRhdGlvbiwgZ2V0RWxlbWVudEF0dHJpYnV0ZSB9IGZyb20gXCJAYXJjZ2lzL3Rvb2xraXQvZG9tXCI7XG5pbXBvcnQgeyBnZXRFbGVtZW50TG9jYWxlLCBzdGFydExvY2FsZU9ic2VydmVyIH0gZnJvbSBcIkBhcmNnaXMvdG9vbGtpdC9pbnRsXCI7XG5jb25zdCBtYWtlQ29udHJvbGxlciA9IChjb25zdHJ1Y3RvcikgPT4gcHJveHkodm9pZCAwLCBjb25zdHJ1Y3Rvcik7XG5jb25zdCBtYWtlR2VuZXJpY0NvbnRyb2xsZXIgPSAoY29uc3RydWN0b3IpID0+IChjb21wb25lbnQpID0+IHByb3h5KFxuICBjb21wb25lbnQsXG4gIC8qKlxuICAgKiBHZW5lcmljQ29udHJvbGxlciBpcyBpZGVudGljYWwgdG8gQ29udHJvbGxlciwgaW4gYWxsIGV4Y2VwdCBmb3IgdHlwaW5nLlxuICAgKiBTbyBkb2luZyBhIHR5cGUtY2FzdCBoZXJlIHNvIGFzIG5vdCB0byBuZWVkbGVzc2x5IGFkZCBvbmUgbW9yZSBvYmplY3RcbiAgICogdG8gdGhlIHByb3RvdHlwZSBjaGFpblxuICAgKi9cbiAgY29uc3RydWN0b3Jcbik7XG5jbGFzcyBGdW5jdGlvbmFsQ29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIGNvbnN0cnVjdG9yKSB7XG4gICAgc3VwZXIoY29tcG9uZW50KTtcbiAgICBjb25zdCBvcmlnaW5hbEV4cG9ydHMgPSB0aGlzLmV4cG9ydHM7XG4gICAgdHJ5IHtcbiAgICAgIHNldEFtYmllbnRDb21wb25lbnQodGhpcy5jb21wb25lbnQpO1xuICAgICAgY29uc3QgdmFsdWUgPSBjb25zdHJ1Y3Rvcih0aGlzLmNvbXBvbmVudCwgdGhpcyk7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RvckNoYW5nZWRFeHBvcnRzID0gdGhpcy5leHBvcnRzICE9PSBvcmlnaW5hbEV4cG9ydHM7XG4gICAgICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICBpZiAoIWNvbnN0cnVjdG9yQ2hhbmdlZEV4cG9ydHMpIHtcbiAgICAgICAgICB0aGlzLnNldFByb3Zpc2lvbmFsRXhwb3J0cyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB2YWx1ZS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICB0aGlzLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgICAgc3VwZXIuY2F0Y2hVcExpZmVjeWNsZSgpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICB0aGlzLlAucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Mb2FkKGFzeW5jICgpID0+IGF3YWl0IHJlc29sdmVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY29uc3RydWN0b3JDaGFuZ2VkRXhwb3J0cyB8fCB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhpcy5leHBvcnRzID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gc3VwZXIuY2F0Y2hVcExpZmVjeWNsZSgpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5QLnJlamVjdChlcnJvcik7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgLyoqIE5vb3AgLSB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCAqL1xuICBjYXRjaFVwTGlmZWN5Y2xlKCkge1xuICAgIHJldHVybjtcbiAgfVxufVxuY29uc3QgcHJveHkgPSBwcm94eUV4cG9ydHMoRnVuY3Rpb25hbENvbnRyb2xsZXIpO1xuY29uc3QgdXNlV2F0Y2hBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMsIGNhbGxiYWNrKSA9PiBuZXcgQXR0cmlidXRlV2F0Y2hDb250cm9sbGVyKGF0dHJpYnV0ZXMsIGNhbGxiYWNrKTtcbmNsYXNzIEF0dHJpYnV0ZVdhdGNoQ29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuICAjb2JzZXJ2ZXI7XG4gICNhdHRyaWJ1dGVzO1xuICAjY2FsbGJhY2s7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZXMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy4jY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLiNvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgIG11dGF0aW9ucy5mb3JFYWNoKChtdXRhdGlvbikgPT4ge1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5pbmNsdWRlcyhtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCxcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmVsLmdldEF0dHJpYnV0ZShtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKSxcbiAgICAgICAgICAgIG11dGF0aW9uLm9sZFZhbHVlLFxuICAgICAgICAgICAgbXV0YXRpb24uYXR0cmlidXRlTmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGhvc3RDb25uZWN0ZWQoKSB7XG4gICAgdGhpcy4jYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5lbC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgICAgICB0aGlzLiNjYWxsYmFjay5jYWxsKHRoaXMuY29tcG9uZW50LCBudWxsLCB0aGlzLmNvbXBvbmVudC5lbC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSwgYXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLiNvYnNlcnZlci5vYnNlcnZlKHRoaXMuY29tcG9uZW50LmVsLCB7XG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVGaWx0ZXI6IHRoaXMuI2F0dHJpYnV0ZXNcbiAgICB9KTtcbiAgfVxuICBob3N0RGlzY29ubmVjdGVkKCkge1xuICAgIHRoaXMuI29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuY29uc3QgbG9hZCA9IG1ha2VDb250cm9sbGVyO1xuY29uc3QgdG9GdW5jdGlvbiA9IChDbGFzcykgPT4gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgYW1iaWVudENvbnRyb2xsZXJzID0gcmV0cmlldmVQYXJlbnRDb250cm9sbGVycygpO1xuICBjb25zdCBpbnN0YW5jZSA9IG5ldyBDbGFzcyguLi5hcmdzKTtcbiAgc2V0UGFyZW50Q29udHJvbGxlcihhbWJpZW50Q29udHJvbGxlcnMuYXQoLTEpKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufTtcbmNvbnN0IHVzZU1lZGlhID0gKHF1ZXJ5KSA9PiBtYWtlQ29udHJvbGxlcigoX2NvbXBvbmVudCwgY29udHJvbGxlcikgPT4ge1xuICBjb25zdCBtZWRpYSA9IGdsb2JhbFRoaXMubWF0Y2hNZWRpYShxdWVyeSk7XG4gIGNvbnN0IGNoYW5nZWQgPSAoKSA9PiB7XG4gICAgY29udHJvbGxlci5leHBvcnRzID0gbWVkaWEubWF0Y2hlcztcbiAgfTtcbiAgY2hhbmdlZCgpO1xuICBjb250cm9sbGVyLm9uTGlmZWN5Y2xlKCgpID0+IHtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGNoYW5nZWQpO1xuICAgIHJldHVybiAoKSA9PiBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGNoYW5nZWQpO1xuICB9KTtcbiAgcmV0dXJuIHZvaWQgMDtcbn0pO1xuY29uc3QgZGVmYXVsdERpcmVjdGlvbiA9IFwibHRyXCI7XG5jb25zdCB1c2VEaXJlY3Rpb24gPSAoKSA9PiBtYWtlQ29udHJvbGxlcigoY29tcG9uZW50LCBjb250cm9sbGVyKSA9PiB7XG4gIGNvbnRyb2xsZXIuZXhwb3J0cyA9IGRlZmF1bHREaXJlY3Rpb247XG4gIGNvbnRyb2xsZXIub25MaWZlY3ljbGUoKCkgPT4ge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgY29uc3QgZGlyID0gZ2V0RWxlbWVudEF0dHJpYnV0ZShjb21wb25lbnQuZWwsIFwiZGlyXCIsIGRlZmF1bHREaXJlY3Rpb24pO1xuICAgICAgY29udHJvbGxlci5leHBvcnRzID0gZGlyID09PSBcInJ0bFwiID8gXCJydGxcIiA6IFwibHRyXCI7XG4gICAgfTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybiBvYnNlcnZlQW5jZXN0b3JzTXV0YXRpb24oY29tcG9uZW50LmVsLCBbXCJkaXJcIl0sIGNhbGxiYWNrKTtcbiAgfSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNFc3JpSW50ZXJuYWxFbnYoKSkge1xuICAgIHRyYWNrS2V5KFxuICAgICAgY29tcG9uZW50LFxuICAgICAgKHJlc29sdmVkKSA9PiB7XG4gICAgICAgIGlmIChyZXNvbHZlZD8ua2V5ID09PSBcImRpclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJEbyBub3QgYXNzaWduIHRoaXMgY29udHJvbGxlciB0byBhIHByb3AgY2FsbGVkIGBkaXJgIGFzIHRoYXQgd2lsbCBvdmVyd3JpdGUgdGhlIEhUTUxFbGVtZW50J3MgYnVpbHQtaW4gYGRpcmAgYXR0cmlidXRlIC0gY29tcG9uZW50IHNob3VsZCBub3QgYmUgc2V0dGluZyB0aGUgYGRpcmAgYXR0cmlidXRlIG9uIGl0c2VsZi4gSW5zdGVhZCwgYXNzaWduIHRoaXMgY29udHJvbGxlciB0byBhIHByb3BlcnR5IGNhbGxlZCBgZGlyZWN0aW9uYC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb250cm9sbGVyLmV4cG9ydHNcbiAgICApO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59KTtcbmNvbnN0IG1ha2VUOW5Db250cm9sbGVyID0gKGdldEFzc2V0UGF0aCkgPT4gKG9wdGlvbnMgPSB7fSkgPT4gKFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmNcbiAgbWFrZUNvbnRyb2xsZXIoKGNvbXBvbmVudCwgY29udHJvbGxlcikgPT4ge1xuICAgIGNvbnN0IGxvY2FsZSA9IGdldEVsZW1lbnRMb2NhbGUoY29tcG9uZW50LmVsKTtcbiAgICBjb25zdCBwZW5kaW5nID0geyBbXCJfbGFuZ1wiXTogbG9jYWxlLmxhbmcsIFtcIl90OW5Mb2NhbGVcIl06IGxvY2FsZS50OW5Mb2NhbGUsIFtcIl9sb2FkaW5nXCJdOiB0cnVlIH07XG4gICAgY29uc3QgY29tcG9uZW50V2l0aE92ZXJyaWRlcyA9IGNvbXBvbmVudDtcbiAgICBjb250cm9sbGVyLm9uTGlmZWN5Y2xlKFxuICAgICAgKCkgPT4gc3RhcnRMb2NhbGVPYnNlcnZlcihcbiAgICAgICAgY29tcG9uZW50LmVsLFxuICAgICAgICAoKSA9PiBnZXRBc3NldFBhdGgoXCIuL2Fzc2V0c1wiKSxcbiAgICAgICAgKHsgdDluTG9jYWxlLCB0OW5TdHJpbmdzLCBsYW5nIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB3aXRob3V0T3ZlcnJpZGVzID0ge1xuICAgICAgICAgICAgLi4udDluU3RyaW5ncyxcbiAgICAgICAgICAgIFtcIl9sYW5nXCJdOiBsYW5nLFxuICAgICAgICAgICAgW1wiX3Q5bkxvY2FsZVwiXTogdDluTG9jYWxlLFxuICAgICAgICAgICAgW1wiX2xvYWRpbmdcIl06IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb250cm9sbGVyLmV4cG9ydHMgPSB3aXRob3V0T3ZlcnJpZGVzO1xuICAgICAgICAgIGNvbnN0IGxhYmVsID0gdDluU3RyaW5ncy5jb21wb25lbnRMYWJlbDtcbiAgICAgICAgICBpZiAodHlwZW9mIGxhYmVsID09PSBcInN0cmluZ1wiICYmIFwibGFiZWxcIiBpbiBjb21wb25lbnQgJiYgY29tcG9uZW50LmxhYmVsID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5sYWJlbCA/Pz0gbGFiZWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFwcGx5T3ZlcnJpZGVzKGNvbXBvbmVudFdpdGhPdmVycmlkZXMubWVzc2FnZU92ZXJyaWRlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMubmFtZVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3QgYXBwbHlPdmVycmlkZXMgPSAobWVzc2FnZU92ZXJyaWRlcykgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY29udHJvbGxlci5leHBvcnRzO1xuICAgICAgY29uc3QgcmF3TWVzc2FnZXMgPSBjdXJyZW50VmFsdWVbXCJfb3JpZ2luYWxcIl0gPz8gY3VycmVudFZhbHVlO1xuICAgICAgY29uc3QgdXBkYXRlZCA9IGRlZXBNZXJnZShyYXdNZXNzYWdlcywgbWVzc2FnZU92ZXJyaWRlcyk7XG4gICAgICBpZiAobWVzc2FnZU92ZXJyaWRlcykge1xuICAgICAgICB1cGRhdGVkW1wiX29yaWdpbmFsXCJdID0gcmF3TWVzc2FnZXM7XG4gICAgICB9XG4gICAgICBjb250cm9sbGVyLmV4cG9ydHMgPSB1cGRhdGVkO1xuICAgIH07XG4gICAgaWYgKFwibWVzc2FnZU92ZXJyaWRlc1wiIGluIGNvbXBvbmVudFdpdGhPdmVycmlkZXMpIHtcbiAgICAgIGNvbnRyb2xsZXIub25VcGRhdGUoKGNoYW5nZXMpID0+IHtcbiAgICAgICAgaWYgKGNoYW5nZXMuaGFzKFwibWVzc2FnZU92ZXJyaWRlc1wiKSkge1xuICAgICAgICAgIGFwcGx5T3ZlcnJpZGVzKGNvbXBvbmVudFdpdGhPdmVycmlkZXMubWVzc2FnZU92ZXJyaWRlcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ibG9ja2luZykge1xuICAgICAgY29udHJvbGxlci5zZXRQcm92aXNpb25hbEV4cG9ydHMocGVuZGluZywgZmFsc2UpO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucmVhZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwZW5kaW5nO1xuICAgIH1cbiAgfSlcbik7XG5jb25zdCBkZWVwTWVyZ2UgPSAob3JpZ2luYWwsIG92ZXJ3cml0ZXMpID0+IHtcbiAgaWYgKCFvdmVyd3JpdGVzKSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsO1xuICB9XG4gIGNvbnN0IG1lcmdlZCA9IHsgLi4ub3JpZ2luYWwgfTtcbiAgT2JqZWN0LmVudHJpZXMob3ZlcndyaXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgbWVyZ2VkW2tleV0gPSBkZWVwTWVyZ2Uob3JpZ2luYWxba2V5XSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZWRba2V5XSA9IHZhbHVlID8/IG9yaWdpbmFsW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1lcmdlZDtcbn07XG5jb25zdCB1c2VQcm9wZXJ0eUNoYW5nZSA9IChfY29tcG9uZW50KSA9PiBwcm9wZXJ0eUNoYW5nZUNvbnRyb2xsZXI7XG5jb25zdCBldmVudE5hbWUgPSBcImFyY2dpc1Byb3BlcnR5Q2hhbmdlXCI7XG5jb25zdCBwcm9wZXJ0eUNoYW5nZUNvbnRyb2xsZXIgPSAoLi4udG9XYXRjaCkgPT4ge1xuICBjb25zdCBjb21wb25lbnQgPSByZXRyaWV2ZUNvbXBvbmVudCgpO1xuICBjb25zdCBldmVudEVtaXR0ZXIgPSBjcmVhdGVFdmVudEZhY3RvcnkoZXZlbnROYW1lLCB2b2lkIDAsIGNvbXBvbmVudCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNFc3JpSW50ZXJuYWxFbnYoKSkge1xuICAgIHRvV2F0Y2guZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5lbGVtZW50UHJvcGVydGllcy5nZXQocHJvcCk7XG4gICAgICBjb25zdCBpc1Byb3AgPSBkZXNjcmlwdG9yICE9PSB2b2lkIDAgJiYgZGVzY3JpcHRvci5zdGF0ZSAhPT0gdHJ1ZTtcbiAgICAgIGlmICghaXNQcm9wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRm9yIHVzZVByb3BlcnR5Q2hhbmdlIHRvIGVtaXQgZXZlbnQgb24gXCIke3Byb3B9XCIgcHJvcGVydHkgY2hhbmdlLCB5b3Ugc2hvdWxkIGFkZCBAcHJvcGVydHkoKSB0byAke3Byb3B9IGluICR7Y29tcG9uZW50LmVsLmxvY2FsTmFtZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGV0IGlzRmlyc3QgPSB0cnVlO1xuICBjb21wb25lbnQubWFuYWdlci5vblVwZGF0ZWQoKGNoYW5nZXMpID0+IHtcbiAgICBpZiAoaXNGaXJzdCB8fCAhY29tcG9uZW50LmVsLmlzQ29ubmVjdGVkKSB7XG4gICAgICBpc0ZpcnN0ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBvZiB0b1dhdGNoKSB7XG4gICAgICBpZiAoY2hhbmdlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoeyBuYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNFc3JpSW50ZXJuYWxFbnYoKSkge1xuICAgIHRyYWNrS2V5KFxuICAgICAgY29tcG9uZW50LFxuICAgICAgKHJlc29sdXRpb24pID0+IHtcbiAgICAgICAgaWYgKHJlc29sdXRpb24gPT09IHZvaWQgMCB8fCByZXNvbHV0aW9uLmlzUmVhY3RpdmUgfHwgcmVzb2x1dGlvbi5rZXkgIT09IGV2ZW50TmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGb3IgY29uc2lzdGVuY3ksIHVzZVByb3BlcnR5Q2hhbmdlIG11c3QgYmUgYXNzaWduZWQgdG8gYW4gYXJjZ2lzUHJvcGVydHlDaGFuZ2UgcHJvcGVydHkgYW5kIHRoYXQgcHJvcGVydHkgc2hvdWxkIG5vdCBoYXZlIEBwcm9wZXJ0eSgpIG9yIEBzdGF0ZSgpIGRlY29yYXRvcnM6IGFyY2dpc1Byb3BlcnR5Q2hhbmdlID0gdXNlUHJvcGVydHlDaGFuZ2U8dGhpcz4oKShcInByb3AxXCIsIFwicHJvcDJcIik7YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBldmVudEVtaXR0ZXJcbiAgICApO1xuICB9XG4gIHJldHVybiBldmVudEVtaXR0ZXI7XG59O1xuY29uc3Qga2V5VHJhY2tSZXNvbHZlID0gcHJvcGVydHlUcmFja1Jlc29sdmU7XG5leHBvcnQge1xuICBDb250cm9sbGVyLFxuICBHIGFzIEdlbmVyaWNDb250cm9sbGVyLFxuICBmIGFzIGJ5cGFzc1JlYWRPbmx5LFxuICBlIGFzIGJ5cGFzc1NldHRlcixcbiAgYyBhcyBjb250cm9sbGVyU3ltYm9sLFxuICBoIGFzIGdldENvbnRyb2xsZXJzQ291bnQsXG4gIGcgYXMgaXNDb250cm9sbGVyLFxuICBrZXlUcmFja1Jlc29sdmUsXG4gIGxvYWQsXG4gIG1ha2VDb250cm9sbGVyLFxuICBtYWtlR2VuZXJpY0NvbnRyb2xsZXIsXG4gIG1ha2VUOW5Db250cm9sbGVyLFxuICBwcm9wZXJ0eVRyYWNrUmVzb2x2ZSxcbiAgcHJveHlFeHBvcnRzLFxuICByZXRyaWV2ZUNvbXBvbmVudCxcbiAgdG9GdW5jdGlvbixcbiAgdHJhY2tLZXksXG4gIGQgYXMgdHJhY2tQcm9wS2V5LFxuICBiIGFzIHRyYWNrUHJvcGVydHlLZXksXG4gIHVzZURpcmVjdGlvbixcbiAgdXNlTWVkaWEsXG4gIHVzZVByb3BlcnR5Q2hhbmdlLFxuICB1c2VXYXRjaEF0dHJpYnV0ZXNcbn07XG4iLCJpbXBvcnQgeyBiIGFzIHNldFBhcmVudENvbnRyb2xsZXIsIGQgYXMgcmV0cmlldmVQYXJlbnRDb250cm9sbGVycywgaiBhcyBzZXRBbWJpZW50Q2hpbGRDb250cm9sbGVyLCBmIGFzIGJ5cGFzc1JlYWRPbmx5IH0gZnJvbSBcIi4vQ29udHJvbGxlckludGVybmFscy1DV1FyZkVBOC5qc1wiO1xuaW1wb3J0IHsgdCBhcyB0cmFja0tleSB9IGZyb20gXCIuL0NvbnRyb2xsZXItZnRBRWNkbUkuanNcIjtcbmNvbnN0IHByb3h5RXhwb3J0cyA9IChDbGFzcykgPT4gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgYW1iaWVudENvbnRyb2xsZXJzID0gcmV0cmlldmVQYXJlbnRDb250cm9sbGVycygpO1xuICBjb25zdCBpbnN0YW5jZSA9IG5ldyBDbGFzcyguLi5hcmdzKTtcbiAgY29uc3QgaW5pdGlhbEV4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuICBzZXRQYXJlbnRDb250cm9sbGVyKGFtYmllbnRDb250cm9sbGVycy5hdCgtMSkpO1xuICBjb25zdCBtYW5hZ2VyID0gaW5zdGFuY2UuY29tcG9uZW50Lm1hbmFnZXI7XG4gIG1hbmFnZXIuVyhpbnN0YW5jZSwgaW5pdGlhbEV4cG9ydHMpO1xuICBpbnN0YW5jZS53YXRjaEV4cG9ydHMobWFuYWdlci5XLmJpbmQobWFuYWdlciwgaW5zdGFuY2UpKTtcbiAgc2V0QW1iaWVudENoaWxkQ29udHJvbGxlcihpbnN0YW5jZSk7XG4gIGNvbnN0IGhvc3RDYW5kaWRhdGVzID0gW2luc3RhbmNlLmNvbXBvbmVudCwgLi4uYW1iaWVudENvbnRyb2xsZXJzXS5yZXZlcnNlKCk7XG4gIHJldHVybiB0cmFja0tleShcbiAgICBob3N0Q2FuZGlkYXRlcyxcbiAgICAocmVzb2x1dGlvbikgPT4gcmVzb2x1dGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0UHJveHkoaW5zdGFuY2UsIHJlc29sdXRpb24sIGluaXRpYWxFeHBvcnRzKSxcbiAgICBpbml0aWFsRXhwb3J0c1xuICApO1xufTtcbmNvbnN0IHNldFByb3h5ID0gKGNvbnRyb2xsZXIsIHsgaG9zdCwga2V5LCBpc1JlYWN0aXZlOiBhc3NpZ25lZFRvUHJvcCB9LCBpbml0aWFsRXhwb3J0cykgPT4ge1xuICBjb25zdCBnZW5lcmljSG9zdCA9IGhvc3Q7XG4gIGNvbnN0IGNvbnRyb2xsZXJWYWx1ZUNoYW5nZWQgPSBnZW5lcmljSG9zdFtrZXldICE9PSBjb250cm9sbGVyLmV4cG9ydHM7XG4gIGNvbnN0IGhvc3RWYWx1ZUNoYW5nZWQgPSBnZW5lcmljSG9zdFtrZXldICE9PSBpbml0aWFsRXhwb3J0cztcbiAgY29uc3QgY29udHJvbGxlclVwZGF0ZWRFeHBvcnRzID0gaW5pdGlhbEV4cG9ydHMgIT09IGNvbnRyb2xsZXIuZXhwb3J0cztcbiAgaWYgKGNvbnRyb2xsZXJWYWx1ZUNoYW5nZWQgJiYgIWhvc3RWYWx1ZUNoYW5nZWQgJiYgY29udHJvbGxlclVwZGF0ZWRFeHBvcnRzKSB7XG4gICAgZ2VuZXJpY0hvc3Rba2V5XSA9IGNvbnRyb2xsZXIuZXhwb3J0cztcbiAgfVxuICBjb25zdCBpc1Byb3h5RXhwb3J0c09uQ29tcG9uZW50ID0gaG9zdCA9PT0gY29udHJvbGxlci5jb21wb25lbnQ7XG4gIGlmIChpc1Byb3h5RXhwb3J0c09uQ29tcG9uZW50KSB7XG4gICAgaWYgKGFzc2lnbmVkVG9Qcm9wKSB7XG4gICAgICBjb25zdCBtYW5hZ2VyID0gY29udHJvbGxlci5jb21wb25lbnQubWFuYWdlcjtcbiAgICAgIGlmIChob3N0VmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgIG1hbmFnZXIuVyhjb250cm9sbGVyLCBnZW5lcmljSG9zdFtrZXldKTtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIub25VcGRhdGUoKGNoYW5nZXMpID0+IHtcbiAgICAgICAgaWYgKGNoYW5nZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdlbmVyaWNIb3N0W2tleV07XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBjb250cm9sbGVyLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuVyhjb250cm9sbGVyLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29udHJvbGxlci5PID0gYXNzaWduZWRUb1Byb3AgPyB2b2lkIDAgOiBrZXk7XG4gIH1cbiAgY29uc3QgaXNSZWFkT25seSA9IGNvbnRyb2xsZXIuY29tcG9uZW50LmNvbnN0cnVjdG9yLmVsZW1lbnRQcm9wZXJ0aWVzLmdldChrZXkpPy5yZWFkT25seTtcbiAgY29udHJvbGxlci53YXRjaEV4cG9ydHMoKCkgPT4ge1xuICAgIGlmIChnZW5lcmljSG9zdFtrZXldID09PSBjb250cm9sbGVyLmV4cG9ydHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgIGJ5cGFzc1JlYWRPbmx5KCgpID0+IHtcbiAgICAgICAgZ2VuZXJpY0hvc3Rba2V5XSA9IGNvbnRyb2xsZXIuZXhwb3J0cztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5lcmljSG9zdFtrZXldID0gY29udHJvbGxlci5leHBvcnRzO1xuICAgIH1cbiAgfSk7XG59O1xuZXhwb3J0IHtcbiAgcHJveHlFeHBvcnRzIGFzIHBcbn07XG4iLCJmdW5jdGlvbiBzbG90Q2hhbmdlSGFzQ29udGVudChldmVudCkge1xuICByZXR1cm4gc2xvdENoYW5nZUhhc0Fzc2lnbmVkRWxlbWVudChldmVudCkgfHwgc2xvdENoYW5nZUhhc1RleHRDb250ZW50KGV2ZW50KTtcbn1cbmZ1bmN0aW9uIHNsb3RDaGFuZ2VHZXRUZXh0Q29udGVudChldmVudCkge1xuICByZXR1cm4gc2xvdENoYW5nZUdldEFzc2lnbmVkTm9kZXMoZXZlbnQpLmZpbHRlcigobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpLm1hcCgobm9kZSkgPT4gbm9kZS50ZXh0Q29udGVudCkuam9pbihcIlwiKS50cmltKCk7XG59XG5mdW5jdGlvbiBzbG90Q2hhbmdlSGFzVGV4dENvbnRlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIHNsb3RDaGFuZ2VHZXRUZXh0Q29udGVudChldmVudCkubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIHNsb3RDaGFuZ2VIYXNBc3NpZ25lZE5vZGUoZXZlbnQpIHtcbiAgcmV0dXJuIHNsb3RDaGFuZ2VHZXRBc3NpZ25lZE5vZGVzKGV2ZW50KS5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gc2xvdENoYW5nZUdldEFzc2lnbmVkTm9kZXMoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmN1cnJlbnRUYXJnZXQuYXNzaWduZWROb2Rlcyh7XG4gICAgZmxhdHRlbjogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNsb3RDaGFuZ2VIYXNBc3NpZ25lZEVsZW1lbnQoZXZlbnQpIHtcbiAgcmV0dXJuIHNsb3RDaGFuZ2VHZXRBc3NpZ25lZEVsZW1lbnRzKGV2ZW50KS5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gc2xvdENoYW5nZUdldEFzc2lnbmVkRWxlbWVudHMoZXZlbnQsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBnZXRTbG90QXNzaWduZWRFbGVtZW50cyhldmVudC50YXJnZXQsIHNlbGVjdG9yKTtcbn1cbmZ1bmN0aW9uIGdldFNsb3RBc3NpZ25lZEVsZW1lbnRzKHNsb3QsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IGFzc2lnbmVkRWxlbWVudHMgPSBzbG90LmFzc2lnbmVkRWxlbWVudHMoe1xuICAgIGZsYXR0ZW46IHRydWVcbiAgfSk7XG4gIHJldHVybiBzZWxlY3RvciA/IGFzc2lnbmVkRWxlbWVudHMuZmlsdGVyKChlbGVtZW50KSA9PiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSA6IGFzc2lnbmVkRWxlbWVudHM7XG59XG5jb25zdCBjbGFzc2VzID0gKC4uLmNsYXNzZXMyKSA9PiB7XG4gIGNvbnN0IGVmZmVjdGl2ZUNsYXNzZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc2VzMi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGNsYXNzZXMyW2ldO1xuICAgIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBlZmZlY3RpdmVDbGFzc2VzLnB1c2goYXJnKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgZWZmZWN0aXZlQ2xhc3Nlcy5wdXNoLmFwcGx5KGVmZmVjdGl2ZUNsYXNzZXMsIGFyZyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gYXJnKSB7XG4gICAgICAgIGlmIChhcmdbcHJvcF0pIHtcbiAgICAgICAgICBlZmZlY3RpdmVDbGFzc2VzLnB1c2gocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY2xhc3NOYW1lID0gZWZmZWN0aXZlQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgZWZmZWN0aXZlQ2xhc3Nlcy5sZW5ndGggPSAwO1xuICByZXR1cm4gY2xhc3NOYW1lO1xufTtcbmNvbnN0IGluVGFyZ2V0RWxlbWVudCA9IChlbGVtZW50LCB0YXJnZXRFbGVtZW50KSA9PiB7XG4gIGxldCBjdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIHdoaWxlIChjdXJyZW50RWxlbWVudCkge1xuICAgIGlmIChjdXJyZW50RWxlbWVudCA9PT0gdGFyZ2V0RWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghY3VycmVudEVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudEVsZW1lbnQucGFyZW50Tm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgIGN1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQucGFyZW50Tm9kZS5ob3N0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBvYnNlcnZlQW5jZXN0b3JzTXV0YXRpb24gPSAoZWxlbWVudCwgYXR0cmlidXRlRmlsdGVyLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBzdWJzY3JpYmUgPSBvYnNlcnZlKGF0dHJpYnV0ZUZpbHRlcikuc3Vic2NyaWJlO1xuICByZXR1cm4gc3Vic2NyaWJlKChtdXRhdGlvbnMpID0+IHtcbiAgICBjb25zdCBtYXRjaGVkID0gbXV0YXRpb25zLnNvbWUoKG11dGF0aW9uKSA9PiBpblRhcmdldEVsZW1lbnQoZWxlbWVudCwgbXV0YXRpb24udGFyZ2V0KSk7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBvYnNlcnZlcnMgPSB7fTtcbmNvbnN0IG9ic2VydmUgPSAoYXR0cmlidXRlRmlsdGVyKSA9PiB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVGaWx0ZXIuam9pbihcIixcIik7XG4gIGNvbnN0IHByZXZpb3VzT2JzZXJ2ZXIgPSBvYnNlcnZlcnNbYXR0cmlidXRlc107XG4gIGlmIChwcmV2aW91c09ic2VydmVyICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gcHJldmlvdXNPYnNlcnZlcjtcbiAgfVxuICBjb25zdCBzdWJzY3JpYmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiBzdWJzY3JpYmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2sobXV0YXRpb25zKSkpO1xuICBpZiAoZ2xvYmFsVGhpcy5kb2N1bWVudCkge1xuICAgIG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVGaWx0ZXIsXG4gICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgb2JzZXJ2ZXIgPSB7XG4gICAgc3Vic2NyaWJlOiAoY2FsbGJhY2spID0+IHtcbiAgICAgIHN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzdWJzY3JpYmVycy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICBpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIG9ic2VydmVyc1thdHRyaWJ1dGVzXSA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIG9ic2VydmVyc1thdHRyaWJ1dGVzXSA9IG9ic2VydmVyO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59O1xuY29uc3QgZ2V0Q2xvc2VzdEVsZW1lbnQgPSAoYmFzZSwgc2VsZWN0b3IpID0+IHtcbiAgbGV0IGN1cnJlbnRFbGVtZW50ID0gYmFzZTtcbiAgd2hpbGUgKGN1cnJlbnRFbGVtZW50KSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGN1cnJlbnRFbGVtZW50LmNsb3Nlc3Q/LihzZWxlY3Rvcik7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBjb25zdCByb290RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50LmdldFJvb3ROb2RlPy4oKTtcbiAgICBpZiAocm9vdEVsZW1lbnQgPT09IGdsb2JhbFRoaXMuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudEVsZW1lbnQgPSByb290RWxlbWVudC5ob3N0O1xuICB9XG4gIHJldHVybjtcbn07XG5mdW5jdGlvbiB1bnNhZmVHZXRDYWxjaXRlTW9kZU5hbWUoZWwpIHtcbiAgY29uc3QgY2xvc2VzdEVsV2l0aE1vZGUgPSBnZXRDbG9zZXN0RWxlbWVudChlbCwgYC5jYWxjaXRlLW1vZGUtZGFyaywgLmNhbGNpdGUtbW9kZS1saWdodCwgLmNhbGNpdGUtbW9kZS1hdXRvYCk7XG4gIHJldHVybiBjbG9zZXN0RWxXaXRoTW9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKFwiY2FsY2l0ZS1tb2RlLWRhcmtcIikgfHwgY2xvc2VzdEVsV2l0aE1vZGU/LmNsYXNzTGlzdC5jb250YWlucyhcImNhbGNpdGUtbW9kZS1hdXRvXCIpICYmIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzID8gXCJkYXJrXCIgOiBcImxpZ2h0XCI7XG59XG5jb25zdCB1bnNhZmVHZXRFbGVtZW50RGlyZWN0aW9uID0gKGVsKSA9PiAoXG4gIC8vI2VuZHJlZ2lvbiB1bnNhZmVHZXRFbGVtZW50RGlyZWN0aW9uXG4gIGdldEVsZW1lbnRBdHRyaWJ1dGUoZWwsIFwiZGlyXCIsIFwibHRyXCIpXG4pO1xuY29uc3QgZ2V0RWxlbWVudEF0dHJpYnV0ZSA9IChlbCwgYXR0cmlidXRlTmFtZSwgZmFsbGJhY2tWYWx1ZSkgPT4ge1xuICBjb25zdCBjbG9zZXN0ID0gZ2V0Q2xvc2VzdEVsZW1lbnQoZWwsIGBbJHthdHRyaWJ1dGVOYW1lfV1gKTtcbiAgcmV0dXJuIGNsb3Nlc3Q/LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSA/PyBmYWxsYmFja1ZhbHVlO1xufTtcbmNvbnN0IGZvY3VzRWxlbWVudCA9IGFzeW5jIChlbCkgPT4ge1xuICBpZiAoZWwgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaGFzU2V0Rm9jdXMoZWwpKSB7XG4gICAgYXdhaXQgZWwuc2V0Rm9jdXMoKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5mb2N1cygpO1xuICB9XG59O1xuY29uc3QgaGFzU2V0Rm9jdXMgPSAocmVmKSA9PiB0eXBlb2YgcmVmLnNldEZvY3VzID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBzZXRGb2N1c09uRWxlbWVudCA9IChyZWYsIHNlbGVjdG9yKSA9PiB7XG4gIGlmICghcmVmPy5zaGFkb3dSb290KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChyZWYuaGFzQXR0cmlidXRlKFwiaHlkcmF0ZWRcIikgfHwgcmVmLmhhc0F0dHJpYnV0ZShcImNhbGNpdGUtaHlkcmF0ZWRcIikpIHtcbiAgICBzZXRGb2N1cyhyZWYsIHNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdm9pZCBQcm9taXNlLnJlc29sdmUocmVmLmNvbXBvbmVudE9uUmVhZHk/LigpKS50aGVuKCgpID0+IHNldEZvY3VzKHJlZiwgc2VsZWN0b3IpKTtcbn07XG5jb25zdCBpc0VsZW1lbnQgPSAocmVmKSA9PiByZWYubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xuY29uc3Qgc2V0Rm9jdXMgPSAocmVmLCBzZWxlY3RvciA9IFwiXCIpID0+IHtcbiAgaWYgKCFpc0VsZW1lbnQocmVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocmVmLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgaWYgKGhhc1NldEZvY3VzKHJlZikpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdm9pZCByZWYuc2V0Rm9jdXMoKSwgMCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgcmVmLmNoaWxkcmVuKSB7XG4gICAgaWYgKHNldEZvY3VzKGNoaWxkLCBzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBjb25zdCBzaGFkb3dSb290ID0gcmVmLnNoYWRvd1Jvb3Q7XG4gIGlmIChzaGFkb3dSb290KSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBzaGFkb3dSb290LmNoaWxkcmVuKSB7XG4gICAgICBpZiAoc2V0Rm9jdXMoY2hpbGQsIHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCB7XG4gIGNsYXNzZXMsXG4gIGZvY3VzRWxlbWVudCxcbiAgZ2V0Q2xvc2VzdEVsZW1lbnQsXG4gIGdldEVsZW1lbnRBdHRyaWJ1dGUsXG4gIGdldFNsb3RBc3NpZ25lZEVsZW1lbnRzLFxuICBvYnNlcnZlQW5jZXN0b3JzTXV0YXRpb24sXG4gIHNldEZvY3VzT25FbGVtZW50LFxuICBzbG90Q2hhbmdlR2V0QXNzaWduZWRFbGVtZW50cyxcbiAgc2xvdENoYW5nZUdldEFzc2lnbmVkTm9kZXMsXG4gIHNsb3RDaGFuZ2VHZXRUZXh0Q29udGVudCxcbiAgc2xvdENoYW5nZUhhc0Fzc2lnbmVkRWxlbWVudCxcbiAgc2xvdENoYW5nZUhhc0Fzc2lnbmVkTm9kZSxcbiAgc2xvdENoYW5nZUhhc0NvbnRlbnQsXG4gIHNsb3RDaGFuZ2VIYXNUZXh0Q29udGVudCxcbiAgdW5zYWZlR2V0Q2FsY2l0ZU1vZGVOYW1lLFxuICB1bnNhZmVHZXRFbGVtZW50RGlyZWN0aW9uXG59O1xuIiwiaW1wb3J0IHsgZ2V0RWxlbWVudEF0dHJpYnV0ZSwgb2JzZXJ2ZUFuY2VzdG9yc011dGF0aW9uIH0gZnJvbSBcIi4uL2RvbS9pbmRleC5qc1wiO1xuY29uc3Qgc3VwcG9ydGVkTG9jYWxlc0FycmF5ID0gXCJhcixiZyxicyxjYSxjcyxkYSxkZSxlbCxlbixlcyxldCxmaSxmcixoZSxocixodSxpZCxpdCxqYSxrbyxsdCxsdixubCxuYixubyxwbCxwdC1CUixwdC1QVCxybyxydSxzayxzbCxzcixzdix0aCx0cix1ayx2aSx6aC1DTix6aC1ISyx6aC1UV1wiLnNwbGl0KFxuICBcIixcIlxuKTtcbmNvbnN0IHN1cHBvcnRlZExvY2FsZXMgPSAoXG4gIC8vI2VuZHJlZ2lvbiBzdXBwb3J0ZWRMb2NhbGVzXG4gIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KHN1cHBvcnRlZExvY2FsZXNBcnJheSlcbik7XG5jb25zdCBkZWZhdWx0TG9jYWxlID0gXCJlblwiO1xuY29uc3QgbG9jYWxlRXF1aXZhbGVuY2llcyA9IHtcbiAgLy8jcmVnaW9uIGxvY2FsZUVxdWl2YWxlbmNpZXNcbiAgLy8gV2UgdXNlIGBwdC1QVGAgYXMgaXQgd2lsbCBoYXZlIHRoZSBzYW1lIHRyYW5zbGF0aW9ucyBhcyBgcHRgLCB3aGljaCBoYXMgbm8gY29ycmVzcG9uZGluZyBidW5kbGVcbiAgcHQ6IFwicHQtUFRcIixcbiAgLy8gV2Ugc3VwcG9ydCBib3RoICduYicgYW5kICdubycgKEJDUCA0NykgZm9yIE5vcndlZ2lhbiBidXQgb25seSBgbm9gIGhhcyBjb3JyZXNwb25kaW5nIGJ1bmRsZVxuICBuYjogXCJub1wiLFxuICAvLyBXZSBzdXBwb3J0IGJvdGggJ25uJyBhbmQgJ25vJyAoQkNQIDQ3KSBmb3IgTm9yd2VnaWFuIGJ1dCBvbmx5IGBub2AgaGFzIGNvcnJlc3BvbmRpbmcgYnVuZGxlXG4gIC8vIFNlZSBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtd2ViLWNvbXBvbmVudHMvaXNzdWVzLzQ2NjdcbiAgbm46IFwibm9cIixcbiAgLy8gV2UgdXNlIGB6aC1DTmAgYXMgYmFzZSB0cmFuc2xhdGlvbiBmb3IgY2hpbmVzZSBsb2NhbGVzIHdoaWNoIGhhcyBubyBjb3JyZXNwb25kaW5nIGJ1bmRsZS5cbiAgemg6IFwiemgtQ05cIlxuICAvLyNlbmRyZWdpb24gbG9jYWxlRXF1aXZhbGVuY2llc1xufTtcbmNvbnN0IGZldGNoVDluU3RyaW5nc0J1bmRsZSA9IGFzeW5jIChsb2NhbGUsIGFzc2V0c1BhdGgsIHByZWZpeCA9IFwiXCIpID0+IHtcbiAgY29uc3QgcGF0aCA9IGAke2Fzc2V0c1BhdGh9LyR7cHJlZml4fWA7XG4gIGNvbnN0IGZpbGVQYXRoID0gYCR7cGF0aH0ke2xvY2FsZX0uanNvbmA7XG4gIHQ5blN0cmluZ3NDYWNoZVtmaWxlUGF0aF0gPz8gKHQ5blN0cmluZ3NDYWNoZVtmaWxlUGF0aF0gPSBmZXRjaEJ1bmRsZShsb2NhbGUsIHBhdGgpKTtcbiAgcmV0dXJuIGF3YWl0IHQ5blN0cmluZ3NDYWNoZVtmaWxlUGF0aF07XG59O1xuY29uc3QgdDluU3RyaW5nc0NhY2hlID0ge307XG5jb25zdCBmZXRjaEJ1bmRsZSA9IGFzeW5jIChsb2NhbGUsIHBhdGgpID0+IHtcbiAgY29uc3QgZmlsZVBhdGggPSBgJHtwYXRofSR7bG9jYWxlfS5qc29uYDtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZpbGVQYXRoKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGlzNDA0Vml0ZUZhbGxiYWNrID0gU3RyaW5nKGVycm9yKS5pbmNsdWRlcyhgVW5leHBlY3RlZCB0b2tlbiAnPCcsIFwiPCFkb2N0eXBlIFwiLi4uIGlzIG5vdCB2YWxpZCBKU09OYCk7XG4gICAgICBpZiAoaXM0MDRWaXRlRmFsbGJhY2spIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgWzQwNF0gTG9jYWxpemF0aW9uIHN0cmluZ3Mgbm90IGZvdW5kIGF0ICR7ZmlsZVBhdGh9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBsb2NhbGl6YXRpb24gc3RyaW5ncyBhdCAke2ZpbGVQYXRofWAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAobG9jYWxlID09PSBkZWZhdWx0TG9jYWxlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBhd2FpdCBmZXRjaEJ1bmRsZShkZWZhdWx0TG9jYWxlLCBwYXRoKTtcbn07XG5jb25zdCBnZXRFbGVtZW50TG9jYWxlID0gKGVsZW1lbnQpID0+IHtcbiAgY29uc3QgbGFuZyA9IGdldEVsZW1lbnRBdHRyaWJ1dGUoZWxlbWVudCwgXCJsYW5nXCIsIGdsb2JhbFRoaXMubmF2aWdhdG9yPy5sYW5ndWFnZSB8fCBkZWZhdWx0TG9jYWxlKTtcbiAgcmV0dXJuIHsgbGFuZywgdDluTG9jYWxlOiBub3JtYWxpemVMb2NhbGUobGFuZykgfTtcbn07XG5jb25zdCBub3JtYWxpemVMb2NhbGUgPSAobGFuZykgPT4ge1xuICBjb25zdCBbcmF3TGFuZ3VhZ2VDb2RlLCByZWdpb25Db2RlXSA9IGxhbmcuc3BsaXQoXCItXCIpO1xuICBjb25zdCBsYW5ndWFnZUNvZGUgPSByYXdMYW5ndWFnZUNvZGUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IG5vcm1hbGl6ZWRMb2NhbGUgPSBsYW5ndWFnZUNvZGU7XG4gIGlmIChyZWdpb25Db2RlKSB7XG4gICAgbm9ybWFsaXplZExvY2FsZSA9IGAke2xhbmd1YWdlQ29kZX0tJHtyZWdpb25Db2RlLnRvVXBwZXJDYXNlKCl9YDtcbiAgfVxuICBub3JtYWxpemVkTG9jYWxlID0gbG9jYWxlRXF1aXZhbGVuY2llc1tub3JtYWxpemVkTG9jYWxlXSA/PyBub3JtYWxpemVkTG9jYWxlO1xuICBpZiAoc3VwcG9ydGVkTG9jYWxlcy5oYXMobm9ybWFsaXplZExvY2FsZSkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplZExvY2FsZTtcbiAgfVxuICBpZiAocmVnaW9uQ29kZSkge1xuICAgIHJldHVybiBub3JtYWxpemVMb2NhbGUobGFuZ3VhZ2VDb2RlKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdExvY2FsZTtcbn07XG5jb25zdCBzdGFydExvY2FsZU9ic2VydmVyID0gKGVsZW1lbnQsIGdldEFzc2V0c1BhdGgsIG9uVXBkYXRlZCwgYXNzZXROYW1lKSA9PiB7XG4gIGxldCByZXN1bHQgPSB2b2lkIDA7XG4gIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4gdXBkYXRlQ29tcG9uZW50TG9jYWxlU3RhdGUoZWxlbWVudCwgZ2V0QXNzZXRzUGF0aCgpLCBhc3NldE5hbWUpLnRoZW4oKG5ld1Jlc3VsdCkgPT4ge1xuICAgIGlmIChyZXN1bHQ/LmxhbmcgIT09IG5ld1Jlc3VsdC5sYW5nIHx8IHJlc3VsdC50OW5Mb2NhbGUgIT09IG5ld1Jlc3VsdC50OW5Mb2NhbGUgfHwgcmVzdWx0LnQ5blN0cmluZ3MgIT09IG5ld1Jlc3VsdC50OW5TdHJpbmdzKSB7XG4gICAgICBvblVwZGF0ZWQobmV3UmVzdWx0KTtcbiAgICB9XG4gICAgcmVzdWx0ID0gbmV3UmVzdWx0O1xuICB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgcXVldWVNaWNyb3Rhc2soY2FsbGJhY2spO1xuICByZXR1cm4gb2JzZXJ2ZUFuY2VzdG9yc011dGF0aW9uKGVsZW1lbnQsIFtcImxhbmdcIl0sIGNhbGxiYWNrKTtcbn07XG5jb25zdCB1cGRhdGVDb21wb25lbnRMb2NhbGVTdGF0ZSA9IGFzeW5jIChlbGVtZW50LCBhc3NldHNQYXRoLCBhc3NldE5hbWUgPSBlbGVtZW50LmxvY2FsTmFtZS5zcGxpdChcIi1cIikuc2xpY2UoMSkuam9pbihcIi1cIikpID0+IHtcbiAgY29uc3QgeyBsYW5nLCB0OW5Mb2NhbGUgfSA9IGdldEVsZW1lbnRMb2NhbGUoZWxlbWVudCk7XG4gIGNvbnN0IHQ5bkFzc2V0c1BhdGggPSBgJHthc3NldHNQYXRofS8ke2Fzc2V0TmFtZX0vdDluYDtcbiAgY29uc3QgcHJlZml4ID0gYG1lc3NhZ2VzLmA7XG4gIGNvbnN0IHQ5blN0cmluZ3MgPSAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtYXNzZXJ0aW9uc1xuICAgIGFzc2V0TmFtZSA9PT0gbnVsbCA/IHt9IDogYXdhaXQgZmV0Y2hUOW5TdHJpbmdzQnVuZGxlKHQ5bkxvY2FsZSwgdDluQXNzZXRzUGF0aCwgcHJlZml4KVxuICApO1xuICByZXR1cm4geyBsYW5nLCB0OW5Mb2NhbGUsIHQ5blN0cmluZ3MgfTtcbn07XG5leHBvcnQge1xuICBkZWZhdWx0TG9jYWxlLFxuICBmZXRjaFQ5blN0cmluZ3NCdW5kbGUsXG4gIGdldEVsZW1lbnRMb2NhbGUsXG4gIG5vcm1hbGl6ZUxvY2FsZSxcbiAgc3RhcnRMb2NhbGVPYnNlcnZlcixcbiAgc3VwcG9ydGVkTG9jYWxlc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==