export const __webpack_id__ = "vendors-node_modules_arcgis_core_views_2d_engine_webgl_WGLContainer_js";
export const __webpack_ids__ = ["vendors-node_modules_arcgis_core_views_2d_engine_webgl_WGLContainer_js"];
export const __webpack_modules__ = {

/***/ "./node_modules/@arcgis/core/views/2d/engine/brushes.js":
/*!**************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/brushes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   brushes: () => (/* binding */ m)
/* harmony export */ });
/* harmony import */ var _webgl_brushes_BrushClip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl/brushes/BrushClip.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/BrushClip.js");
/* harmony import */ var _webgl_brushes_WGLBrushStencil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl/brushes/WGLBrushStencil.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushStencil.js");
/* harmony import */ var _webgl_brushes_WGLBrushTileDebugInfo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl/brushes/WGLBrushTileDebugInfo.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushTileDebugInfo.js");
/* harmony import */ var _webgl_brushes_WGLBrushVTLBackground_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webgl/brushes/WGLBrushVTLBackground.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLBackground.js");
/* harmony import */ var _webgl_brushes_WGLBrushVTLCircle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./webgl/brushes/WGLBrushVTLCircle.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLCircle.js");
/* harmony import */ var _webgl_brushes_WGLBrushVTLFill_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./webgl/brushes/WGLBrushVTLFill.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLFill.js");
/* harmony import */ var _webgl_brushes_WGLBrushVTLLine_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./webgl/brushes/WGLBrushVTLLine.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLLine.js");
/* harmony import */ var _webgl_brushes_WGLBrushVTLSymbol_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./webgl/brushes/WGLBrushVTLSymbol.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLSymbol.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const m={clip:_webgl_brushes_BrushClip_js__WEBPACK_IMPORTED_MODULE_0__["default"],stencil:_webgl_brushes_WGLBrushStencil_js__WEBPACK_IMPORTED_MODULE_1__["default"],tileDebugInfo:_webgl_brushes_WGLBrushTileDebugInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"],vtlBackground:_webgl_brushes_WGLBrushVTLBackground_js__WEBPACK_IMPORTED_MODULE_3__.WGLBrushVTLBackground,vtlFill:_webgl_brushes_WGLBrushVTLFill_js__WEBPACK_IMPORTED_MODULE_5__.WGLBrushVTLFill,vtlLine:_webgl_brushes_WGLBrushVTLLine_js__WEBPACK_IMPORTED_MODULE_6__.WGLBrushVTLLine,vtlCircle:_webgl_brushes_WGLBrushVTLCircle_js__WEBPACK_IMPORTED_MODULE_4__.WGLBrushVTLCircle,vtlSymbol:_webgl_brushes_WGLBrushVTLSymbol_js__WEBPACK_IMPORTED_MODULE_7__.WGLBrushVTLSymbol};


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/AFeatureTile.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/AFeatureTile.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AFeatureTile: () => (/* binding */ g)
/* harmony export */ });
/* harmony import */ var _core_libs_gl_matrix_2_math_mat2d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../core/libs/gl-matrix-2/math/mat2d.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/math/mat2d.js");
/* harmony import */ var _core_libs_gl_matrix_2_factories_mat2df32_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../core/libs/gl-matrix-2/factories/mat2df32.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/mat2df32.js");
/* harmony import */ var _core_libs_gl_matrix_2_math_mat3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../core/libs/gl-matrix-2/math/mat3.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/math/mat3.js");
/* harmony import */ var _core_libs_gl_matrix_2_factories_mat3f32_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../core/libs/gl-matrix-2/factories/mat3f32.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/mat3f32.js");
/* harmony import */ var _chunks_vec32_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../chunks/vec32.js */ "./node_modules/@arcgis/core/chunks/vec32.js");
/* harmony import */ var _core_libs_gl_matrix_2_factories_vec3f32_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../core/libs/gl-matrix-2/factories/vec3f32.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/vec3f32.js");
/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./definitions.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/definitions.js");
/* harmony import */ var _TiledDisplayObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TiledDisplayObject.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/TiledDisplayObject.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const x=(0,_core_libs_gl_matrix_2_factories_mat3f32_js__WEBPACK_IMPORTED_MODULE_3__.create)(),M=(0,_core_libs_gl_matrix_2_factories_vec3f32_js__WEBPACK_IMPORTED_MODULE_5__.create)();class g extends _TiledDisplayObject_js__WEBPACK_IMPORTED_MODULE_7__.TiledDisplayObject{constructor(t,s,i,r){super(t,s,i,r,_definitions_js__WEBPACK_IMPORTED_MODULE_6__.tileSize,_definitions_js__WEBPACK_IMPORTED_MODULE_6__.tileSize)}destroy(){super.destroy()}setTransform(m){const c=this.resolution/m.resolution,h=this.transforms.tileMat3,[f,p]=m.toScreenNoRotation([0,0],[this.x,this.y]),d=this.width/this.rangeX*c,u=this.height/this.rangeY*c;(0,_core_libs_gl_matrix_2_math_mat3_js__WEBPACK_IMPORTED_MODULE_2__.set)(h,d,0,0,0,u,0,f,p,1),(0,_core_libs_gl_matrix_2_math_mat3_js__WEBPACK_IMPORTED_MODULE_2__.multiply)(this.transforms.displayViewScreenMat3,m.displayViewMat3,h);const x=(0,_core_libs_gl_matrix_2_math_mat2d_js__WEBPACK_IMPORTED_MODULE_0__.set)((0,_core_libs_gl_matrix_2_factories_mat2df32_js__WEBPACK_IMPORTED_MODULE_1__.create)(),d,0,0,u,f,p);(0,_core_libs_gl_matrix_2_math_mat2d_js__WEBPACK_IMPORTED_MODULE_0__.multiply)(this.transforms.labelMat2d,m.viewMat2d,x);const M=[0,0];m.toScreen(M,[this.x,this.y]);const g=this.transforms.tileUnitsToPixels;(0,_core_libs_gl_matrix_2_math_mat3_js__WEBPACK_IMPORTED_MODULE_2__.identity)(g),(0,_core_libs_gl_matrix_2_math_mat3_js__WEBPACK_IMPORTED_MODULE_2__.translate)(g,g,M),(0,_core_libs_gl_matrix_2_math_mat3_js__WEBPACK_IMPORTED_MODULE_2__.rotate)(g,g,Math.PI*m.rotation/180),(0,_core_libs_gl_matrix_2_math_mat3_js__WEBPACK_IMPORTED_MODULE_2__.scale)(g,g,[d,u,1])}_createTransforms(){return{labelMat2d:(0,_core_libs_gl_matrix_2_factories_mat2df32_js__WEBPACK_IMPORTED_MODULE_1__.create)(),tileMat3:(0,_core_libs_gl_matrix_2_factories_mat3f32_js__WEBPACK_IMPORTED_MODULE_3__.create)(),displayViewScreenMat3:(0,_core_libs_gl_matrix_2_factories_mat3f32_js__WEBPACK_IMPORTED_MODULE_3__.create)(),tileUnitsToPixels:(0,_core_libs_gl_matrix_2_factories_mat3f32_js__WEBPACK_IMPORTED_MODULE_3__.create)()}}containsScreenPoint(t,s,i){const r=(0,_core_libs_gl_matrix_2_math_mat3_js__WEBPACK_IMPORTED_MODULE_2__.multiply)(x,t.viewMat3,this.transforms.tileMat3),e=(0,_core_libs_gl_matrix_2_math_mat3_js__WEBPACK_IMPORTED_MODULE_2__.invert)(x,r);if(null==e)return!0;(0,_chunks_vec32_js__WEBPACK_IMPORTED_MODULE_4__.i)(M,...s,1);const a=(0,_chunks_vec32_js__WEBPACK_IMPORTED_MODULE_4__.o)(M,M,e),n=i*(this.resolution/t.resolution);return a[0]>=-n&&a[0]<this.width+n&&a[1]>=-n&&a[1]<this.height+n}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/ClippingInfo.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/ClippingInfo.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ c)
/* harmony export */ });
/* harmony import */ var _core_Error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../core/Error.js */ "./node_modules/@arcgis/core/core/Error.js");
/* harmony import */ var _core_Logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../core/Logger.js */ "./node_modules/@arcgis/core/core/Logger.js");
/* harmony import */ var _core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../core/reactiveUtils.js */ "./node_modules/@arcgis/core/core/reactiveUtils.js");
/* harmony import */ var _core_libs_gl_matrix_2_factories_mat3f32_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../core/libs/gl-matrix-2/factories/mat3f32.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/mat3f32.js");
/* harmony import */ var _DisplayObject_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DisplayObject.js */ "./node_modules/@arcgis/core/views/2d/engine/DisplayObject.js");
/* harmony import */ var _Mesh2D_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Mesh2D.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/Mesh2D.js");
/* harmony import */ var _support_clippingUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../support/clippingUtils.js */ "./node_modules/@arcgis/core/views/2d/support/clippingUtils.js");
/* harmony import */ var _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../webgl/VertexArrayObject.js */ "./node_modules/@arcgis/core/views/webgl/VertexArrayObject.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
class c extends _DisplayObject_js__WEBPACK_IMPORTED_MODULE_4__.DisplayObject{constructor(e,t){super(),this._clip=t,this._cache={},this.stage=e,this._handle=(0,_core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_2__.watch)((()=>t.version),(()=>this._invalidate())),this.ready()}static fromClipArea(e,t){return new c(e,t)}_destroyGL(){null!=this._cache.mesh&&(this._cache.mesh.destroy(),this._cache.mesh=null),null!=this._cache.vao&&(this._cache.vao.dispose(),this._cache.vao=null)}destroy(){this._destroyGL(),this._handle.remove()}getVAO(e,t,r,s){const[i,a]=t.size;if("geometry"!==this._clip.type&&this._lastWidth===i&&this._lastHeight===a||(this._lastWidth=i,this._lastHeight=a,this._destroyGL()),null==this._cache.vao){const i=this._createMesh(t,this._clip),a=i.getIndexBuffer(e),o=i.getVertexBuffers(e);this._cache.mesh=i,this._cache.vao=new _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_7__.VertexArrayObject(e,r,s,o,a)}return this._cache.vao}_createTransforms(){return{displayViewScreenMat3:(0,_core_libs_gl_matrix_2_factories_mat3f32_js__WEBPACK_IMPORTED_MODULE_3__.create)()}}_invalidate(){this._destroyGL(),this.requestRender()}_createMesh(r,s){switch(s.type){case"rect":return _Mesh2D_js__WEBPACK_IMPORTED_MODULE_5__["default"].fromScreenExtent((0,_support_clippingUtils_js__WEBPACK_IMPORTED_MODULE_6__.createScreenExtent)(s,r.size[0],r.size[1]));case"path":return _Mesh2D_js__WEBPACK_IMPORTED_MODULE_5__["default"].fromPath(s);case"geometry":return _Mesh2D_js__WEBPACK_IMPORTED_MODULE_5__["default"].fromGeometry(r,s);default:return _core_Logger_js__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("esri.views.2d.engine.webgl.ClippingInfo").error(new _core_Error_js__WEBPACK_IMPORTED_MODULE_0__["default"]("mapview-bad-type","Unable to create ClippingInfo mesh from clip of type: ${clip.type}")),_Mesh2D_js__WEBPACK_IMPORTED_MODULE_5__["default"].fromScreenExtent({xmin:0,ymin:0,xmax:1,ymax:1})}}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/FeatureDisplayList.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/FeatureDisplayList.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DisplayList: () => (/* binding */ l),
/* harmony export */   DisplayListInfo: () => (/* binding */ h)
/* harmony export */ });
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/enums.js");
/* harmony import */ var _cpuMapped_FreeList_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cpuMapped/FreeList.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/FreeList.js");
/* harmony import */ var _shaderGraph_techniques_featureTechniqueUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shaderGraph/techniques/featureTechniqueUtils.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/featureTechniqueUtils.js");
/* harmony import */ var _webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../webgl/enums.js */ "./node_modules/@arcgis/core/views/webgl/enums.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
function r(t,e){return t<<16|255&e}function d(t){return 255&t}class h{constructor(t,e,n,i,a){this.instance=t,this.materialKey=e,this.target=n,this.start=i,this.count=a}get textureKey(){return d(this.materialKey)}get indexEnd(){return this.start+this.count}extend(t){this.count+=t}render(t){this.instance.techniqueRef.render(t,this)}get key(){return this.target.key}getStencilReference(){return this.target.stencilRef}getAttributePrecisionPackFactors(){const t=this.instance.instanceId;return this.target.getMesh(t).getAttributePrecisionPackFactors()}draw(t,e){(0,_shaderGraph_techniques_featureTechniqueUtils_js__WEBPACK_IMPORTED_MODULE_3__.isHittest)(t)?this.drawCompute(t.context,e):this.drawGeometry(t.context,e)}drawCompute(t,e){const n=this.instance.instanceId,i=this.target.getMesh(n).getComputeVAO(t,e),r=this.start*Uint32Array.BYTES_PER_ELEMENT/3;t.bindVAO(i),t.drawElements(_webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__.PrimitiveType.POINTS,this.count/3,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__.DataType.UNSIGNED_INT,r),t.bindVAO(null)}drawGeometry(t,e){const n=this.instance.instanceId,i=this.target.getMesh(n).getGeometryVAO(t,e),r=this.start*Uint32Array.BYTES_PER_ELEMENT;t.bindVAO(i),t.drawElements(_webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__.PrimitiveType.TRIANGLES,this.count,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__.DataType.UNSIGNED_INT,r),t.bindVAO(null)}}class l{constructor(){this._length=0,this._minOrderedLength=0,this._materialKeys=new Set}static fromDisplayEntities(t,e,n,i){const a=new l;for(const s of t.values())for(const t of s.records){const s=n.getInstance(t.instanceId),d=r(s.instanceId,t.textureKey);a.addRecord(s,d,t.indexStart,t.indexCount,t.vertexStart,t.vertexCount,e,i)}return a}get length(){return this._length}get minOrderedLength(){return this._minOrderedLength}get minUnorderedLength(){return this._materialKeys.size}render(t,e){const{drawPhase:n}=t;for(const i of this.infos()){const a=i.instance.techniqueRef;a.drawPhase&n&&(null==e||a.type===e)&&i.render(t)}}addRecord(i,a,s,r,d,l,o,c){let u=s,_=r;if(_||(u=d,_=l),!_)return;if(null==this._head){const t=new h(i,a,o,u,_);return this._head=new _cpuMapped_FreeList_js__WEBPACK_IMPORTED_MODULE_2__.List(t),this._tail=this._head,this._length++,void this._minOrderedLength++}if(c===_enums_js__WEBPACK_IMPORTED_MODULE_1__.FeatureBatchingStrategy.STRICT_ORDER)return this._insert(i,a,o,u,_,this._tail,null);let g=null,m=this._head;const f=i.instanceId,y=i.techniqueRef.symbologyPlane;if(c===_enums_js__WEBPACK_IMPORTED_MODULE_1__.FeatureBatchingStrategy.STRICT_MARKERS_AND_TEXT&&(y===_enums_js__WEBPACK_IMPORTED_MODULE_1__.FeatureSymbologyDrawOrder.MARKER||y===_enums_js__WEBPACK_IMPORTED_MODULE_1__.FeatureSymbologyDrawOrder.TEXT))return this._insert(i,a,o,u,_,this._tail,null);for(;m;){const t=m.data.instance,e=t.instanceId,n=t.techniqueRef.symbologyPlane,s=g?.data.instance.instanceId;if(y<n||f===s&&f!==e)return this._insert(i,a,o,u,_,g,m);g=m,m=m.next}this._insert(i,a,o,u,_,g,null)}*infos(){if(null!=this._head)for(const t of this._head.values())yield t}_insert(t,e,i,a,s,r,d){if(null==r&&null==d){const r=new h(t,e,i,a,s);return this._head=new _cpuMapped_FreeList_js__WEBPACK_IMPORTED_MODULE_2__.List(r),this._tail=this._head,this._length++,void this._minOrderedLength++}return e!==this._tail.data.materialKey&&this._minOrderedLength++,this._materialKeys.add(e),null==r&&null!=d?this._insertAtHead(t,e,i,a,s,d):null!=r&&null==d?this._insertAtEnd(t,e,i,a,s,r):null!=r&&null!=d?this._insertAtMiddle(t,e,i,a,s,r,d):void 0}_insertAtHead(t,e,i,a,s,r){const d=a+s;if(e===r.data.materialKey&&i===r.data.target&&d===r.data.start)r.data.start=a,r.data.count+=s;else{const d=new h(t,e,i,a,s);this._head=new _cpuMapped_FreeList_js__WEBPACK_IMPORTED_MODULE_2__.List(d),this._head.next=r,this._length++}}_insertAtEnd(t,e,i,a,s,r){if(r.data.materialKey===e&&r.data.indexEnd===a)r.data.count+=s;else{const d=new h(t,e,i,a,s);this._tail=new _cpuMapped_FreeList_js__WEBPACK_IMPORTED_MODULE_2__.List(d),r.next=this._tail,this._length++}}_insertAtMiddle(t,e,i,a,s,r,d){const l=a+s;if(r.data.materialKey===e&&r.data.target===i&&r.data.indexEnd===a)r.data.count+=s,r.data.materialKey===d.data.materialKey&&r.data.target===d.data.target&&r.data.indexEnd===d.data.start&&(r.data.count+=d.data.count,r.next=d.next,this._length--);else if(e===d.data.materialKey&&i===d.data.target&&l===d.data.start)d.data.start=a,d.data.count+=s;else{const l=new h(t,e,i,a,s),o=new _cpuMapped_FreeList_js__WEBPACK_IMPORTED_MODULE_2__.List(l);r.next=o,o.next=d,this._length++}}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/FeatureTile.js":
/*!************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/FeatureTile.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FeatureTile: () => (/* binding */ I)
/* harmony export */ });
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _core_Logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../core/Logger.js */ "./node_modules/@arcgis/core/core/Logger.js");
/* harmony import */ var _core_libs_gl_matrix_2_factories_mat2df32_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../core/libs/gl-matrix-2/factories/mat2df32.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/mat2df32.js");
/* harmony import */ var _core_libs_gl_matrix_2_factories_mat3f32_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../core/libs/gl-matrix-2/factories/mat3f32.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/mat3f32.js");
/* harmony import */ var _AFeatureTile_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AFeatureTile.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/AFeatureTile.js");
/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./definitions.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/definitions.js");
/* harmony import */ var _DisplayEntity_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DisplayEntity.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/DisplayEntity.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/enums.js");
/* harmony import */ var _FeatureDisplayList_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./FeatureDisplayList.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/FeatureDisplayList.js");
/* harmony import */ var _ReshufflePlan_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ReshufflePlan.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/ReshufflePlan.js");
/* harmony import */ var _collisions_LabelMetric_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./collisions/LabelMetric.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/collisions/LabelMetric.js");
/* harmony import */ var _cpuMapped_MappedMesh_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./cpuMapped/MappedMesh.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/MappedMesh.js");
/* harmony import */ var _mesh_meshDebugUtils_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mesh/meshDebugUtils.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/mesh/meshDebugUtils.js");
/* harmony import */ var _util_Reader_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./util/Reader.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/util/Reader.js");
/* harmony import */ var _util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./util/serializationUtils.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/util/serializationUtils.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const b=()=>_core_Logger_js__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("esri.views.2d.engine.webgl.FeatureTile");let g=0;class I extends _AFeatureTile_js__WEBPACK_IMPORTED_MODULE_4__.AFeatureTile{constructor(e,i,r,o,d,n,h=!1){super(e,i,r,o),this._fader=d,this._labelInstanceId=n,this._meshes=new Map,this._entities=[],this._entityIndex=new Map,this._invalidated=!1,this._nextUploadAllowed=!1,this.tileAge=g++,this._metrics=[],this._metricsVisibility=new Set,this._entityIds=new Set,this._entityIdsFromBuffer=new Set,this._attributeEpoch=0,this._encounteredEnd=!1,this.neededForCoverage=!1,this.isCoverage=!1,this.rendering=!1,this._decluttered=!1,this._objectIdMap=null,this.visible=!0,this.transforms.labelMat2d=(0,_core_libs_gl_matrix_2_factories_mat2df32_js__WEBPACK_IMPORTED_MODULE_2__.create)(),this.transforms.tileUnitsToPixels=(0,_core_libs_gl_matrix_2_factories_mat3f32_js__WEBPACK_IMPORTED_MODULE_3__.create)(),this.enableDeferredUploads=h}destroy(){super.destroy(),this.clear()}clear(){for(const e of this._meshes.values())e.destroy();this._meshes.clear(),this._entities=[],this._fader?.removeFeatureTileMetrics(this,this._metrics),this._metrics=[],this._displayList=null,this._invalidated=!0,this._entityIds.clear(),this._nextUploadAllowed=!0}beforeRender(e){super.beforeRender(e),this._needsReshuffle&&e.reshuffleManager.schedule(this)}tryReady(e){const t=this._invalidated&&!this._uploadAllowed;return!(this.isReady||t||!this._encounteredEnd||!(e>=this._attributeEpoch))&&((0,_core_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.ready [epoch=${e}]`),this.ready(),this.requestRender(),this.decluttered=!1,!0)}get symbols(){const e=new Map;for(const t of this._metrics)e.get(t.labelClassId)||e.set(t.labelClassId,[]),e.get(t.labelClassId).push(t);return e}get decluttered(){return this._decluttered}set decluttered(e){this._decluttered=e,this.requestRender()}get id(){return this.key.id}get hasData(){return!!this._meshes.size}get hasAnimations(){return!!this._objectIdMap}get needsUpload(){return this._invalidated}get _uploadAllowed(){return!this.enableDeferredUploads||this._nextUploadAllowed}get _hasMetrics(){return this._metrics.length>0}upload(){this._nextUploadAllowed=!0}getDisplayList(e,t){if(this._uploadAllowed&&this._invalidated){this._entities.sort(((e,t)=>{const s=t.sortKey,i=e.sortKey;return i===s?e.id-t.id:i-s})),t===_enums_js__WEBPACK_IMPORTED_MODULE_7__.FeatureBatchingStrategy.BATCHING&&this.reshuffle(!0),this._displayList=_FeatureDisplayList_js__WEBPACK_IMPORTED_MODULE_8__.DisplayList.fromDisplayEntities(this._entities,this,e,t);for(const e of this._meshes.values())e.upload();this.debugInfo.display.length=this._displayList.length,this.debugInfo.display.minOrderedLength=this._displayList.minOrderedLength,this.debugInfo.display.minUnorderedLength=this._displayList.minUnorderedLength,this.requestRender(),this._invalidated=!1,this._nextUploadAllowed=!1}return this._displayList}getMesh(e){if(!this._meshes.has(e))throw new Error(`InternalError: Unable to find VAO for instance: ${e}`);return this._meshes.get(e)}getSortKeys(e){const t=new Map;for(const{id:s,sortKey:i}of this._entities)if(e.has(s)&&t.set(s,i),t.size===e.size)break;return t}onMessage(e){if(e.objectIdMap)for(const t in e.objectIdMap)this._objectIdMap||(this._objectIdMap={}),this._objectIdMap[t]=e.objectIdMap[t];switch(e.type){case"append":this._onAppendMessage(e);break;case"update":this._onUpdateMessage(e)}if(this._aggregateMemoryStats(),this.requestRender(),e.end){if((0,_core_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.end [epoch=${e.attributeEpoch}]`),!e.attributeEpoch)throw new Error("InternalError: Attribute epoch not defined.");this._attributeEpoch=e.attributeEpoch,this._encounteredEnd=!0}this._writeLabelVisibilityToMesh()}_onAppendMessage(e){if((0,_core_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.append`,{append:(0,_mesh_meshDebugUtils_js__WEBPACK_IMPORTED_MODULE_12__.debugMeshDataInfo)(e?.append)}),e.clear&&this.clear(),!e.append)return;const t=(0,_util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_14__.deserializeList)(new _util_Reader_js__WEBPACK_IMPORTED_MODULE_13__["default"](e.append.entities),_DisplayEntity_js__WEBPACK_IMPORTED_MODULE_6__["default"]);this._insert(t,e.append.data,!1)}_onUpdateMessage(e){(0,_core_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.update`,{isPixelBuffer:e.isPixelBuffer,modify:(0,_mesh_meshDebugUtils_js__WEBPACK_IMPORTED_MODULE_12__.debugMeshDataInfo)(e.modify),remove:e.remove});const t=(0,_util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_14__.deserializeList)(new _util_Reader_js__WEBPACK_IMPORTED_MODULE_13__["default"](e.modify.entities),_DisplayEntity_js__WEBPACK_IMPORTED_MODULE_6__["default"]),s=t.map((e=>e.id)),i=e.isPixelBuffer??!1,r=[...e.remove,...s];i?this._removeByIdsFromBuffer(r):this._removeByIds(r),this._insert(t,e.modify.data,i)}reshuffle(e=!1){if(this.destroyed)return;const t=new Map;for(const s of this._entities)for(const i of s.records){const s=this._meshes.get(i.instanceId);let r=t.get(s);r||(r=new _ReshufflePlan_js__WEBPACK_IMPORTED_MODULE_9__.ReshufflePlan(e),t.set(s,r)),r.copyRecord(i)}for(const[s,i]of t)s.reshuffle(i);this._invalidated=!0,this._aggregateMemoryStats(),(0,_core_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("esri-2d-update-debug")&&b().info(`Tile ${this.key.id} was reshuffled.`)}copyPixelBufferedEntitesFrom(e,t,s,i){const r=s*_definitions_js__WEBPACK_IMPORTED_MODULE_5__.tileSize,o=i*_definitions_js__WEBPACK_IMPORTED_MODULE_5__.tileSize;for(const d of e._entities){let s=null;for(const i of d.records)if(i.overlaps&t){const t=e.getMesh(i.instanceId),n=this._ensureMesh(i.instanceId,t.layout,t.useVisibility).copyRecordFrom(t,i,r,o);s||(s=new _DisplayEntity_js__WEBPACK_IMPORTED_MODULE_6__["default"](d.id,d.sortKey),this._entityIdsFromBuffer.add(d.id),this._entityIndex.set(s.id,s),this._entities.push(s)),s.records.push(n)}}this._invalidated=!0}get metricsVisibility(){return this._metricsVisibility}copyMetricsVisibility(e){for(const t of e)this._metricsVisibility.add(t);this._writeLabelVisibilityToMesh()}updateLabelVisibility(){this._metricsVisibility.clear();for(const e of this._metrics){e.uniqueSymbol.show&&e.selectedForRendering&&this._metricsVisibility.add(e.hash)}this._writeLabelVisibilityToMesh()}_writeLabelVisibilityToMesh(){const e=this._meshes.get(this._labelInstanceId);if(e&&this._hasMetrics){for(const t of this._metrics){const s=this._entityIndex.get(t.id);if(!s)continue;const i=this._metricsVisibility.has(t.hash);e.setEntityRecordRangeVisibility(s.records,t.recordStart,t.recordCount,i?0:255)}this._invalidated=!0}}_ensureMesh(e,t,s){return this._meshes.has(e)||this._meshes.set(e,new _cpuMapped_MappedMesh_js__WEBPACK_IMPORTED_MODULE_11__.MappedMesh(this._stage.bufferPool,t,s)),this._meshes.get(e)}_insert(e,t,s){if(!e.length)return;this._removeDuplicatedBufferedEntites(e);const i=this._insertVertexData(t);for(const r of e){for(const e of r.records)e.updateBaseOffsets(i.get(e.instanceId));s?this._tryInsertBufferedEntity(r):this._insertEntity(r)}this._invalidated=!0}_insertMetrics(e){for(const t of e)t.tile=this;this._metrics.push(...e),this._fader?.insertFeatureTileMetrics(this,e)}_insertVertexData(e){const t=new Map;for(const s of e){const{instanceId:e,layout:i}=s,r=i.attributes.some((e=>"visibility"===e.name)),o=this._ensureMesh(e,i,r).append(s);if(s.metrics){const e=(0,_util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_14__.deserializeList)(new _util_Reader_js__WEBPACK_IMPORTED_MODULE_13__["default"](s.metrics),_collisions_LabelMetric_js__WEBPACK_IMPORTED_MODULE_10__.LabelMetric)??[];this._insertMetrics(e)}t.set(e,o)}return t}_insertEntity(e){(0,_core_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("esri-2d-update-debug")&&this._entityIds.has(e.id)&&console.error(`Tile ${this.key.id} insertEntity: Already have entityId ${e.id}`),this._entityIds.add(e.id),this._entityIndex.set(e.id,e),this._entities.push(e)}_tryInsertBufferedEntity(e){this._entityIds.has(e.id)?this._removeRecordsFromMesh(e.records):(this._entityIdsFromBuffer.add(e.id),this._entityIndex.set(e.id,e),this._entities.push(e))}_removeDuplicatedBufferedEntites(e){if(!this._entityIdsFromBuffer.size)return;const t=[];for(const s of e)this._entityIdsFromBuffer.has(s.id)&&t.push(s.id);this._removeByIds(t)}_removeByIdsFromBuffer(e){this._removeByIds(e.filter((e=>this._entityIdsFromBuffer.has(e))))}_removeByIds(e){if(0===e.length)return;const t=new Set(e),s=[];for(const r of this._entities)t.has(r.id)?(this._remove(r),this._entityIndex.delete(r.id)):s.push(r);this._entities=s;const i=this._metrics.filter((e=>t.has(e.displayId)));this._metrics=this._metrics.filter((e=>!t.has(e.displayId))),this._fader?.removeFeatureTileMetrics(this,i),this._invalidated=!0}_remove(e){this._removeRecordsFromMesh(e.records),this._entityIds.delete(e.id),this._entityIdsFromBuffer.delete(e.id)}_removeRecordsFromMesh(e){for(const t of e){const{instanceId:e,indexStart:s,indexCount:i,vertexStart:r,vertexCount:o}=t;this._meshes.get(e)?.remove(s,i,r,o)}}_aggregateMemoryStats(){this.debugInfo.memory.bytesUsed=0,this.debugInfo.memory.bytesReserved=0;for(const e of this._meshes.values())this.debugInfo.memory.bytesUsed+=e.memoryStats.bytesUsed,this.debugInfo.memory.bytesReserved+=e.memoryStats.bytesReserved}get _needsReshuffle(){if(this.destroyed)return!1;const{bytesUsed:e,bytesReserved:t}=this.debugInfo.memory,s=e/t,{minOrderedLength:i,length:h}=this.debugInfo.display;return t>_definitions_js__WEBPACK_IMPORTED_MODULE_5__.RESHUFFLING_EXEMPT_MEMORY_BYTES&&s<_definitions_js__WEBPACK_IMPORTED_MODULE_5__.RESHUFFLING_TARGET_MEMORY_EFFICIENCY||h>_definitions_js__WEBPACK_IMPORTED_MODULE_5__.RESHUFFLING_EXEMPT_DRAW_CALLS&&i/h<_definitions_js__WEBPACK_IMPORTED_MODULE_5__.RESHUFFLING_TARGET_DRAW_EFFICIENCY}get entityIds(){return this._objectIdMap?this._entities.map((({id:e})=>({objectId:this._objectIdMap[e],displayId:e}))):[]}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/Mesh2D.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/Mesh2D.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ y)
/* harmony export */ });
/* harmony import */ var _core_Error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../core/Error.js */ "./node_modules/@arcgis/core/core/Error.js");
/* harmony import */ var _core_Logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../core/Logger.js */ "./node_modules/@arcgis/core/core/Logger.js");
/* harmony import */ var _chunks_earcut_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../chunks/earcut.js */ "./node_modules/@arcgis/core/chunks/earcut.js");
/* harmony import */ var _core_libs_gl_matrix_2_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../core/libs/gl-matrix-2/math/vec2.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/math/vec2.js");
/* harmony import */ var _core_libs_gl_matrix_2_factories_vec2f64_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../core/libs/gl-matrix-2/factories/vec2f64.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/vec2f64.js");
/* harmony import */ var _layers_graphics_featureConversionUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../layers/graphics/featureConversionUtils.js */ "./node_modules/@arcgis/core/layers/graphics/featureConversionUtils.js");
/* harmony import */ var _layers_graphics_OptimizedGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../layers/graphics/OptimizedGeometry.js */ "./node_modules/@arcgis/core/layers/graphics/OptimizedGeometry.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./number.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/number.js");
/* harmony import */ var _webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../webgl/BufferObject.js */ "./node_modules/@arcgis/core/views/webgl/BufferObject.js");
/* harmony import */ var _webgl_enums_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../webgl/enums.js */ "./node_modules/@arcgis/core/views/webgl/enums.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const l=(e,r,t,o)=>{let n=0;for(let s=1;s<t;s++){const t=e[2*(r+s-1)],o=e[2*(r+s-1)+1];n+=(e[2*(r+s)]-t)*(e[2*(r+s)+1]+o)}return o?n>0:n<0},u=({coords:e,lengths:r},o)=>{const n=[];for(let s=0,i=0;s<r.length;i+=r[s],s+=1){const c=i,a=[];for(;s<r.length-1&&l(e,i+r[s],r[s+1],o);s+=1,i+=r[s])a.push(i+r[s]-c);const f=e.slice(2*c,2*(i+r[s])),m=(0,_chunks_earcut_js__WEBPACK_IMPORTED_MODULE_2__.e)(f,a,2);for(const e of m)n.push(e+c)}return n};class y{constructor(e,r,t,o=!1){this._cache={},this.vertices=e,this.indices=r,this.primitiveType=t,this.isMapSpace=o}static fromPath(e){const r=(0,_layers_graphics_featureConversionUtils_js__WEBPACK_IMPORTED_MODULE_5__.convertFromNestedArray)(new _layers_graphics_OptimizedGeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"],e.path,!1,!1),t=r.coords,o=new Uint32Array(u(r,!0)),n=new Uint32Array(t.length/2);for(let s=0;s<n.length;s++)n[s]=(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(Math.floor(t[2*s]),Math.floor(t[2*s+1]));return new y({geometry:n},o,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_9__.PrimitiveType.TRIANGLES)}static fromGeometry(t,o){const n=o.geometry?.type;switch(n){case"polygon":return y.fromPolygon(t,o.geometry);case"extent":return y.fromMapExtent(t,o.geometry);default:return _core_Logger_js__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("esri.views.2d.engine.webgl.Mesh2D").error(new _core_Error_js__WEBPACK_IMPORTED_MODULE_0__["default"]("mapview-bad-type",`Unable to create a mesh from type ${n}`,o)),y.fromScreenExtent({xmin:0,ymin:0,xmax:1,ymax:1})}}static fromPolygon(e,r){const t=(0,_layers_graphics_featureConversionUtils_js__WEBPACK_IMPORTED_MODULE_5__.convertFromPolygon)(new _layers_graphics_OptimizedGeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"],r,!1,!1),s=t.coords,f=new Uint32Array(u(t,!1)),h=new Uint32Array(s.length/2),l=(0,_core_libs_gl_matrix_2_factories_vec2f64_js__WEBPACK_IMPORTED_MODULE_4__.create)(),x=(0,_core_libs_gl_matrix_2_factories_vec2f64_js__WEBPACK_IMPORTED_MODULE_4__.create)();for(let n=0;n<h.length;n++)(0,_core_libs_gl_matrix_2_math_vec2_js__WEBPACK_IMPORTED_MODULE_3__.set)(l,s[2*n],s[2*n+1]),e.toScreen(x,l),h[n]=(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(Math.floor(x[0]),Math.floor(x[1]));return new y({geometry:h},f,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_9__.PrimitiveType.TRIANGLES,!0)}static fromScreenExtent({xmin:e,xmax:r,ymin:t,ymax:o}){const n={geometry:new Uint32Array([(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(e,t),(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(r,t),(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(e,o),(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(e,o),(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(r,t),(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(r,o)])},s=new Uint32Array([0,1,2,3,4,5]);return new y(n,s,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_9__.PrimitiveType.TRIANGLES)}static fromMapExtent(e,r){const[t,o]=e.toScreen([0,0],[r.xmin,r.ymin]),[n,s]=e.toScreen([0,0],[r.xmax,r.ymax]),i={geometry:new Uint32Array([(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(t,o),(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(n,o),(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(t,s),(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(t,s),(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(n,o),(0,_number_js__WEBPACK_IMPORTED_MODULE_7__.i1616to32)(n,s)])},c=new Uint32Array([0,1,2,3,4,5]);return new y(i,c,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_9__.PrimitiveType.TRIANGLES)}destroy(){null!=this._cache.indexBuffer&&this._cache.indexBuffer.dispose(),this._cache.vertexBuffers?.forEach((e=>e?.dispose())),this._cache.indexBuffer=this._cache.vertexBuffers=null}getIndexBuffer(e,r=_webgl_enums_js__WEBPACK_IMPORTED_MODULE_9__.Usage.STATIC_DRAW){return this._cache.indexBuffer??=_webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_8__.BufferObject.createIndex(e,r,this.indices),this._cache.indexBuffer}getVertexBuffers(e,r=_webgl_enums_js__WEBPACK_IMPORTED_MODULE_9__.Usage.STATIC_DRAW){return this._cache.vertexBuffers??=new Map(Object.keys(this.vertices).reduce(((t,o)=>(t.push([o,_webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_8__.BufferObject.createVertex(e,r,this.vertices[o])]),t)),new Array)),this._cache.vertexBuffers}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/PooledUint32Array.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/PooledUint32Array.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrayBufferPool: () => (/* binding */ i),
/* harmony export */   PooledUint32Array: () => (/* binding */ s)
/* harmony export */ });
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _core_maybe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../core/maybe.js */ "./node_modules/@arcgis/core/core/maybe.js");
/* harmony import */ var _cpuMapped_FreeList_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cpuMapped/FreeList.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/FreeList.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const r=(0,_core_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])("esri-2d-log-allocations");class s{static create(t,e){const r=e.acquireUint32Array(t);return new s(r,e)}constructor(t,e){this._array=t,this._pool=e}get array(){return this._array}get length(){return this._array.length}getUint32View(t,e){return new Uint32Array(this._array.buffer,t+this._array.byteOffset,e)}expand(t){if(t<=this._array.byteLength)return;const e=this._pool.acquireUint32Array(t);e.set(this._array),this._pool.releaseUint32Array(this._array),this._array=e}destroy(){this._pool.releaseUint32Array(this._array)}}class a{constructor(){this._data=new ArrayBuffer(a.BYTE_LENGTH),this._freeList=new _cpuMapped_FreeList_js__WEBPACK_IMPORTED_MODULE_2__.FreeList({start:0,end:this._data.byteLength})}static get BYTE_LENGTH(){return 16e6}get buffer(){return this._data}acquireUint32Array(t){const e=this._freeList.firstFit(t);return null==e?null:new Uint32Array(this._data,e,t/Uint32Array.BYTES_PER_ELEMENT)}releaseUint32Array(t){this._freeList.free(t.byteOffset,t.byteLength)}}class i{constructor(){this._pages=[],this._pagesByBuffer=new Map,this._bytesAllocated=0}destroy(){this._pages=[],this._pagesByBuffer=null}get _bytesTotal(){return this._pages.length*a.BYTE_LENGTH}acquireUint32Array(e){if(this._bytesAllocated+=e,r&&console.log(`Allocating ${e}, (${this._bytesAllocated} / ${this._bytesTotal})`),e>=a.BYTE_LENGTH)return new Uint32Array(e/Uint32Array.BYTES_PER_ELEMENT);for(const t of this._pages){const r=t.acquireUint32Array(e);if(null!=r)return r}const s=this._addPage().acquireUint32Array(e);return (0,_core_maybe_js__WEBPACK_IMPORTED_MODULE_1__.assertIsSome)(s,"Expected to allocate page"),s}releaseUint32Array(t){this._bytesAllocated-=t.byteLength,r&&console.log(`Freeing ${t.byteLength}, (${this._bytesAllocated} / ${this._bytesTotal})`);const e=this._pagesByBuffer.get(t.buffer);e&&e.releaseUint32Array(t)}_addPage(){const t=new a;return this._pages.push(t),this._pagesByBuffer.set(t.buffer,t),t}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/ReshufflePlan.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/ReshufflePlan.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReshufflePlan: () => (/* binding */ t)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
class t{constructor(t){this._indexOnly=t,this.vertex={count:0,operations:[]},this.index={count:0,operations:[]}}copyRecord(t){let e=0;this._indexOnly||(e=this.vertex.count-t.vertexStart,this.vertex.operations.push({srcFrom:t.vertexStart,dstFrom:this.vertex.count,count:t.vertexCount,mutate:0}),t.vertexStart=this.vertex.count,this.vertex.count+=t.vertexCount);let n=!1;if(this._indexOnly&&this.index.operations.length>=1){const e=this.index.operations[this.index.operations.length-1];e.srcFrom+e.count===t.indexStart&&(e.count+=t.indexCount,n=!0)}n||this.index.operations.push({srcFrom:t.indexStart,dstFrom:this.index.count,count:t.indexCount,mutate:e}),t.indexStart=this.index.count,this.index.count+=t.indexCount}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/WGLContainer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/WGLContainer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ n)
/* harmony export */ });
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _brushes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../brushes.js */ "./node_modules/@arcgis/core/views/2d/engine/brushes.js");
/* harmony import */ var _Container_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Container.js */ "./node_modules/@arcgis/core/views/2d/engine/Container.js");
/* harmony import */ var _ClippingInfo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ClippingInfo.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/ClippingInfo.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/enums.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
class n extends _Container_js__WEBPACK_IMPORTED_MODULE_2__.Container{set clips(s){super.clips=s,this._updateClippingInfo(s)}renderChildren(s){s.painter.setPipelineState(null),null==this._renderPasses&&(this._renderPasses=this.prepareRenderPasses(s.painter));for(const r of this._renderPasses)try{r.render(s)}catch(e){}}prepareRenderPasses(e){return[e.registerRenderPass({name:"clip",brushes:[_brushes_js__WEBPACK_IMPORTED_MODULE_1__.brushes.clip],target:()=>this._clippingInfos,drawPhase:_enums_js__WEBPACK_IMPORTED_MODULE_4__.WGLDrawPhase.MAP|_enums_js__WEBPACK_IMPORTED_MODULE_4__.WGLDrawPhase.LABEL|_enums_js__WEBPACK_IMPORTED_MODULE_4__.WGLDrawPhase.LABEL_ALPHA|_enums_js__WEBPACK_IMPORTED_MODULE_4__.WGLDrawPhase.DEBUG|_enums_js__WEBPACK_IMPORTED_MODULE_4__.WGLDrawPhase.HIGHLIGHT})]}_updateClippingInfo(s){null!=this._clippingInfos&&(this._clippingInfos.forEach((s=>s.destroy())),this._clippingInfos=null),null!=s&&s.length&&(this._clippingInfos=s.items.map((s=>_ClippingInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].fromClipArea(this.stage,s)))),this.requestRender()}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/BrushClip.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/BrushClip.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ p)
/* harmony export */ });
/* harmony import */ var _core_libs_gl_matrix_2_factories_vec4f32_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../core/libs/gl-matrix-2/factories/vec4f32.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/vec4f32.js");
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/Utils.js");
/* harmony import */ var _WGLBrush_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WGLBrush.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrush.js");
/* harmony import */ var _shaders_BackgroundPrograms_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/BackgroundPrograms.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BackgroundPrograms.js");
/* harmony import */ var _webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../webgl/enums.js */ "./node_modules/@arcgis/core/views/webgl/enums.js");
/* harmony import */ var _webgl_ProgramTemplate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../webgl/ProgramTemplate.js */ "./node_modules/@arcgis/core/views/webgl/ProgramTemplate.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const m=()=>(0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.createProgramDescriptor)("clip",{geometry:[{location:0,name:"a_pos",count:2,type:_webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__.DataType.SHORT}]});class p extends _WGLBrush_js__WEBPACK_IMPORTED_MODULE_2__["default"]{constructor(){super(...arguments),this._color=(0,_core_libs_gl_matrix_2_factories_vec4f32_js__WEBPACK_IMPORTED_MODULE_0__.fromValues)(0,1,0,1)}dispose(){this._program&&this._program.dispose()}prepareState({context:r}){r.setStencilTestEnabled(!0),r.setBlendingEnabled(!1),r.setFaceCullingEnabled(!1),r.setColorMask(!1,!1,!1,!1),r.setStencilOp(_webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__.StencilOperation.KEEP,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__.StencilOperation.KEEP,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__.StencilOperation.REPLACE),r.setStencilWriteMask(255),r.setStencilFunction(_webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__.CompareFunction.ALWAYS,0,255)}draw(r,e){const{context:t,state:o,requestRender:i,allowDelayedRender:p}=r,c=m(),d=e.getVAO(t,o,c.attributes,c.bufferLayouts);null!=d.indexBuffer&&(this._program||(this._program=(0,_webgl_ProgramTemplate_js__WEBPACK_IMPORTED_MODULE_5__.createProgram)(t,_shaders_BackgroundPrograms_js__WEBPACK_IMPORTED_MODULE_3__.background)),!p||null==i||this._program.compiled?(t.useProgram(this._program),this._program.setUniform2fv("u_coord_range",[1,1]),this._program.setUniform4fv("u_color",this._color),this._program.setUniformMatrix3fv("u_dvsMat3",o.displayMat3),t.bindVAO(d),t.drawElements(_webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__.PrimitiveType.TRIANGLES,d.indexBuffer.size,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_4__.DataType.UNSIGNED_INT,0),t.bindVAO()):i())}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushStencil.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushStencil.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _)
/* harmony export */ });
/* harmony import */ var _core_libs_gl_matrix_2_factories_vec4f32_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../core/libs/gl-matrix-2/factories/vec4f32.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/vec4f32.js");
/* harmony import */ var _DefaultVertexAttributeLayouts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DefaultVertexAttributeLayouts.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/DefaultVertexAttributeLayouts.js");
/* harmony import */ var _WGLBrush_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WGLBrush.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrush.js");
/* harmony import */ var _shaders_BackgroundPrograms_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/BackgroundPrograms.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BackgroundPrograms.js");
/* harmony import */ var _webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../webgl/BufferObject.js */ "./node_modules/@arcgis/core/views/webgl/BufferObject.js");
/* harmony import */ var _webgl_enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../webgl/enums.js */ "./node_modules/@arcgis/core/views/webgl/enums.js");
/* harmony import */ var _webgl_ProgramTemplate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../webgl/ProgramTemplate.js */ "./node_modules/@arcgis/core/views/webgl/ProgramTemplate.js");
/* harmony import */ var _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../webgl/VertexArrayObject.js */ "./node_modules/@arcgis/core/views/webgl/VertexArrayObject.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
class _ extends _WGLBrush_js__WEBPACK_IMPORTED_MODULE_2__["default"]{constructor(){super(...arguments),this._color=(0,_core_libs_gl_matrix_2_factories_vec4f32_js__WEBPACK_IMPORTED_MODULE_0__.fromValues)(1,0,0,1),this._initialized=!1}dispose(){this._solidProgram&&(this._solidProgram.dispose(),this._solidProgram=null),this._solidVertexArrayObject&&(this._solidVertexArrayObject.dispose(),this._solidVertexArrayObject=null)}prepareState({context:e}){e.setDepthWriteEnabled(!1),e.setDepthTestEnabled(!1),e.setStencilTestEnabled(!0),e.setBlendingEnabled(!1),e.setColorMask(!1,!1,!1,!1),e.setStencilOp(_webgl_enums_js__WEBPACK_IMPORTED_MODULE_5__.StencilOperation.KEEP,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_5__.StencilOperation.KEEP,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_5__.StencilOperation.REPLACE),e.setStencilWriteMask(255)}draw(e,r){const{context:t,requestRender:i,allowDelayedRender:s}=e;this._initialized||this._initialize(t),!s||null==i||this._solidProgram.compiled?(t.setStencilFunctionSeparate(_webgl_enums_js__WEBPACK_IMPORTED_MODULE_5__.Face.FRONT_AND_BACK,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_5__.CompareFunction.GREATER,r.stencilRef,255),t.bindVAO(this._solidVertexArrayObject),t.useProgram(this._solidProgram),this._solidProgram.setUniformMatrix3fv("u_dvsMat3",r.transforms.displayViewScreenMat3),this._solidProgram.setUniform2fv("u_coord_range",[r.rangeX,r.rangeY]),this._solidProgram.setUniform1f("u_depth",0),this._solidProgram.setUniform4fv("u_color",this._color),t.drawArrays(_webgl_enums_js__WEBPACK_IMPORTED_MODULE_5__.PrimitiveType.TRIANGLE_STRIP,0,4),t.bindVAO()):i()}_initialize(e){if(this._initialized)return!0;const t=(0,_webgl_ProgramTemplate_js__WEBPACK_IMPORTED_MODULE_6__.createProgram)(e,_shaders_BackgroundPrograms_js__WEBPACK_IMPORTED_MODULE_3__.background);if(!t)return!1;const o=new Int8Array([0,0,1,0,0,1,1,1]),a=_webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_4__.BufferObject.createVertex(e,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_5__.Usage.STATIC_DRAW,o),l=new _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_7__.VertexArrayObject(e,_shaders_BackgroundPrograms_js__WEBPACK_IMPORTED_MODULE_3__.background.attributes,_DefaultVertexAttributeLayouts_js__WEBPACK_IMPORTED_MODULE_1__.Pos2b,new Map([["geometry",a]]));return this._solidProgram=t,this._solidVertexArrayObject=l,this._initialized=!0,!0}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushTileDebugInfo.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushTileDebugInfo.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ y)
/* harmony export */ });
/* harmony import */ var _core_libs_gl_matrix_2_factories_vec4f32_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../core/libs/gl-matrix-2/factories/vec4f32.js */ "./node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/vec4f32.js");
/* harmony import */ var _DefaultVertexAttributeLayouts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DefaultVertexAttributeLayouts.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/DefaultVertexAttributeLayouts.js");
/* harmony import */ var _FeatureTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../FeatureTile.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/FeatureTile.js");
/* harmony import */ var _WGLBrush_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WGLBrush.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrush.js");
/* harmony import */ var _shaders_BackgroundPrograms_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/BackgroundPrograms.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BackgroundPrograms.js");
/* harmony import */ var _shaders_TileInfoPrograms_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shaders/TileInfoPrograms.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/TileInfoPrograms.js");
/* harmony import */ var _webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../webgl/BufferObject.js */ "./node_modules/@arcgis/core/views/webgl/BufferObject.js");
/* harmony import */ var _webgl_enums_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../webgl/enums.js */ "./node_modules/@arcgis/core/views/webgl/enums.js");
/* harmony import */ var _webgl_ProgramTemplate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../webgl/ProgramTemplate.js */ "./node_modules/@arcgis/core/views/webgl/ProgramTemplate.js");
/* harmony import */ var _webgl_Texture_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../webgl/Texture.js */ "./node_modules/@arcgis/core/views/webgl/Texture.js");
/* harmony import */ var _webgl_TextureDescriptor_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../webgl/TextureDescriptor.js */ "./node_modules/@arcgis/core/views/webgl/TextureDescriptor.js");
/* harmony import */ var _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../../webgl/VertexArrayObject.js */ "./node_modules/@arcgis/core/views/webgl/VertexArrayObject.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const _=512,x=512,b=16,p=8,T=(x-2*p)/5;class y extends _WGLBrush_js__WEBPACK_IMPORTED_MODULE_3__["default"]{constructor(){super(...arguments),this._color=(0,_core_libs_gl_matrix_2_factories_vec4f32_js__WEBPACK_IMPORTED_MODULE_0__.fromValues)(1,0,0,1)}dispose(){this._outlineProgram?.dispose(),this._outlineProgram=null,this._tileInfoProgram?.dispose(),this._tileInfoProgram=null,this._outlineVertexArrayObject?.dispose(),this._outlineVertexArrayObject=null,this._tileInfoVertexArrayObject?.dispose(),this._tileInfoVertexArrayObject=null,this._ctx=null}prepareState({context:e}){e.setBlendingEnabled(!0),e.setBlendFunctionSeparate(_webgl_enums_js__WEBPACK_IMPORTED_MODULE_7__.BlendFactor.ONE,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_7__.BlendFactor.ONE_MINUS_SRC_ALPHA,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_7__.BlendFactor.ONE,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_7__.BlendFactor.ONE_MINUS_SRC_ALPHA),e.setColorMask(!0,!0,!0,!0),e.setStencilWriteMask(0),e.setStencilTestEnabled(!1)}draw(e,t){const{context:o,requestRender:i,allowDelayedRender:s}=e;if(!t.isReady&&t instanceof _FeatureTile_js__WEBPACK_IMPORTED_MODULE_2__.FeatureTile&&t.hasData)return;if(this._loadWGLResources(o),s&&null!=i&&(!this._outlineProgram.compiled||!this._tileInfoProgram.compiled))return void i();o.bindVAO(this._outlineVertexArrayObject),o.useProgram(this._outlineProgram),this._outlineProgram.setUniformMatrix3fv("u_dvsMat3",t.transforms.displayViewScreenMat3),this._outlineProgram.setUniform2f("u_coord_range",t.rangeX,t.rangeY),this._outlineProgram.setUniform1f("u_depth",0),this._outlineProgram.setUniform4fv("u_color",this._color),o.drawArrays(_webgl_enums_js__WEBPACK_IMPORTED_MODULE_7__.PrimitiveType.LINE_STRIP,0,4);const n=this._getTexture(o,t);n?(o.bindVAO(this._tileInfoVertexArrayObject),o.useProgram(this._tileInfoProgram),o.bindTexture(n,0),this._tileInfoProgram.setUniformMatrix3fv("u_dvsMat3",t.transforms.displayViewScreenMat3),this._tileInfoProgram.setUniform1f("u_depth",0),this._tileInfoProgram.setUniform2f("u_coord_ratio",t.rangeX/t.width,t.rangeY/t.height),this._tileInfoProgram.setUniform2f("u_delta",0,0),this._tileInfoProgram.setUniform2f("u_dimensions",n.descriptor.width,n.descriptor.height),o.drawArrays(_webgl_enums_js__WEBPACK_IMPORTED_MODULE_7__.PrimitiveType.TRIANGLE_STRIP,0,4),o.bindVAO()):o.bindVAO()}_loadWGLResources(e){if(this._outlineProgram&&this._tileInfoProgram)return;const r=(0,_webgl_ProgramTemplate_js__WEBPACK_IMPORTED_MODULE_8__.createProgram)(e,_shaders_BackgroundPrograms_js__WEBPACK_IMPORTED_MODULE_4__.background),o=(0,_webgl_ProgramTemplate_js__WEBPACK_IMPORTED_MODULE_8__.createProgram)(e,_shaders_TileInfoPrograms_js__WEBPACK_IMPORTED_MODULE_5__.tileInfo),a=new Int8Array([0,0,1,0,1,1,0,1]),l=_webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_6__.BufferObject.createVertex(e,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_7__.Usage.STATIC_DRAW,a),m=new _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_11__.VertexArrayObject(e,_shaders_BackgroundPrograms_js__WEBPACK_IMPORTED_MODULE_4__.background.attributes,_DefaultVertexAttributeLayouts_js__WEBPACK_IMPORTED_MODULE_1__.Pos2b,new Map([["geometry",l]])),u=new Int8Array([0,0,1,0,0,1,1,1]),d=_webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_6__.BufferObject.createVertex(e,_webgl_enums_js__WEBPACK_IMPORTED_MODULE_7__.Usage.STATIC_DRAW,u),h=new _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_11__.VertexArrayObject(e,_shaders_TileInfoPrograms_js__WEBPACK_IMPORTED_MODULE_5__.tileInfo.attributes,_DefaultVertexAttributeLayouts_js__WEBPACK_IMPORTED_MODULE_1__.Pos2b,new Map([["geometry",d]]));this._outlineProgram=r,this._tileInfoProgram=o,this._outlineVertexArrayObject=m,this._tileInfoVertexArrayObject=h}_getTexture(e,t){if(!this._ctx){const e=document.createElement("canvas");e.width=_,e.height=x,this._ctx=e.getContext("2d")}if(!t.tileDebugInfoTexture){const r=new _webgl_TextureDescriptor_js__WEBPACK_IMPORTED_MODULE_10__.TextureDescriptor;r.wrapMode=_webgl_enums_js__WEBPACK_IMPORTED_MODULE_7__.TextureWrapMode.CLAMP_TO_EDGE,r.samplingMode=_webgl_enums_js__WEBPACK_IMPORTED_MODULE_7__.TextureSamplingMode.LINEAR,r.isImmutable=!0,r.width=_,r.height=x,t.tileDebugInfoTexture=new _webgl_Texture_js__WEBPACK_IMPORTED_MODULE_9__.Texture(e,r)}const r=this._ctx;r.clearRect(0,0,r.canvas.width,r.canvas.height),r.textAlign="left",r.textBaseline="top",r.font=b-2+"px sans-serif",r.lineWidth=2,r.fillStyle="white",r.strokeStyle="black";const{debugSlot:o}=t;let i=p+T*o;const s=`${o}) ${t.key.id} (${t.constructor.name})`;r.strokeText(s,p,i),r.fillText(s,p,i),i+=b;const{debugInfo:n}=t;if(n){const{length:e,minOrderedLength:t,minUnorderedLength:o,triangleCount:s}=n.display;if(e>0){const t=`Length: ${e}`;r.strokeText(t,p,i),r.fillText(t,p,i),i+=b}if(t){const e=`Min ordered length: ${t}`;r.strokeText(e,p,i),r.fillText(e,p,i),i+=b}if(o){const e=`Min unordered length: ${o}`;r.strokeText(e,p,i),r.fillText(e,p,i),i+=b}if(s>0){s>1e5&&(r.fillStyle="red",r.strokeStyle="white");const e=`Triangle count: ${s}`;r.strokeText(e,p,i),r.fillText(e,p,i),i+=b}const{bytesUsed:a,bytesReserved:l}=n.memory;if(r.fillStyle="white",r.strokeStyle="black",a>0||l>0){const e=`Memory usage: ${a} of ${l} bytes`;r.strokeText(e,p,i),r.fillText(e,p,i),i+=b}}return t.tileDebugInfoTexture.setData(r.canvas),t.tileDebugInfoTexture}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Buffer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Buffer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MappedBuffer: () => (/* binding */ o)
/* harmony export */ });
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _core_maybe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../core/maybe.js */ "./node_modules/@arcgis/core/core/maybe.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../number.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/number.js");
/* harmony import */ var _PooledUint32Array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PooledUint32Array.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/PooledUint32Array.js");
/* harmony import */ var _FreeList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FreeList.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/FreeList.js");
/* harmony import */ var _webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../webgl/BufferObject.js */ "./node_modules/@arcgis/core/views/webgl/BufferObject.js");
/* harmony import */ var _webgl_enums_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../webgl/enums.js */ "./node_modules/@arcgis/core/views/webgl/enums.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const a=1.25,d=32767,u=d<<16|d;class o{constructor(t,i,r,s){this._pool=s;const n=_PooledUint32Array_js__WEBPACK_IMPORTED_MODULE_3__.PooledUint32Array.create(i*r*Uint32Array.BYTES_PER_ELEMENT,this._pool);this.size=i,this.strideInt=r,this.bufferType=t,this.dirty={start:1/0,end:0},this.memoryStats={bytesUsed:0,bytesReserved:i*r*Uint32Array.BYTES_PER_ELEMENT},this._gpu=null,this._cpu=n,this.clear()}get elementSize(){return this._cpu.length/this.strideInt}get intSize(){return this.fillPointer*this.strideInt}get byteSize(){return this.intSize*Uint32Array.BYTES_PER_ELEMENT}get invalidated(){return this.bufferSize>0&&!this._gpu}get invalidatedComputeBuffer(){return this.bufferSize>0&&!this._gpuComputeTriangles}invalidate(){this._invalidateTriangleBuffer(),this._gpu?.dispose(),this._gpu=null}_invalidateTriangleBuffer(){this._gpuComputeTriangles?.dispose(),this._gpuComputeTriangles=null}destroy(){this._gpu?.dispose(),this._gpuComputeTriangles?.dispose(),this._cpu?.destroy()}clear(){this.dirty.start=1/0,this.dirty.end=0,this.freeList=new _FreeList_js__WEBPACK_IMPORTED_MODULE_4__.FreeList({start:0,end:this._cpu.length/this.strideInt}),this.fillPointer=0}ensure(t){if(this.maxAvailableSpace()>=t)return;if(t*this.strideInt>this._cpu.length-this.fillPointer){this.invalidate();const i=this._cpu.length/this.strideInt,r=Math.round((i+t)*a),e=r*this.strideInt;this._cpu.expand(e*Uint32Array.BYTES_PER_ELEMENT),this.freeList.free(i,r-i),this.memoryStats.bytesReserved+=(r-i)*this.strideInt*Uint32Array.BYTES_PER_ELEMENT}}setU32(t,i){this._cpu.array[t]!==i&&(this._cpu.array[t]=i,this.dirty.start=Math.min(t,this.dirty.start),this.dirty.end=Math.max(t+1,this.dirty.end))}setF32(t,r){this.setU32(t,(0,_number_js__WEBPACK_IMPORTED_MODULE_2__.toUint32)(r))}setF32Range(t,r,e){const s=(0,_number_js__WEBPACK_IMPORTED_MODULE_2__.toUint32)(e);this._cpu.array.fill(s,t,r),this.dirty.start=Math.min(t,this.dirty.start),this.dirty.end=Math.max(r,this.dirty.end)}getF32(t){return (0,_number_js__WEBPACK_IMPORTED_MODULE_2__.toFloat32)(this._cpu.array[t])}getGPUBuffer(t,i=!1){if(!this.bufferSize)return null;if(i){if("index"!==this.bufferType)throw new Error("Tired to get triangle buffer, but target is not an index buffer");return null==this._gpuComputeTriangles&&(this._gpuComputeTriangles=this._createComputeBuffer(t)),this._gpuComputeTriangles}return null==this._gpu&&(this._gpu=this._createBuffer(t)),this._gpu}getView(t,i){return this._cpu.getUint32View(t,i/Uint32Array.BYTES_PER_ELEMENT)}get bufferSize(){return this._cpu.length/this.strideInt}maxAvailableSpace(){return this.freeList.maxAvailableSpace()}insert(i,r,e,s){const n=e*this.strideInt;if(!n)return 0;const h=r*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,a=new Uint32Array(i,h,n),d=this.freeList.firstFit(e);(0,_core_maybe_js__WEBPACK_IMPORTED_MODULE_1__.assertIsSome)(d,"First fit region must be defined");const u=d*this.strideInt,o=n;if(this._cpu.array.set(a,u),0!==s)for(let t=0;t<a.length;t++)this._cpu.array[t+u]+=s;return this.dirty.start=Math.min(this.dirty.start,u),this.dirty.end=Math.max(this.dirty.end,u+o),this.fillPointer=Math.max(this.fillPointer,u+o),this.memoryStats.bytesUsed+=e*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,d}copyFrom(i,r,e,s,n){const h=e*this.strideInt;if(!h)return 0;const a=r*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,d=i._cpu.getUint32View(a,h),u=this.freeList.firstFit(e);(0,_core_maybe_js__WEBPACK_IMPORTED_MODULE_1__.assertIsSome)(u,"First fit region must be defined");const o=u*this.strideInt,f=h;if(this._cpu.array.set(d,o),0!==s)for(let t=0;t<h;t++)this._cpu.array[o+t*this.strideInt+n]+=s;return this.dirty.start=Math.min(this.dirty.start,o),this.dirty.end=Math.max(this.dirty.end,o+f),this.fillPointer=Math.max(this.fillPointer,o+f),this.memoryStats.bytesUsed+=e*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,u}free(t,i,r){const e=t*this.strideInt,s=(t+i)*this.strideInt;if(!0===r)for(let n=t;n!==t+i;n++)this._cpu.array[n*this.strideInt]=u;this.dirty.start=Math.min(this.dirty.start,e),this.dirty.end=Math.max(this.dirty.end,s),this.freeList.free(t,i),this.memoryStats.bytesUsed-=i*this.strideInt*Uint32Array.BYTES_PER_ELEMENT}upload(){if(this.dirty.end){if(this._invalidateTriangleBuffer(),null==this._gpu)return this.dirty.start=1/0,void(this.dirty.end=0);this._gpu.setSubData(this._cpu.array,this.dirty.start,this.dirty.start,this.dirty.end),this.dirty.start=1/0,this.dirty.end=0}}reshuffle(t,i){if(0===i.length)return;const r=this.byteSize,s=t*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,n=r>s,h=this._cpu,a=_PooledUint32Array_js__WEBPACK_IMPORTED_MODULE_3__.PooledUint32Array.create(s,this._pool);n||a.array.set(this._cpu.getUint32View(0,this.intSize));for(const e of i)if(n||e.srcFrom!==e.dstFrom||0!==e.mutate){this.dirty.start=Math.min(this.dirty.start,e.dstFrom*this.strideInt),this.dirty.end=Math.max(this.dirty.end,(e.dstFrom+e.count)*this.strideInt);for(let t=0;t<e.count;t++){const i=(e.dstFrom+t)*this.strideInt,r=(e.srcFrom+t)*this.strideInt;for(let t=0;t<this.strideInt;t++)a.array[i+t]=h.array[r+t]+e.mutate}}this._cpu.destroy(),this._cpu=a,n&&this.invalidate(),this.freeList.clear(),this.memoryStats.bytesUsed=this.memoryStats.bytesReserved=s}_createBuffer(t){const i=_webgl_enums_js__WEBPACK_IMPORTED_MODULE_6__.Usage.DYNAMIC_DRAW;return"index"===this.bufferType?_webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_5__.BufferObject.createIndex(t,i,this._cpu.array):_webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_5__.BufferObject.createVertex(t,i,this._cpu.array)}_createComputeBuffer(t){const i=_webgl_enums_js__WEBPACK_IMPORTED_MODULE_6__.Usage.DYNAMIC_DRAW,r=new Uint32Array(this.fillPointer/3);for(let e=0;e<this.fillPointer;e+=3)r[e/3]=this._cpu.array[e];return _webgl_BufferObject_js__WEBPACK_IMPORTED_MODULE_5__.BufferObject.createIndex(t,i,r)}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/FreeList.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/FreeList.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FreeList: () => (/* binding */ a),
/* harmony export */   List: () => (/* binding */ t)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
class t{constructor(a){if(this.next=null,!Array.isArray(a))return void(this.data=a);this.data=a[0];let e=this;for(let n=1;n<a.length;n++)e.next=new t([a[n]]),e=e.next}*values(){let t=this;for(;t;)yield t.data,t=t.next}forEach(t){let a=this;for(;a;)t(a.data),a=a.next}get last(){return this.next?this.next.last:this}}class a{constructor(a){this._head=null,null!=a&&(this._head=new t(a))}get head(){return this._head}maxAvailableSpace(){if(null==this._head)return 0;let t=0;return this._head.forEach((a=>{const e=a.end-a.start;t=Math.max(t,e)})),t}firstFit(t){if(null==this._head)return null;let a=null,e=this._head;for(;e;){const n=e.data.end-e.data.start;if(n===t)return a?a.next=e.next:this._head=e.next,e.data.start;if(n>t){const a=e.data.start;return e.data.start+=t,a}a=e,e=e.next}return null}free(a,e){const n=a+e;if(null==this._head){const e=new t({start:a,end:n});return void(this._head=e)}if(n<=this._head.data.start){if(n===this._head.data.start)return void(this._head.data.start-=e);const r=new t({start:a,end:n});return r.next=this._head,void(this._head=r)}let r=this._head,d=r.next;for(;d;){if(d.data.start>=n){if(r.data.end===a){if(r.data.end+=e,r.data.end===d.data.start){const t=d.data.end-d.data.start;return r.data.end+=t,void(r.next=d.next)}return}if(d.data.start===n)return void(d.data.start-=e);const s=new t({start:a,end:n});return s.next=r.next,void(r.next=s)}r=d,d=d.next}if(a===r.data.end)return void(r.data.end+=e);const s=new t({start:a,end:n});r.next=s}clear(){this._head=null}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/MappedMesh.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/MappedMesh.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MappedMesh: () => (/* binding */ y)
/* harmony export */ });
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _core_maybe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../core/maybe.js */ "./node_modules/@arcgis/core/core/maybe.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../number.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/number.js");
/* harmony import */ var _Buffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Buffer.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Buffer.js");
/* harmony import */ var _shaderGraph_techniques_mesh_dataViewUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaderGraph/techniques/mesh/dataViewUtils.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/dataViewUtils.js");
/* harmony import */ var _shaderGraph_techniques_mesh_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shaderGraph/techniques/mesh/utils.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/utils.js");
/* harmony import */ var _webgl_enums_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../webgl/enums.js */ "./node_modules/@arcgis/core/views/webgl/enums.js");
/* harmony import */ var _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../webgl/VertexArrayObject.js */ "./node_modules/@arcgis/core/views/webgl/VertexArrayObject.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const u=1e3,a=4,h=[{name:"visibility",offset:0,type:_webgl_enums_js__WEBPACK_IMPORTED_MODULE_6__.DataType.FLOAT,count:1}],l={hash:(0,_shaderGraph_techniques_mesh_utils_js__WEBPACK_IMPORTED_MODULE_5__.vertexLayoutHash)(h),attributes:h,stride:a};function _(e,t){const i=e.attributes.filter((e=>t.locations.has(e.name))).map((t=>({name:t.name,type:t.type,count:t.count,divisor:0,normalized:t.normalized??!1,offset:t.offset,stride:e.stride})));return new Map([["geometry",i]])}function d(e,t){const i=[],r=e.attributes.filter((e=>t.locations.has(e.name)));for(const s of r){i.push({name:s.name,type:s.type,count:s.count,divisor:0,normalized:s.normalized??!1,offset:s.offset,stride:e.stride});const r=t.computeAttributeMap[s.name];null!=r&&2===r.length&&(i.push({name:r[0],count:s.count,divisor:0,type:s.type,normalized:s.normalized??!1,offset:s.offset+e.stride,stride:e.stride}),i.push({name:r[1],count:s.count,divisor:0,type:s.type,normalized:s.normalized??!1,offset:s.offset+2*e.stride,stride:e.stride}))}return new Map([["geometry",i]])}class y{constructor(e,t,i){if(this._bufferPool=e,this._layout=t,this.useVisibility=i,this._invalidatedGeometry=!1,this._invalidatedCompute=!1,this._position=this._layout.attributes.find((e=>"pos"===e.name||"position"===e.name)),!this._position)throw new Error("InternalError: Unable to find position attribute")}destroy(){this._indexBuffer=(0,_core_maybe_js__WEBPACK_IMPORTED_MODULE_1__.destroyMaybe)(this._indexBuffer),this._vertexBuffer=(0,_core_maybe_js__WEBPACK_IMPORTED_MODULE_1__.destroyMaybe)(this._vertexBuffer),this._visibilityBuffer=(0,_core_maybe_js__WEBPACK_IMPORTED_MODULE_1__.destroyMaybe)(this._visibilityBuffer),this._computeVAO?.disposeVAOOnly(),this._geometryVAO?.disposeVAOOnly()}get layout(){return this._layout}getDrawArgs(e,t,i,r){return r?{primitive:_webgl_enums_js__WEBPACK_IMPORTED_MODULE_6__.PrimitiveType.POINTS,count:t/3,offset:i/3}:{primitive:e,count:t,offset:i}}getAttributePrecisionPackFactors(){const e={};for(const t of this.layout.attributes)t.packPrecisionFactor&&(e[t.name]=t.packPrecisionFactor);return e}getDebugVertexInfo(e=!1,t){if(!this._vertexBuffer)return null;const i=this._layout,s=i.stride,f=this._vertexBuffer.getView(0,this._vertexBuffer.byteSize),o=[];if(e)if(null==t)console.log("must provide location info to see compute attributes");else for(const r of i.attributes){const e=t.computeAttributeMap[r.name];null!=e&&2===e.length&&(o.push({...r,name:e[0],offset:r.offset+s}),o.push({...r,name:e[1],offset:r.offset+2*s}))}const n=new DataView(f.slice().buffer);let u=f.byteLength/s;e&&(u=this._indexBuffer.fillPointer/3);const a=this._indexBuffer.getView(0,this._indexBuffer.byteSize);let h=0;const l=[];for(let _=0;_<u;_++){if(e){h=a[3*_]*s}const t={};for(const e of[...i.attributes,...o]){let i=`${e.offset} ${e.name}`,s=(0,_shaderGraph_techniques_mesh_dataViewUtils_js__WEBPACK_IMPORTED_MODULE_4__.unpackDataView)(n,e,h);if(e.packPrecisionFactor)if(i+=` (precision: ${e.packPrecisionFactor})`,"number"==typeof s)s/=e.packPrecisionFactor;else for(let t=0;t<s.length;t++)s[t]/=e.packPrecisionFactor;t[i]=s}h+=s,l.push(t)}return{vertices:l,layout:i}}_ensure(e,t){if(this._vertexBuffer&&this._indexBuffer)this._indexBuffer.ensure(Math.max(e,u)),this._vertexBuffer.ensure(Math.max(t,u)),this._visibilityBuffer&&this._visibilityBuffer.ensure(Math.max(t,u));else{const r=this._layout.stride/Uint32Array.BYTES_PER_ELEMENT;this._indexBuffer=new _Buffer_js__WEBPACK_IMPORTED_MODULE_3__.MappedBuffer("index",Math.max(e,u),1,this._bufferPool),this._vertexBuffer=new _Buffer_js__WEBPACK_IMPORTED_MODULE_3__.MappedBuffer("vertex",Math.max(t,u),r,this._bufferPool),this.useVisibility&&(this._visibilityBuffer=new _Buffer_js__WEBPACK_IMPORTED_MODULE_3__.MappedBuffer("vertex",Math.max(t,u),a/Uint32Array.BYTES_PER_ELEMENT,this._bufferPool))}}append(e){const t=e.layout.stride,i=e.indices.byteLength/Uint32Array.BYTES_PER_ELEMENT,r=e.vertices.byteLength/t;this._ensure(i,r);const{vertices:s,indices:f}=e,o=this._vertexBuffer.insert(s,0,s.byteLength/t,0),n=new Uint32Array(r);new Float32Array(n.buffer).fill(255),this._visibilityBuffer&&this._visibilityBuffer.insert(n,0,n.byteLength/a,0);return{vertexFrom:o,indexFrom:this._indexBuffer.insert(f,0,f.byteLength/4,o)}}setEntityRecordRangeVisibility(e,t,i,r){if(!(t+i>e.length))for(let s=t;s<t+i;s++){const{vertexStart:t,vertexCount:i}=e[s];this._visibilityBuffer.setF32Range(t,t+i,r)}}getEntityRecordVisibility(e,t){const i=e.records[t];return this._visibilityBuffer.getF32(i.vertexStart)}copyRecordFrom(e,i,r,s){const{indexStart:f,indexCount:o,vertexStart:n,vertexCount:u}=i;this._ensure(o,u);const a=e._position,h=r*(a.packPrecisionFactor??1),l=s*(a.packPrecisionFactor??1),_=a.offset,d=(0,_number_js__WEBPACK_IMPORTED_MODULE_2__.i1616to32)(h,l),y=this._vertexBuffer.copyFrom(e._vertexBuffer,n,u,d,_);this._visibilityBuffer&&e._visibilityBuffer&&this._visibilityBuffer.copyFrom(e._visibilityBuffer,n,u,0,0);const v=this._indexBuffer.copyFrom(e._indexBuffer,f,o,y-n,0),c=i.clone();return c.vertexStart=y,c.indexStart=v,c.overlaps=0,c}remove(e,t,i,r){this._indexBuffer.free(e,t),this._vertexBuffer.free(i,r),this._visibilityBuffer&&this._visibilityBuffer.free(i,r)}upload(){this._invalidatedGeometry=!0,this._invalidatedCompute=!0}getGeometryVAO(e,t){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;if(this._invalidatedGeometry){(this._vertexBuffer.invalidated||this._indexBuffer.invalidated||this._visibilityBuffer?.invalidated)&&(this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),this._visibilityBuffer&&this._visibilityBuffer.invalidate(),this._geometryVAO?.disposeVAOOnly(),this._geometryVAO=null),this._vertexBuffer.upload(),this._indexBuffer.upload(),this._visibilityBuffer&&this._visibilityBuffer.upload();const i=this._indexBuffer.getGPUBuffer(e,!1),r=new Map([["geometry",this._vertexBuffer.getGPUBuffer(e)]]);if(this._visibilityBuffer&&r.set("visibility",this._visibilityBuffer.getGPUBuffer(e)),!this._geometryVAO){const s=_(this.layout,t);s.set("visibility",_(l,t).get("geometry")),this._geometryVAO=new _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_7__.VertexArrayObject(e,t.locations,s,r,i)}this._invalidatedGeometry=!1}return this._geometryVAO}getComputeVAO(e,t){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;if(this._invalidatedCompute){(this._vertexBuffer.invalidated||this._indexBuffer.invalidatedComputeBuffer)&&(this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),this._visibilityBuffer&&this._visibilityBuffer.invalidate(),this._computeVAO?.disposeVAOOnly(),this._computeVAO=null),this._vertexBuffer.upload(),this._indexBuffer.upload(),this._visibilityBuffer&&this._visibilityBuffer.upload();const i=this._indexBuffer.getGPUBuffer(e,!0),r=new Map([["geometry",this._vertexBuffer.getGPUBuffer(e)]]);if(this._visibilityBuffer&&r.set("visibility",this._visibilityBuffer.getGPUBuffer(e)),!this._computeVAO){const s=d(this.layout,t);s.set("visibility",_(l,t).get("geometry")),this._computeVAO=new _webgl_VertexArrayObject_js__WEBPACK_IMPORTED_MODULE_7__.VertexArrayObject(e,t.locations,s,r,i),this._invalidatedCompute=!1}}return this._computeVAO}get memoryStats(){return{bytesUsed:this._vertexBuffer.memoryStats.bytesUsed+this._indexBuffer.memoryStats.bytesUsed,bytesReserved:this._vertexBuffer.memoryStats.bytesReserved+this._indexBuffer.memoryStats.bytesReserved,vertex:this._vertexBuffer.memoryStats,index:this._indexBuffer.memoryStats}}reshuffle(e){this._vertexBuffer&&this._vertexBuffer.reshuffle(e.vertex.count,e.vertex.operations),this._indexBuffer&&this._indexBuffer.reshuffle(e.index.count,e.index.operations),this._visibilityBuffer&&this._visibilityBuffer.reshuffle(e.vertex.count,e.vertex.operations)}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/mesh/meshDebugUtils.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/mesh/meshDebugUtils.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   debugMeshDataInfo: () => (/* binding */ s)
/* harmony export */ });
/* harmony import */ var _DisplayEntity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DisplayEntity.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/DisplayEntity.js");
/* harmony import */ var _collisions_LabelMetric_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collisions/LabelMetric.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/collisions/LabelMetric.js");
/* harmony import */ var _shaderGraph_techniques_mesh_dataViewUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shaderGraph/techniques/mesh/dataViewUtils.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/dataViewUtils.js");
/* harmony import */ var _util_Reader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Reader.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/util/Reader.js");
/* harmony import */ var _util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/serializationUtils.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/util/serializationUtils.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
function s(e){if(!e)return null;return{entities:(0,_util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_4__.deserializeList)(new _util_Reader_js__WEBPACK_IMPORTED_MODULE_3__["default"](e.entities),_DisplayEntity_js__WEBPACK_IMPORTED_MODULE_0__["default"]),vertexData:e.data.map(a)}}function a(t){const s=t.layout.stride,a=new DataView(t.vertices),n=[],c=t.vertices.byteLength/s;let l=0;for(let e=0;e<c;e++){const e={};for(const r of t.layout.attributes){let t=`${r.offset} ${r.name}`,o=(0,_shaderGraph_techniques_mesh_dataViewUtils_js__WEBPACK_IMPORTED_MODULE_2__.unpackDataView)(a,r,l);if(r.packPrecisionFactor)if(t+=` (precision: ${r.packPrecisionFactor})`,"number"==typeof o)o/=r.packPrecisionFactor;else for(let e=0;e<o.length;e++)o[e]/=r.packPrecisionFactor;e[t]=o}l+=s,n.push(e)}const f=t.metrics?(0,_util_serializationUtils_js__WEBPACK_IMPORTED_MODULE_4__.deserializeList)(new _util_Reader_js__WEBPACK_IMPORTED_MODULE_3__["default"](t.metrics),_collisions_LabelMetric_js__WEBPACK_IMPORTED_MODULE_1__.LabelMetric)??[]:[];return{vertices:n,layout:t.layout,metrics:f}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BackgroundPrograms.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BackgroundPrograms.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   background: () => (/* binding */ e)
/* harmony export */ });
/* harmony import */ var _sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sources/resolver.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/sources/resolver.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const e={shaders:{vertexShader:(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("background/background.vert"),fragmentShader:(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("background/background.frag")},attributes:new Map([["a_pos",0]])};


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/TileInfoPrograms.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/TileInfoPrograms.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tileInfo: () => (/* binding */ r)
/* harmony export */ });
/* harmony import */ var _sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sources/resolver.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/sources/resolver.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const r={shaders:{vertexShader:(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("tileInfo/tileInfo.vert"),fragmentShader:(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("tileInfo/tileInfo.frag")},attributes:new Map([["a_pos",0]])};


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/sources/resolver.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/sources/resolver.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveIncludes: () => (/* binding */ n)
/* harmony export */ });
/* harmony import */ var _shaderRepository_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaderRepository.js */ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/sources/shaderRepository.js");
/* harmony import */ var _webgl_ShaderCompiler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../webgl/ShaderCompiler.js */ "./node_modules/@arcgis/core/views/webgl/ShaderCompiler.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
function o(r){return function(e){let o=r;return e.split("/").forEach((r=>{o&&(o=o[r])})),o}}const t=new _webgl_ShaderCompiler_js__WEBPACK_IMPORTED_MODULE_1__.ShaderCompiler(o(_shaderRepository_js__WEBPACK_IMPORTED_MODULE_0__["default"]));function n(r){return t.resolveIncludes(r)}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/sources/shaderRepository.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/shaders/sources/shaderRepository.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const e={background:{"background.frag":"uniform lowp vec4 u_color;\nvoid main() {\ngl_FragColor = u_color;\n}","background.vert":"attribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump vec2 u_coord_range;\nuniform mediump float u_depth;\nvoid main() {\nvec3 v_pos = u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0);\ngl_Position = vec4(v_pos.xy, 0.0, 1.0);\n}"},bitBlit:{"bitBlit.frag":"uniform lowp sampler2D u_tex;\nuniform lowp float u_opacity;\nvarying mediump vec2 v_uv;\nvoid main() {\nlowp vec4 color = texture2D(u_tex, v_uv);\ngl_FragColor = color * u_opacity;\n}","bitBlit.vert":"attribute vec2 a_pos;\nattribute vec2 a_tex;\nvarying mediump vec2 v_uv;\nvoid main(void) {\ngl_Position = vec4(a_pos , 0.0, 1.0);\nv_uv = a_tex;\n}"},debug:{overlay:{"overlay.frag":"precision mediump float;\nvarying vec4 v_color;\nvoid main(void) {\ngl_FragColor = v_color;\n}","overlay.vert":"attribute vec3 a_PositionAndFlags;\nuniform mat3 u_dvsMat3;\nuniform vec4 u_colors[4];\nuniform float u_opacities[4];\nvarying vec4 v_color;\nvoid main(void) {\nvec2 position = a_PositionAndFlags.xy;\nfloat flags = a_PositionAndFlags.z;\nint colorIndex = int(mod(flags, 4.0));\nvec4 color;\nfor (int i = 0; i < 4; i++) {\ncolor = u_colors[i];\nif (i == colorIndex) {\nbreak;\n}\n}\nint opacityIndex = int(mod(floor(flags / 4.0), 4.0));\nfloat opacity;\nfor (int i = 0; i < 4; i++) {\nopacity = u_opacities[i];\nif (i == opacityIndex) {\nbreak;\n}\n}\nv_color = color * opacity;\ngl_Position = vec4((u_dvsMat3 * vec3(position, 1.0)).xy, 0.0, 1.0);\n}"}},dot:{dot:{"dot.frag":"precision mediump float;\nvarying vec4 v_color;\nvarying float v_dotRatio;\nvarying float v_invEdgeRatio;\nuniform highp float u_tileZoomFactor;\nvoid main()\n{\nfloat dist = length(gl_PointCoord - vec2(.5, .5)) * 2.;\nfloat alpha = smoothstep(0., 1., v_invEdgeRatio * (dist - v_dotRatio) + 1.);\ngl_FragColor = v_color * alpha;\n}","dot.vert":"precision highp float;\nattribute vec2 a_pos;\nuniform sampler2D u_texture;\nuniform highp mat3 u_dvsMat3;\nuniform highp float u_tileZoomFactor;\nuniform highp float u_dotSize;\nuniform highp float u_pixelRatio;\nvarying vec2 v_pos;\nvarying vec4 v_color;\nvarying float v_dotRatio;\nvarying float v_invEdgeRatio;\nconst float EPSILON = 0.000001;\nvoid main()\n{\nmat3 tileToTileTexture = mat3(  1., 0., 0.,\n0., -1., 0.,\n0., 1., 1.  );\nvec3 texCoords = tileToTileTexture * vec3(a_pos.xy / 512., 1.);\nv_color = texture2D(u_texture, texCoords.xy);\nfloat smoothEdgeWidth = max(u_dotSize / 2., 1.) ;\nfloat z = 0.;\nz += 2.0 * step(v_color.a, EPSILON);\ngl_PointSize = (smoothEdgeWidth + u_dotSize);\ngl_Position = vec4((u_dvsMat3 * vec3(a_pos + .5, 1.)).xy, z, 1.);\nv_dotRatio = u_dotSize / gl_PointSize;\nv_invEdgeRatio = -1. / ( smoothEdgeWidth / gl_PointSize );\ngl_PointSize  *= (u_pixelRatio * u_tileZoomFactor);\n}"}},filtering:{"bicubic.glsl":"vec4 computeWeights(float v) {\nfloat b = 1.0 / 6.0;\nfloat v2 = v * v;\nfloat v3 = v2 * v;\nfloat w0 = b * (-v3 + 3.0 * v2 - 3.0 * v + 1.0);\nfloat w1 = b * (3.0 * v3  - 6.0 * v2 + 4.0);\nfloat w2 = b * (-3.0 * v3 + 3.0 * v2 + 3.0 * v + 1.0);\nfloat w3 = b * v3;\nreturn vec4(w0, w1, w2, w3);\n}\nvec4 bicubicOffsetsAndWeights(float v) {\nvec4 w = computeWeights(v);\nfloat g0 = w.x + w.y;\nfloat g1 = w.z + w.w;\nfloat h0 = 1.0 - (w.y / g0) + v;\nfloat h1 = 1.0 + (w.w / g1) - v;\nreturn vec4(h0, h1, g0, g1);\n}\nvec4 sampleBicubicBSpline(sampler2D sampler, vec2 coords, vec2 texSize) {\nvec2 eX = vec2(1.0 / texSize.x, 0.0);\nvec2 eY = vec2(0.0, 1.0 / texSize.y);\nvec2 texel = coords * texSize - 0.5;\nvec3 hgX = bicubicOffsetsAndWeights(fract(texel).x).xyz;\nvec3 hgY = bicubicOffsetsAndWeights(fract(texel).y).xyz;\nvec2 coords10 = coords + hgX.x * eX;\nvec2 coords00 = coords - hgX.y * eX;\nvec2 coords11 = coords10 + hgY.x * eY;\nvec2 coords01 = coords00 + hgY.x * eY;\ncoords10 = coords10 - hgY.y * eY;\ncoords00 = coords00 - hgY.y * eY;\nvec4 color00 = texture2D(sampler, coords00);\nvec4 color10 = texture2D(sampler, coords10);\nvec4 color01 = texture2D(sampler, coords01);\nvec4 color11 = texture2D(sampler, coords11);\ncolor00 = mix(color00, color01, hgY.z);\ncolor10 = mix(color10, color11, hgY.z);\ncolor00 = mix(color00, color10, hgX.z);\nreturn color00;\n}","bilinear.glsl":"vec4 sampleBilinear(sampler2D sampler, vec2 coords, vec2 texSize) {\nvec2 texelStart = floor(coords * texSize);\nvec2 coord0 = texelStart / texSize;\nvec2 coord1 = (texelStart +  vec2(1.0, 0.0)) / texSize;\nvec2 coord2 = (texelStart +  vec2(0.0, 1.0)) / texSize;\nvec2 coord3 = (texelStart +  vec2(1.0, 1.0)) / texSize;\nvec4 color0 = texture2D(sampler, coord0);\nvec4 color1 = texture2D(sampler, coord1);\nvec4 color2 = texture2D(sampler, coord2);\nvec4 color3 = texture2D(sampler, coord3);\nvec2 blend = fract(coords * texSize);\nvec4 color01 = mix(color0, color1, blend.x);\nvec4 color23 = mix(color2, color3, blend.x);\nvec4 color = mix(color01, color23, blend.y);\n#ifdef NNEDGE\nfloat alpha = floor(color0.a * color1.a * color2.a * color3.a + 0.5);\ncolor = color * alpha + (1.0 - alpha) * texture2D(sampler, coords);\n#endif\nreturn color;\n}","epx.glsl":"vec4 sampleEPX(sampler2D sampler, float size, vec2 coords, vec2 texSize) {\nvec2 invSize = 1.0 / texSize;\nvec2 texel = coords * texSize;\nvec2 texel_i = floor(texel);\nvec2 texel_frac = fract(texel);\nvec4 colorP = texture2D(sampler, texel_i * invSize);\nvec4 colorP1 = vec4(colorP);\nvec4 colorP2 = vec4(colorP);\nvec4 colorP3 = vec4(colorP);\nvec4 colorP4 = vec4(colorP);\nvec4 colorA = texture2D(sampler, (texel_i - vec2(0.0, 1.0)) * invSize);\nvec4 colorB = texture2D(sampler, (texel_i + vec2(1.0, 0.0)) * invSize);\nvec4 colorC = texture2D(sampler, (texel_i - vec2(1.0, 0.0)) * invSize);\nvec4 colorD = texture2D(sampler, (texel_i + vec2(0.0, 1.0)) * invSize);\nif (colorC == colorA && colorC != colorD && colorA != colorB) {\ncolorP1 = colorA;\n}\nif (colorA == colorB && colorA != colorC && colorB != colorD) {\ncolorP2 = colorB;\n}\nif (colorD == colorC && colorD != colorB && colorC != colorA) {\ncolorP3 = colorC;\n}\nif (colorB == colorD && colorB != colorA && colorD != colorC) {\ncolorP4 = colorD;\n}\nvec4 colorP12 = mix(colorP1, colorP2, texel_frac.x);\nvec4 colorP34 = mix(colorP1, colorP2, texel_frac.x);\nreturn mix(colorP12, colorP34, texel_frac.y);\n}"},heatmap:{heatmapResolve:{"heatmapResolve.frag":"precision highp float;\n#ifdef HEATMAP_PRECISION_HALF_FLOAT\n#define COMPRESSION_FACTOR 4.0\n#else\n#define COMPRESSION_FACTOR 1.0\n#endif\nuniform sampler2D u_texture;\nuniform sampler2D u_gradient;\nuniform vec2 u_densityMinAndInvRange;\nuniform float u_densityNormalization;\nvarying vec2 v_uv;\nvoid main() {\nvec4 data = texture2D(u_texture, v_uv);\nfloat density = data.r * COMPRESSION_FACTOR;\ndensity *= u_densityNormalization;\ndensity = (density - u_densityMinAndInvRange.x) * u_densityMinAndInvRange.y;\nvec4 color = texture2D(u_gradient, vec2(density, 0.5));\ngl_FragColor = vec4(color.rgb * color.a, color.a);\n}","heatmapResolve.vert":"precision highp float;\nattribute vec2 a_pos;\nvarying vec2 v_uv;\nvoid main() {\nv_uv = a_pos;\ngl_Position = vec4(a_pos * 2.0 - 1.0, 1., 1.);\n}"}},highlight:{"blur.frag":"varying mediump vec2 v_texcoord;\nuniform mediump vec4 u_direction;\nuniform mediump mat4 u_channelSelector;\nuniform mediump float u_sigma;\nuniform sampler2D u_texture;\nmediump float gauss1(mediump vec2 dir) {\nreturn exp(-dot(dir, dir) / (2.0 * u_sigma * u_sigma));\n}\nmediump vec4 selectChannel(mediump vec4 sample) {\nreturn u_channelSelector * sample;\n}\nvoid accumGauss1(mediump float i, inout mediump float tot, inout mediump float weight) {\nmediump float w = gauss1(i * u_direction.xy);\ntot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw))[3] * w;\nweight += w;\n}\nvoid main(void) {\nmediump float tot = 0.0;\nmediump float weight = 0.0;\naccumGauss1(-5.0, tot, weight);\naccumGauss1(-4.0, tot, weight);\naccumGauss1(-3.0, tot, weight);\naccumGauss1(-2.0, tot, weight);\naccumGauss1(-1.0, tot, weight);\naccumGauss1(0.0, tot, weight);\naccumGauss1(1.0, tot, weight);\naccumGauss1(2.0, tot, weight);\naccumGauss1(3.0, tot, weight);\naccumGauss1(4.0, tot, weight);\naccumGauss1(5.0, tot, weight);\ngl_FragColor = vec4(0.0, 0.0, 0.0, tot / weight);\n}","highlight.frag":"varying mediump vec2 v_texcoord;\nuniform sampler2D u_texture;\nuniform mediump float u_sigma;\nuniform sampler2D u_shade;\nuniform mediump vec2 u_minMaxDistance;\nmediump float estimateDistance() {\nmediump float y = texture2D(u_texture, v_texcoord)[3];\nconst mediump float y0 = 0.5;\nmediump float m0 = 1.0 / (sqrt(2.0 * 3.1415) * u_sigma);\nmediump float d = (y - y0) / m0;\nreturn d;\n}\nmediump vec4 shade(mediump float d) {\nmediump float mappedDistance = (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\nmappedDistance = clamp(mappedDistance, 0.0, 1.0);\nreturn texture2D(u_shade, vec2(mappedDistance, 0.5));\n}\nvoid main(void) {\nmediump float d = estimateDistance();\ngl_FragColor = shade(d);\n}","textured.vert":"attribute mediump vec2 a_position;\nattribute mediump vec2 a_texcoord;\nvarying mediump vec2 v_texcoord;\nvoid main(void) {\ngl_Position = vec4(a_position, 0.0, 1.0);\nv_texcoord = a_texcoord;\n}"},materials:{"attributeData.glsl":"uniform highp sampler2D filterFlags;\nuniform highp sampler2D animation;\nuniform highp sampler2D gpgpu;\nuniform highp sampler2D visualVariableData;\nuniform highp sampler2D dataDriven0;\nuniform highp sampler2D dataDriven1;\nuniform highp sampler2D dataDriven2;\nuniform float size;\nhighp vec2 getAttributeDataCoords(in highp vec3 id) {\nhighp vec3  texel = unpackDisplayIdTexel(id);\nhighp float u32 = float(int(texel.r) + int(texel.g) * 256 + int(texel.b) * 256 * 256);\nhighp float col = mod(u32, size);\nhighp float row = (u32 - col) / size;\nhighp float u = col / size;\nhighp float v = row / size;\nreturn vec2(u, v);\n}\nhighp vec2 getAttributeDataTextureCoords(in highp vec3 id) {\nreturn (getAttributeDataCoords(id) * 2.0) - 1.0 + (.5 / vec2(size));\n}\nhighp vec4 getFilterData(in highp vec3 id) {\nvec2 coords = getAttributeDataCoords(id);\nreturn texture2D(filterFlags, coords);\n}\nhighp vec4 getAnimation(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(animation, coords);\n}\nhighp vec4 getVisualVariableData(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(visualVariableData, coords);\n}\nhighp vec4 getDataDriven0(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(dataDriven0, coords);\n}\nhighp vec4 getDataDriven1(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(dataDriven1, coords);\n}\nhighp vec4 getGPGPU(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(gpgpu, coords);\n}\nhighp vec4 getDataDriven2(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(dataDriven2, coords);\n}\nfloat u88VVToFloat(in vec2 v) {\nbool isMagic = v.x == 255.0 && v.y == 255.0;\nif (isMagic) {\nreturn NAN_MAGIC_NUMBER;\n}\nreturn (v.x + v.y * float(0x100)) - 32768.0;\n}","barycentric.glsl":"float inTriangle(vec3 bary) {\nvec3 absBary = abs(bary);\nreturn step((absBary.x + absBary.y + absBary.z), 1.05);\n}\nvec3 xyToBarycentric(in vec2 pos, in vec2 v0,  in vec2 v1, in vec2 v2) {\nmat3 xyToBarycentricMat3 = mat3(\nv1.x * v2.y - v2.x * v1.y, v2.x * v0.y - v0.x * v2.y, v0.x * v1.y - v1.x * v0.y,\nv1.y - v2.y, v2.y - v0.y, v0.y - v1.y,\nv2.x - v1.x, v0.x - v2.x, v1.x - v0.x\n);\nfloat A2 = v0.x * (v1.y - v2.y) + v1.x * (v2.y - v0.y) + v2.x * (v0.y - v1.y);\nreturn (1. / A2) * xyToBarycentricMat3 * vec3(1., pos);\n}","constants.glsl":"const float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_RAD_TO_DEG = 180.0 / 3.141592654;\nconst float POSITION_PRECISION = 1.0 / 8.0;\nconst float FILL_POSITION_PRECISION = 1.0 / 1.0;\nconst float SOFT_EDGE_RATIO = 1.0;\nconst float THIN_LINE_WIDTH_FACTOR = 1.1;\nconst float THIN_LINE_HALF_WIDTH = 1.0;\nconst float EXTRUDE_SCALE_PLACEMENT_PADDING = 1.0 / 4.0;\nconst float OFFSET_PRECISION = 1.0 / 8.0;\nconst float OUTLINE_SCALE = 1.0 / 5.0;\nconst float SDF_FONT_SIZE = 24.0;\nconst float MAX_SDF_DISTANCE = 8.0;\nconst float PLACEMENT_PADDING = 8.0;\nconst float EPSILON = 0.00001;\nconst float EPSILON_HITTEST = 0.05;\nconst int MAX_FILTER_COUNT = 2;\nconst int ATTR_VV_SIZE = 0;\nconst int ATTR_VV_COLOR = 1;\nconst int ATTR_VV_OPACITY = 2;\nconst int ATTR_VV_ROTATION = 3;\nconst highp float NAN_MAGIC_NUMBER = 1e-30;\nconst int BITSET_GENERIC_LOCK_COLOR = 1;\nconst int BITSET_GENERIC_CONSIDER_ALPHA_ONLY = 4;\nconst int BITSET_MARKER_ALIGNMENT_MAP = 0;\nconst int BITSET_MARKER_OUTLINE_ALLOW_COLOR_OVERRIDE = 2;\nconst int BITSET_MARKER_SCALE_SYMBOLS_PROPORTIONALLY = 3;\nconst int BITSET_TYPE_FILL_OUTLINE = 0;\nconst int BITSET_FILL_RANDOM_PATTERN_OFFSET = 2;\nconst int BITSET_FILL_HAS_UNRESOLVED_REPLACEMENT_COLOR = 3;\nconst int BITSET_FILL_HAS_PATTERN_HEIGHT_PRECISION_FACTOR = 5;\nconst int BITSET_FILL_HAS_PATTERN_WIDTH_PRECISION_FACTOR = 6;\nconst int BITSET_LINE_SCALE_DASH = 2;",fill:{"common.glsl":"#include <materials/symbologyTypeUtils.glsl>\n#ifdef PATTERN\nuniform mediump vec2 u_mosaicSize;\nvarying mediump float v_sampleAlphaOnly;\n#endif\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nuniform lowp vec4 u_isActive[ 2 ];\nuniform highp float u_dotValue;\nuniform highp float u_tileDotsOverArea;\nuniform highp float u_dotTextureDotCount;\nuniform mediump float u_tileZoomFactor;\n#endif\nvarying highp vec3 v_id;\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\nvarying mediump vec4 v_aux1;\n#ifdef PATTERN\nvarying mediump vec2 v_tileTextureCoord;\n#endif\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\nvarying lowp float v_isOutline;\n#endif\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nvarying highp vec2 v_dotTextureCoords;\nvarying highp vec4 v_dotThresholds[ 2 ];\n#endif","fill.frag":"precision highp float;\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/fill/common.glsl>\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\n#endif\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nuniform mediump mat4 u_dotColors[ 2 ];\nuniform sampler2D u_dotTextures[ 2 ];\nuniform vec4 u_dotBackgroundColor;\n#endif\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#include <materials/shared/line/common.glsl>\n#include <materials/shared/line/line.frag>\nlowp vec4 drawLine() {\nfloat v_lineWidth = v_aux1.x;\nvec2  v_normal    = v_aux1.yz;\nLineData inputs = LineData(\nv_color,\nv_normal,\nv_lineWidth,\nv_opacity,\nv_id\n);\nreturn shadeLine(inputs);\n}\n#endif\nlowp vec4 drawFill() {\nlowp vec4 out_color = vec4(0.);\n#ifdef HITTEST\nout_color = v_color;\n#elif defined(PATTERN)\nmediump vec4 v_tlbr = v_aux1;\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\nif (v_sampleAlphaOnly > 0.5) {\ncolor.rgb = vec3(color.a);\n}\nout_color = v_opacity * v_color * color;\n#elif SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY && !defined(HIGHLIGHT)\nvec4 textureThresholds0 = texture2D(u_dotTextures[0], v_dotTextureCoords);\nvec4 textureThresholds1 = texture2D(u_dotTextures[1], v_dotTextureCoords);\nvec4 difference0 = v_dotThresholds[0] - textureThresholds0;\nvec4 difference1 = v_dotThresholds[1] - textureThresholds1;\n#ifdef DD_DOT_BLENDING\nvec4 isPositive0 = step(0.0, difference0);\nvec4 isPositive1 = step(0.0, difference1);\nfloat weightSum = dot(isPositive0, difference0) + dot(isPositive1, difference1);\nfloat lessThanEqZero = step(weightSum, 0.0);\nfloat greaterThanZero = 1.0 - lessThanEqZero ;\nfloat divisor = (weightSum + lessThanEqZero);\nvec4 weights0 = difference0 * isPositive0 / divisor;\nvec4 weights1 = difference1 * isPositive1 / divisor;\nvec4 dotColor = u_dotColors[0] * weights0 + u_dotColors[1] * weights1;\nvec4 preEffectColor = greaterThanZero * dotColor + lessThanEqZero * u_dotBackgroundColor;\n#else\nfloat diffMax = max(max4(difference0), max4(difference1));\nfloat lessThanZero = step(diffMax, 0.0);\nfloat greaterOrEqZero = 1.0 - lessThanZero;\nvec4 isMax0 = step(diffMax, difference0);\nvec4 isMax1 = step(diffMax, difference1);\nvec4 dotColor = u_dotColors[0] * isMax0 + u_dotColors[1] * isMax1;\nvec4 preEffectColor = greaterOrEqZero * dotColor + lessThanZero * u_dotBackgroundColor;\n#endif\nout_color = preEffectColor;\n#else\nout_color = v_opacity * v_color;\n#endif\n#ifdef HIGHLIGHT\nout_color.a = 1.0;\n#endif\nreturn out_color;\n}\nvoid main() {\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\nif (v_isOutline > 0.5) {\ngl_FragColor = drawLine();\n} else {\ngl_FragColor = drawFill();\n}\n#else\ngl_FragColor = drawFill();\n#endif\n}","fill.vert":"#include <materials/symbologyTypeUtils.glsl>\n#define PACKED_LINE\nprecision highp float;\nattribute float a_bitset;\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nattribute float a_inverseArea;\nvec4 a_color = vec4(0.0, 0.0, 0.0, 1.0);\nvec2 a_zoomRange = vec2(0.0, 10000.0);\n#else\nattribute vec4 a_color;\nattribute vec4 a_aux2;\nattribute vec4 a_aux3;\n#ifndef SYMBOLOGY_TYPE_IS_SIMPLE_LIKE\nattribute vec4 a_aux1;\nattribute vec2 a_zoomRange;\n#else\nvec2 a_zoomRange = vec2(0.0, 10000.0);\n#endif\n#endif\nuniform vec2 u_tileOffset;\nuniform vec2 u_maxIntNumOfCrossing;\n#include <util/encoding.glsl>\n#include <materials/vcommon.glsl>\n#include <materials/fill/common.glsl>\n#include <materials/fill/hittest.glsl>\nconst float INV_SCALE_COMPRESSION_FACTOR = 1.0 / 128.0;\nconst float MAX_REPRESENTABLE_INT = 16777216.0;\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nvec4 dotThreshold(vec4 featureAttrOverFeatureArea, float dotValue, float tileDotsOverArea) {\nreturn featureAttrOverFeatureArea * (1.0 / dotValue)  * (1.0 / tileDotsOverArea);\n}\n#endif\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#include <materials/shared/line/common.glsl>\n#include <materials/shared/line/line.vert>\nvoid drawLine(out lowp vec4 out_color, out highp vec3 out_pos) {\nLineData outputs = buildLine(\nout_pos,\na_id,\na_pos,\na_color,\n(a_aux3.xy - 128.) / 16.,\n(a_aux3.zw - 128.) / 16.,\n0.,\na_aux2.z / 16.,\na_bitset,\nvec4(0.),\nvec2(0.),\na_aux2.w / 16.\n);\nv_id      = outputs.id;\nv_opacity = outputs.opacity;\nv_aux1    = vec4(outputs.lineHalfWidth, outputs.normal, 0.);\nout_color = outputs.color;\n}\n#endif\nvoid drawFill(out lowp vec4 out_color, out highp vec3 out_pos) {\nfloat a_bitSet = a_bitset;\nout_color = getColor(a_color, a_bitSet, BITSET_GENERIC_LOCK_COLOR);\nv_opacity = getOpacity();\nv_id      = norm(a_id);\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nmat3 tileToTileNormalized = mat3(  2. / 512.,  0.,  0.,\n0., -2. / 512.,  0.,\n-1.,  1.,  1.  );\nout_pos   = tileToTileNormalized * vec3((a_pos * FILL_POSITION_PRECISION), 1.);\n#else\nout_pos   = u_dvsMat3 * vec3(a_pos * FILL_POSITION_PRECISION, 1.);\n#endif\n#ifdef PATTERN\nvec4  a_tlbr   = a_aux1;\nfloat a_width  = a_aux2.x;\nfloat a_height = a_aux2.y;\nvec2  a_offset = a_aux2.zw;\nvec2  a_scale  = a_aux3.xy;\nfloat a_angle  = a_aux3.z;\nif (getBit(a_bitset, BITSET_FILL_HAS_PATTERN_WIDTH_PRECISION_FACTOR) > 0.5) {\na_width *= INV_SCALE_COMPRESSION_FACTOR;\n}\nif (getBit(a_bitset, BITSET_FILL_HAS_PATTERN_HEIGHT_PRECISION_FACTOR) > 0.5) {\na_height *= INV_SCALE_COMPRESSION_FACTOR;\n}\nvec2 scale = INV_SCALE_COMPRESSION_FACTOR * a_scale;\nfloat width = u_zoomFactor * a_width * scale.x;\nfloat height = u_zoomFactor * a_height * scale.y;\nfloat angle = C_256_TO_RAD * a_angle;\nfloat sinA = sin(angle);\nfloat cosA = cos(angle);\nfloat dx = 0.0;\nfloat dy = 0.0;\nif (getBit(a_bitset, BITSET_FILL_RANDOM_PATTERN_OFFSET) > 0.5) {\nfloat id = rgba2float(vec4(a_id, 0.0));\ndx = rand(vec2(id, 0.0));\ndy = rand(vec2(0.0, id));\n}\nmat3 patternMatrix = mat3(cosA / width, sinA / height, 0,\n-sinA / width, cosA / height, 0,\ndx,            dy,           1);\nvec2 patternSize = vec2(a_width, a_height);\nvec2 numPatternsPerMaxInt = vec2(MAX_REPRESENTABLE_INT) / patternSize;\nvec2 maxIntCrossingOffsetCorrection = patternSize * fract(u_maxIntNumOfCrossing * numPatternsPerMaxInt);\nvec2 tileOffset = u_tileOffset + maxIntCrossingOffsetCorrection - 0.5 * patternSize;\ntileOffset = vec2(tileOffset.x * cosA - tileOffset.y * sinA, tileOffset.x * sinA + tileOffset.y * cosA);\ntileOffset = mod(tileOffset, patternSize);\nvec2 symbolOffset = u_zoomFactor * scale * vec2(a_offset - tileOffset) / vec2(width, height);\nv_tileTextureCoord = (patternMatrix * vec3(a_pos * FILL_POSITION_PRECISION, 1.0)).xy - symbolOffset;\nv_aux1 = a_tlbr / u_mosaicSize.xyxy;\nv_sampleAlphaOnly = getBit(a_bitset, BITSET_GENERIC_CONSIDER_ALPHA_ONLY);\nif (getBit(a_bitSet, BITSET_FILL_HAS_UNRESOLVED_REPLACEMENT_COLOR) > 0.5) {\n#ifdef VV_COLOR\nv_sampleAlphaOnly *= (1.0 - float(isNan(VV_ADATA[ATTR_VV_COLOR]))) * (1.0 - getBit(a_bitSet, BITSET_GENERIC_LOCK_COLOR));\n#else\nv_sampleAlphaOnly = 0.0;\n#endif\n}\n#elif SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nvec4 ddAttributeData0 = getAttributeData2(a_id) * u_isActive[0] * a_inverseArea;\nvec4 ddAttributeData1 = getAttributeData3(a_id) * u_isActive[1] * a_inverseArea;\nfloat size = u_tileZoomFactor * 512.0 * 1.0 / u_pixelRatio;\nv_dotThresholds[0] = dotThreshold(ddAttributeData0, u_dotValue, u_tileDotsOverArea);\nv_dotThresholds[1] = dotThreshold(ddAttributeData1, u_dotValue, u_tileDotsOverArea);\nv_dotTextureCoords = (a_pos * FILL_POSITION_PRECISION + 0.5) / size;\n#endif\n}\n#ifdef HITTEST\nvoid draw(out lowp vec4 out_color, out highp vec3 out_pos) {\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\nif (getBit(a_bitset, BITSET_TYPE_FILL_OUTLINE) > 0.5) {\nout_pos = vec3(0., 0., 2.);\nreturn;\n}\n#endif\nhittestFill(out_color, out_pos);\ngl_PointSize = 1.0;\n}\n#elif defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE)\nvoid draw(out lowp vec4 out_color, out highp vec3 out_pos) {\nv_isOutline = getBit(a_bitset, BITSET_TYPE_FILL_OUTLINE);\nif (v_isOutline > 0.5) {\ndrawLine(out_color, out_pos);\n} else {\ndrawFill(out_color, out_pos);\n}\n}\n#else\n#define draw drawFill\n#endif\nvoid main()\n{\nINIT;\nhighp vec3 pos  = vec3(0.);\nhighp vec4 color  = vec4(0.);\ndraw(color, pos);\nv_color = color;\ngl_Position = vec4(clip(v_color, pos, getFilterFlags(), a_zoomRange), 1.0);\n}","hittest.glsl":"#ifdef HITTEST\n#include <materials/hittest/common.glsl>\nattribute vec2 a_pos1;\nattribute vec2 a_pos2;\nvoid hittestFill(\nout lowp vec4 out_color,\nout highp vec3 out_pos\n) {\nvec3 pos        = u_viewMat3 * u_tileMat3 * vec3(a_pos  * FILL_POSITION_PRECISION, 1.);\nvec3 pos1       = u_viewMat3 * u_tileMat3 * vec3(a_pos1 * FILL_POSITION_PRECISION, 1.);\nvec3 pos2       = u_viewMat3 * u_tileMat3 * vec3(a_pos2 * FILL_POSITION_PRECISION, 1.);\nfloat hittestDist = u_hittestDist;\nfloat dist = distPointTriangle(u_hittestPos, pos.xy, pos1.xy, pos2.xy);\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\nif (dist < 0. || dist >= hittestDist) {\nout_pos.z += 2.0;\n}\nout_color = vec4(1. / 255., 0, 0, dist == 0. ? (1. / 255.) : 0.);\n}\n#endif"},hittest:{"common.glsl":"#ifdef HITTEST\nuniform float hittestDist;\nuniform highp vec2 hittestPos;\nfloat projectScalar(vec2 a, vec2 b) {\nreturn dot(a, normalize(b));\n}\nfloat distPointSegment(vec2 p0, vec2 p1, vec2 p2) {\nvec2 L = p2 - p1;\nvec2 A = p0 - p1;\nfloat projAL = projectScalar(A, L);\nfloat t = clamp(projAL / length(L), 0., 1.);\nreturn distance(p0, p1 + t * (p2 - p1));\n}\nvoid hittestMarker(out lowp vec4 out_color, out highp vec3 out_pos, in highp vec3 pos, float size) {\nfloat dist = distance(pos, vec3(hittestPos, 1.));\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\nif ((dist - size) > hittestDist) {\nout_pos.z += 2.0;\n}\nout_color = vec4(1. / 255., 0, 0, (dist - size) < 0. ? (1. / 255.) : 0.);\n}\nfloat intersectPointTriangleBary(vec2 p, vec2 a, vec2 b, vec2 c) {\nreturn inTriangle(xyToBarycentric(p, a, b, c));\n}\nfloat distPointTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {\nvec2 ba = b - a;\nvec2 ca = c - a;\nfloat crossProduct = ba.x * ca.y - ca.x * ba.y;\nbool isParallel = crossProduct < EPSILON_HITTEST && crossProduct > -EPSILON_HITTEST;\nif (isParallel) {\nreturn -1.;\n}\nif (intersectPointTriangleBary(p.xy, a, b, c) == 1.) {\nreturn 0.;\n}\nfloat distAB = distPointSegment(p, a, b);\nfloat distBC = distPointSegment(p, b, c);\nfloat distCA = distPointSegment(p, c, a);\nreturn min(min(distAB, distBC), distCA);\n}\n#endif"},icon:{"common.glsl":"#include <util/encoding.glsl>\nuniform lowp vec2 u_mosaicSize;\nvarying lowp vec4 v_color;\nvarying highp vec3 v_id;\nvarying highp vec4 v_sizeTex;\nvarying mediump vec3 v_pos;\nvarying lowp float v_opacity;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\nvarying mediump float v_distRatio;\nvarying mediump float v_overridingOutlineColor;\nvarying mediump float v_isThin;\n#endif\n#ifdef SDF\nvec4 getColor(vec2 v_size, vec2 v_tex) {\n#ifdef HITTEST\nlowp vec4 fillPixelColor = vec4(1.0);\n#else\nlowp vec4 fillPixelColor = v_color;\n#endif\nfloat d = 0.5 - rgba2float(texture2D(u_texture, v_tex));\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * size * SOFT_EDGE_RATIO * v_distRatio;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nfloat outlineWidth = v_outlineWidth;\n#ifdef HIGHLIGHT\noutlineWidth = max(outlineWidth, 4.0 * v_isThin);\n#endif\nif (outlineWidth > 0.25) {\nlowp vec4 outlinePixelColor = v_overridingOutlineColor * v_color + (1.0 - v_overridingOutlineColor) * v_outlineColor;\nfloat clampedOutlineSize = min(outlineWidth, size);\noutlinePixelColor *= clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\nreturn v_opacity * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\n}\nreturn v_opacity * fillPixelColor;\n}\n#else\nvec4 getColor(vec2 _v_size, vec2 v_tex) {\nlowp vec4 texColor = texture2D(u_texture, v_tex);\nreturn v_opacity * texColor * v_color;\n}\n#endif",heatmapAccumulate:{"common.glsl":"varying lowp vec4 v_hittestResult;\nvarying mediump vec2 v_offsetFromCenter;\nvarying highp float v_fieldValue;","heatmapAccumulate.frag":"precision mediump float;\n#include <materials/icon/heatmapAccumulate/common.glsl>\n#ifdef HEATMAP_PRECISION_HALF_FLOAT\n#define COMPRESSION_FACTOR 0.25\n#else\n#define COMPRESSION_FACTOR 1.0\n#endif\nuniform lowp sampler2D u_texture;\nvoid main() {\n#ifdef HITTEST\ngl_FragColor = v_hittestResult;\n#else\nfloat radius = length(v_offsetFromCenter);\nfloat shapeWeight = step(radius, 1.0);\nfloat oneMinusRadiusSquared = 1.0 - radius * radius;\nfloat kernelWeight = oneMinusRadiusSquared * oneMinusRadiusSquared;\ngl_FragColor = vec4(shapeWeight * kernelWeight * v_fieldValue * COMPRESSION_FACTOR);\n#endif\n}","heatmapAccumulate.vert":"precision highp float;\nattribute vec2 a_vertexOffset;\nvec4 a_color = vec4(0.0);\nvec2 a_zoomRange = vec2(0.0, 10000.0);\nuniform float u_radius;\nuniform float u_isFieldActive;\n#include <materials/vcommon.glsl>\n#include <materials/hittest/common.glsl>\n#include <materials/icon/heatmapAccumulate/common.glsl>\nvoid main() {\nfloat filterFlags = getFilterFlags();\n#ifdef HITTEST\nhighp vec4 out_hittestResult = vec4(0.);\nhighp vec3 out_pos = vec3(0.);\nvec3 pos = u_viewMat3 * u_tileMat3 * vec3(a_pos * POSITION_PRECISION, 1.0);\nhittestMarker(out_hittestResult, out_pos, pos, u_radius);\nv_hittestResult = out_hittestResult;\ngl_PointSize = 1.;\ngl_Position = vec4(clip(a_color, out_pos, filterFlags, a_zoomRange), 1.0);\n#else\nv_offsetFromCenter = sign(a_vertexOffset);\nv_fieldValue = getAttributeData2(a_id).x * u_isFieldActive + 1.0 - u_isFieldActive;\nvec3 centerPos = u_dvsMat3 * vec3(a_pos * POSITION_PRECISION, 1.0);\nvec3 vertexPos = centerPos + u_displayViewMat3 * vec3(v_offsetFromCenter, 0.0) * u_radius;\ngl_Position = vec4(clip(a_color, vertexPos, filterFlags, a_zoomRange), 1.0);\n#endif\n}"},"hittest.glsl":"#ifdef HITTEST\n#include <materials/hittest/common.glsl>\nattribute vec2 a_vertexOffset1;\nattribute vec2 a_vertexOffset2;\nattribute vec2 a_texCoords1;\nattribute vec2 a_texCoords2;\nvec2 getTextureCoords(in vec3 bary, in vec2 texCoords0, in vec2 texCoords1, in vec2 texCoords2) {\nreturn texCoords0 * bary.x + texCoords1 * bary.y + texCoords2 * bary.z;\n}\nvoid hittestIcon(\ninout lowp vec4 out_color,\nout highp vec3 out_pos,\nin vec3 pos,\nin vec3 offset,\nin vec2 size,\nin float scaleFactor,\nin float isMapAligned\n) {\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\nvec3 posBase = u_viewMat3 * u_tileMat3  * pos;\nvec3 offset1 = scaleFactor * vec3(a_vertexOffset1 / 16.0, 0.);\nvec3 offset2 = scaleFactor * vec3(a_vertexOffset2 / 16.0, 0.);\nvec2 pos0    = (posBase + getMatrixNoDisplay(isMapAligned) * offset).xy;\nvec2 pos1    = (posBase + getMatrixNoDisplay(isMapAligned) * offset1).xy;\nvec2 pos2    = (posBase + getMatrixNoDisplay(isMapAligned) * offset2).xy;\nvec3 bary0 = xyToBarycentric(u_hittestPos + vec2(-u_hittestDist, -u_hittestDist), pos0, pos1, pos2);\nvec3 bary1 = xyToBarycentric(u_hittestPos + vec2(0., -u_hittestDist), pos0, pos1, pos2);\nvec3 bary2 = xyToBarycentric(u_hittestPos + vec2(u_hittestDist, -u_hittestDist), pos0, pos1, pos2);\nvec3 bary3 = xyToBarycentric(u_hittestPos + vec2(-u_hittestDist, 0.), pos0, pos1, pos2);\nvec3 bary4 = xyToBarycentric(u_hittestPos, pos0, pos1, pos2);\nvec3 bary5 = xyToBarycentric(u_hittestPos + vec2(u_hittestDist, 0.), pos0, pos1, pos2);\nvec3 bary6 = xyToBarycentric(u_hittestPos + vec2(-u_hittestDist, u_hittestDist), pos0, pos1, pos2);\nvec3 bary7 = xyToBarycentric(u_hittestPos + vec2(0., u_hittestDist), pos0, pos1, pos2);\nvec3 bary8 = xyToBarycentric(u_hittestPos + vec2(u_hittestDist, u_hittestDist), pos0, pos1, pos2);\nvec2 tex0 = a_texCoords  / u_mosaicSize;\nvec2 tex1 = a_texCoords1 / u_mosaicSize;\nvec2 tex2 = a_texCoords2 / u_mosaicSize;\nfloat alphaSum = 0.;\nalphaSum += inTriangle(bary0) * getColor(size, getTextureCoords(bary0, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary1) * getColor(size, getTextureCoords(bary1, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary2) * getColor(size, getTextureCoords(bary2, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary3) * getColor(size, getTextureCoords(bary3, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary4) * getColor(size, getTextureCoords(bary4, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary5) * getColor(size, getTextureCoords(bary5, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary6) * getColor(size, getTextureCoords(bary6, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary7) * getColor(size, getTextureCoords(bary7, tex0, tex1, tex2)).a;\nout_pos.z += step(alphaSum, .05) * 2.0;\nout_color = vec4(1. / 255., 0., 0., alphaSum / 255.);\n}\n#endif","icon.frag":"precision mediump float;\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/icon/common.glsl>\nvoid main()\n{\n#ifdef HITTEST\nvec4 color = v_color;\n#else\nvec4 color = getColor(v_sizeTex.xy, v_sizeTex.zw);\n#endif\n#ifdef HIGHLIGHT\ncolor.a = step(1.0 / 255.0, color.a);\n#endif\ngl_FragColor = color;\n}","icon.vert":"precision highp float;\nattribute vec4 a_color;\nattribute vec4 a_outlineColor;\nattribute vec4 a_sizeAndOutlineWidth;\nattribute vec2 a_vertexOffset;\nattribute vec2 a_texCoords;\nattribute vec2 a_bitSetAndDistRatio;\nattribute vec2 a_zoomRange;\n#include <materials/vcommon.glsl>\n#include <materials/icon/common.glsl>\n#include <materials/icon/hittest.glsl>\nfloat getMarkerScaleFactor(inout vec2 size, in float referenceSize) {\n#ifdef VV_SIZE\nfloat f = getSize(size.y) / size.y;\nfloat sizeFactor = size.y / referenceSize;\nreturn getSize(referenceSize) / referenceSize;\n#else\nreturn 1.;\n#endif\n}\nvoid main()\n{\nINIT;\nfloat a_bitSet = a_bitSetAndDistRatio.x;\nvec3  pos           = vec3(a_pos * POSITION_PRECISION, 1.0);\nvec2  size          = a_sizeAndOutlineWidth.xy * a_sizeAndOutlineWidth.xy / 128.0;\nvec3  offset        = vec3(a_vertexOffset / 16.0, 0.);\nfloat outlineSize   = a_sizeAndOutlineWidth.z * a_sizeAndOutlineWidth.z / 128.0;\nfloat isMapAligned  = getBit(a_bitSet, BITSET_MARKER_ALIGNMENT_MAP);\nfloat referenceSize = a_sizeAndOutlineWidth.w * a_sizeAndOutlineWidth.w / 128.0;\nfloat scaleSymbolProportionally = getBit(a_bitSet, BITSET_MARKER_SCALE_SYMBOLS_PROPORTIONALLY);\nfloat scaleFactor               = getMarkerScaleFactor(size, referenceSize);\nsize.xy     *= scaleFactor;\noffset.xy   *= scaleFactor;\noutlineSize *= scaleSymbolProportionally * (scaleFactor - 1.0) + 1.0;\nvec2 v_tex   = a_texCoords / u_mosaicSize;\nfloat filterFlags = getFilterFlags();\nv_color    = getColor(a_color, a_bitSet, BITSET_GENERIC_LOCK_COLOR);\nv_opacity  = getOpacity();\nv_id       = norm(a_id);\nv_pos      = u_dvsMat3 * pos + getMatrix(isMapAligned) * getRotation()  * offset;\nv_sizeTex  = vec4(size.xy, v_tex.xy);\n#ifdef SDF\nv_isThin   = getBit(a_bitSet, BITSET_MARKER_OUTLINE_ALLOW_COLOR_OVERRIDE);\n#ifdef VV_COLOR\nv_overridingOutlineColor = v_isThin;\n#else\nv_overridingOutlineColor = 0.0;\n#endif\nv_outlineWidth = min(outlineSize, max(max(size.x, size.y) - 0.99, 0.0));\nv_outlineColor = a_outlineColor;\nv_distRatio = a_bitSetAndDistRatio.y / 128.0;\n#endif\n#ifdef HITTEST\nhighp vec4 out_color = vec4(0.);\nhighp vec3 out_pos   = vec3(0.);\nhittestIcon(out_color, out_pos, pos, offset, size, scaleFactor, isMapAligned);\nv_color = out_color;\ngl_PointSize = 1.;\ngl_Position = vec4(clip(v_color, out_pos, filterFlags, a_zoomRange), 1.0);\n#else\ngl_Position = vec4(clip(v_color, v_pos, filterFlags, a_zoomRange), 1.0);\n#endif\n}"},label:{"common.glsl":"uniform mediump float u_zoomLevel;\nuniform mediump float u_mapRotation;\nuniform mediump float u_mapAligned;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\nvarying mediump vec4 v_color;\nvarying lowp vec4 v_animation;","label.frag":"#include <materials/text/text.frag>","label.vert":"precision highp float;\n#include <materials/vcommon.glsl>\n#include <materials/text/common.glsl>\nattribute vec4 a_color;\nattribute vec4 a_haloColor;\nattribute vec4 a_texAndSize;\nattribute vec4 a_refSymbolAndPlacementOffset;\nattribute vec4 a_glyphData;\nattribute vec2 a_vertexOffset;\nattribute vec2 a_texCoords;\nuniform float u_isHaloPass;\nuniform float u_isBackgroundPass;\nuniform float u_mapRotation;\nuniform float u_mapAligned;\nfloat getZ(in float minZoom, in float maxZoom, in float angle) {\nfloat glyphAngle = angle * 360.0 / 254.0;\nfloat mapAngle = u_mapRotation * 360.0 / 254.0;\nfloat diffAngle = min(360.0 - abs(mapAngle - glyphAngle), abs(mapAngle - glyphAngle));\nfloat z = 0.0;\nz += u_mapAligned * (2.0 * (1.0 - step(minZoom, u_currentZoom)));\nz += u_mapAligned * 2.0 * step(90.0, diffAngle);\nz += 2.0 * (1.0 - step(u_currentZoom, maxZoom));\nreturn z;\n}\nvoid main()\n{\nINIT;\nfloat groupMinZoom    = getMinZoom();\nfloat glyphMinZoom    = a_glyphData.x;\nfloat glyphMaxZoom    = a_glyphData.y;\nfloat glyphAngle      = a_glyphData.z;\nfloat a_isBackground  = a_glyphData.w;\nfloat a_minZoom          = max(groupMinZoom, glyphMinZoom);\nfloat a_placementPadding = a_refSymbolAndPlacementOffset.x * EXTRUDE_SCALE_PLACEMENT_PADDING;\nvec2  a_placementDir     = unpack_u8_nf32(a_refSymbolAndPlacementOffset.zw);\nfloat a_refSymbolSize    = a_refSymbolAndPlacementOffset.y;\nfloat fontSize           = a_texAndSize.z;\nfloat haloSize           = a_texAndSize.w * OUTLINE_SCALE;\nvec2  vertexOffset = a_vertexOffset * OFFSET_PRECISION;\nvec3  pos          = vec3(a_pos * POSITION_PRECISION, 1.0);\nfloat z            = getZ(a_minZoom, glyphMaxZoom, glyphAngle);\nfloat fontScale    = fontSize / SDF_FONT_SIZE;\nfloat halfSize     = getSize(a_refSymbolSize) / 2.0;\nfloat animation    = pow(getAnimationState(), vec4(2.0)).r;\nfloat isText = 1.0 - a_isBackground;\nfloat isBackground = u_isBackgroundPass * a_isBackground;\nvec4  nonHaloColor = (isBackground + isText) * a_color;\nv_color     = animation * ((1.0 - u_isHaloPass) * nonHaloColor + (u_isHaloPass * a_haloColor));\nv_opacity   = 1.0;\nv_tex       = a_texCoords / u_mosaicSize;\nv_edgeDistanceOffset = u_isHaloPass * haloSize / fontScale / MAX_SDF_DISTANCE;\nv_antialiasingWidth  = 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\nvec2 placementOffset = a_placementDir * (halfSize + a_placementPadding);\nvec3 glyphOffset     = u_displayMat3 * vec3(vertexOffset + placementOffset, 0.0);\nvec3 v_pos           = vec3((u_dvsMat3 * pos + glyphOffset).xy, z);\nfloat isHidden = u_isBackgroundPass * isText + (1.0 - u_isBackgroundPass) * a_isBackground;\nv_pos.z += 2.0 * isHidden;\ngl_Position = vec4(v_pos, 1.0);\n#ifdef DEBUG\nv_color = vec4(a_color.rgb, z == 0.0 ? 1.0 : 0.645);\n#endif\n}"},line:{"common.glsl":"varying lowp vec4 v_color;\nvarying highp vec3 v_id;\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp float v_opacity;\n#ifdef PATTERN\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\n#endif\n#if defined(PATTERN) || defined(SDF)\nvarying highp float v_accumulatedDistance;\n#endif\n#ifdef SDF\nvarying mediump float v_lineWidthRatio;\n#endif","hittest.glsl":"#include <materials/hittest/common.glsl>\n#ifdef HITTEST\nattribute vec2 a_pos1;\nattribute vec2 a_pos2;\nvoid hittestLine(out lowp vec4 out_color, out highp vec3 out_pos, float halfWidth) {\nvec3 pos        = u_viewMat3 * u_tileMat3 * vec3(a_pos  * POSITION_PRECISION, 1.);\nvec3 pos1       = u_viewMat3 * u_tileMat3 * vec3(a_pos1 * POSITION_PRECISION, 1.);\nvec3 pos2       = u_viewMat3 * u_tileMat3 * vec3(a_pos2 * POSITION_PRECISION, 1.);\nvec3 outTextureCoords = vec3(getAttributeDataTextureCoords(a_id), 0.0);\nfloat dist = min(distPointSegment(u_hittestPos, pos.xy, pos1.xy),\ndistPointSegment(u_hittestPos, pos.xy, pos2.xy)) - halfWidth;\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\nif (dist >= u_hittestDist) {\nout_pos.z += 2.0;\n}\nout_color = vec4(1. / 255., 0, 0, dist <= 0. ? (1. / 255.) : 0.);\n}\n#endif","line.frag":"precision lowp float;\n#include <util/encoding.glsl>\n#include <materials/constants.glsl>\n#include <materials/symbologyTypeUtils.glsl>\n#include <materials/line/common.glsl>\n#include <materials/shared/line/common.glsl>\n#include <materials/shared/line/line.frag>\n#ifdef HITTEST\nvoid main() {\ngl_FragColor = v_color;\n}\n#else\nvoid main() {\nLineData inputs = LineData(\nv_color,\nv_normal,\nv_lineHalfWidth,\nv_opacity,\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#ifdef PATTERN\nv_tlbr,\nv_patternSize,\n#endif\n#ifdef SDF\nv_lineWidthRatio,\n#endif\n#if defined(PATTERN) || defined(SDF)\nv_accumulatedDistance,\n#endif\n#endif\nv_id\n);\ngl_FragColor = shadeLine(inputs);\n}\n#endif","line.vert":"precision highp float;\nattribute vec4 a_color;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\nattribute vec4 a_tlbr;\nattribute vec4 a_segmentDirection;\nattribute vec2 a_aux;\nattribute vec2 a_zoomRange;\n#include <materials/vcommon.glsl>\n#include <materials/symbologyTypeUtils.glsl>\n#include <materials/line/common.glsl>\n#include <materials/line/hittest.glsl>\n#include <materials/shared/line/common.glsl>\n#include <materials/shared/line/line.vert>\n#ifdef HITTEST\nvoid draw() {\nfloat aa        = 0.5 * u_antialiasing;\nfloat a_halfWidth = a_accumulatedDistanceAndHalfWidth.y / 16.;\nfloat a_cimHalfWidth = a_aux.x / 16. ;\nvec2  a_offset = a_offsetAndNormal.xy / 16.;\nfloat baseWidth = getBaseLineHalfWidth(a_halfWidth, a_cimHalfWidth);\nfloat halfWidth = getLineHalfWidth(baseWidth, aa);\nhighp vec3 pos  = vec3(0.);\nv_color = vec4(0.);\nhittestLine(v_color, pos, halfWidth);\ngl_PointSize = 1.;\ngl_Position = vec4(clip(v_color, pos, getFilterFlags(), a_zoomRange), 1.0);\n}\n#else\nvoid draw()\n{\nhighp vec3 pos = vec3(0.);\nLineData outputs = buildLine(\npos,\na_id,\na_pos,\na_color,\na_offsetAndNormal.xy / 16.,\na_offsetAndNormal.zw / 16.,\na_accumulatedDistanceAndHalfWidth.x,\na_accumulatedDistanceAndHalfWidth.y / 16.,\na_segmentDirection.w,\na_tlbr,\na_segmentDirection.xy / 16.,\na_aux.x / 16.\n);\nv_id              = outputs.id;\nv_color           = outputs.color;\nv_normal          = outputs.normal;\nv_lineHalfWidth   = outputs.lineHalfWidth;\nv_opacity         = outputs.opacity;\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#ifdef PATTERN\nv_tlbr          = outputs.tlbr;\nv_patternSize   = outputs.patternSize;\n#endif\n#ifdef SDF\nv_lineWidthRatio = outputs.lineWidthRatio;\n#endif\n#if defined(PATTERN) || defined(SDF)\nv_accumulatedDistance = outputs.accumulatedDistance;\n#endif\n#endif\ngl_Position = vec4(clip(outputs.color, pos, getFilterFlags(), a_zoomRange), 1.0);\n}\n#endif\nvoid main() {\nINIT;\ndraw();\n}"},pie:{"pie.common.glsl":"uniform float outlineWidth;\nuniform mediump float sectorThreshold;\nvarying vec3  v_id;\nvarying vec3  v_pos;\nvarying vec2  v_offset;\nvarying vec4  v_color;\nvarying float v_size;\nvarying float v_numOfEntries;\nvarying float v_maxSectorAngle;\nvarying vec2  v_filteredSectorToColorId[numberOfFields];\nvarying vec2  v_texCoords;\nvarying float v_outlineWidth;\nvarying float v_opacity;\nstruct FilteredChartInfo {\nfloat endSectorAngle;\nint colorId;\n};","pie.frag":"precision highp float;\n#include <util/atan2.glsl>\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/pie/pie.common.glsl>\nuniform lowp vec4 colors[numberOfFields];\nuniform lowp vec4 defaultColor;\nuniform lowp vec4 othersColor;\nuniform lowp vec4 outlineColor;\nuniform float donutRatio;\nlowp vec4 getSectorColor(in int index, in vec2 filteredSectorToColorId[numberOfFields]) {\nmediump int colorIndex = int(filteredSectorToColorId[index].y);\nreturn colors[colorIndex];\n}\nconst int OTHER_SECTOR_ID = 255;\n#ifdef HITTEST\nvec4 getColor() {\nfloat distanceSize = length(v_offset) * v_size;\nfloat donutSize = donutRatio * v_size;\nfloat alpha = step(donutSize, distanceSize) * (1.0 - step(v_size, distanceSize));\nreturn v_color;\n}\n#else\nvec4 getColor() {\nfloat angle = 90.0 - C_RAD_TO_DEG * atan2(v_offset.y, v_offset.x);\nif (angle < 0.0) {\nangle += 360.0;\n} else if (angle > 360.0) {\nangle = mod(angle, 360.0);\n}\nint numOfEntries = int(v_numOfEntries);\nfloat maxSectorAngle = v_maxSectorAngle;\nlowp vec4 fillColor = (maxSectorAngle > 0.0 || sectorThreshold > 0.0) ? othersColor : defaultColor;\nlowp vec4 prevColor = vec4(0.0);\nlowp vec4 nextColor = vec4(0.0);\nfloat startSectorAngle = 0.0;\nfloat endSectorAngle = 0.0;\nif (angle < maxSectorAngle) {\nfor (int index = 0; index < numberOfFields; ++index) {\nstartSectorAngle = endSectorAngle;\nendSectorAngle = v_filteredSectorToColorId[index].x;\nif (endSectorAngle > angle) {\nfillColor = getSectorColor(index, v_filteredSectorToColorId);\nprevColor = sectorThreshold != 0.0 && index == 0 && abs(360.0 - maxSectorAngle) < EPSILON ? othersColor :\ngetSectorColor(index > 0 ? index - 1 : numOfEntries - 1, v_filteredSectorToColorId);\nnextColor = sectorThreshold != 0.0 && abs(endSectorAngle - maxSectorAngle) < EPSILON ? othersColor :\ngetSectorColor(index < numOfEntries - 1 ? index + 1 : 0, v_filteredSectorToColorId);\nbreak;\n}\nif (index == numOfEntries - 1) {\nbreak;\n}\n}\n} else {\nprevColor = getSectorColor(numOfEntries - 1, v_filteredSectorToColorId);\nnextColor = getSectorColor(0, v_filteredSectorToColorId);\nstartSectorAngle = maxSectorAngle;\nendSectorAngle = 360.0;\n}\nlowp vec4 outlineColor = outlineColor;\nfloat offset = length(v_offset);\nfloat distanceSize = offset * v_size;\nif (startSectorAngle != 0.0 || endSectorAngle != 360.0) {\nfloat distanceToStartSector = (angle - startSectorAngle);\nfloat distanceToEndSector = (endSectorAngle - angle);\nfloat sectorThreshold = 0.6;\nfloat beginSectorAlpha = smoothstep(0.0, sectorThreshold, distanceToStartSector * offset);\nfloat endSectorAlpha = smoothstep(0.0, sectorThreshold, distanceToEndSector * offset);\nif (endSectorAlpha > 0.0) {\nfillColor = mix(nextColor, fillColor, endSectorAlpha);\n} else if (beginSectorAlpha > 0.0) {\nfillColor = mix(prevColor, fillColor, beginSectorAlpha);\n}\n}\nfloat donutSize = donutRatio * (v_size - v_outlineWidth);\nfloat endOfDonut = donutSize - v_outlineWidth;\nfloat aaThreshold = 0.75;\nfloat innerCircleAlpha = endOfDonut - aaThreshold > 0.0 ? smoothstep(endOfDonut - aaThreshold, endOfDonut + aaThreshold, distanceSize) : 1.0;\nfloat outerCircleAlpha = 1.0 - smoothstep(v_size - aaThreshold, v_size + aaThreshold , distanceSize);\nfloat circleAlpha = innerCircleAlpha * outerCircleAlpha;\nfloat startOfOutline = v_size - v_outlineWidth;\nif (startOfOutline > 0.0 && v_outlineWidth > 0.25) {\nfloat outlineFactor = smoothstep(startOfOutline - aaThreshold, startOfOutline + aaThreshold, distanceSize);\nfloat innerLineFactor = donutSize - aaThreshold > 0.0 ? 1.0 - smoothstep(donutSize - aaThreshold, donutSize + aaThreshold , distanceSize) : 0.0;\nfillColor = mix(fillColor, outlineColor, innerLineFactor + outlineFactor);\n}\nreturn v_opacity * circleAlpha * fillColor;\n}\n#endif\nvoid main()\n{\nvec4 color = getColor();\n#ifdef highlight\ncolor.a = step(1.0 / 255.0, color.a);\n#endif\ngl_FragColor = color;\n}","pie.vert":"#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/barycentric.glsl>\n#include <materials/vcommon.glsl>\n#include <materials/vv.glsl>\n#include <materials/attributeData.glsl>\n#include <materials/pie/pie.common.glsl>\n#include <materials/hittest/common.glsl>\nattribute float a_bitSet;\nattribute vec2  a_offset;\nattribute vec2  a_texCoords;\nattribute vec2  a_size;\nattribute float a_referenceSize;\nattribute vec2  a_zoomRange;\nint filterValue(in float sectorAngle,\nin int currentIndex,\ninout FilteredChartInfo filteredInfo,\ninout vec2 filteredSectorToColorId[numberOfFields]) {\nif (sectorAngle > sectorThreshold * 360.0) {\nfilteredInfo.endSectorAngle += sectorAngle;\nfilteredSectorToColorId[filteredInfo.colorId] = vec2(filteredInfo.endSectorAngle, currentIndex);\n++filteredInfo.colorId;\n}\nreturn 0;\n}\nint filterValues(inout vec2 filteredSectorToColorId[numberOfFields],\ninout FilteredChartInfo filteredInfo,\nin float sectorAngles[numberOfFields]) {\nfor (int index = 0; index < numberOfFields; ++index) {\nfloat sectorValue = sectorAngles[index];\nfilterValue(sectorValue, index, filteredInfo, filteredSectorToColorId);\n}\nreturn filteredInfo.colorId;\n}\nvec2 getMarkerSize(inout vec2 offset, inout vec2 baseSize, inout float outlineSize, in float a_referenceSize, in float bitSet) {\nvec2 outSize = baseSize;\n#ifdef VV_SIZE\nfloat r = getSize(a_referenceSize, currentScale) / a_referenceSize;\noutSize.xy *= r;\noffset.xy *= r;\nfloat scaleSymbolProportionally = getBit(bitSet, BITSET_MARKER_SCALE_SYMBOLS_PROPORTIONALLY);\noutlineSize *= scaleSymbolProportionally * (r - 1.0) + 1.0;\n#endif\nreturn outSize;\n}\nvec3 getOffset(in vec2 in_offset, float a_bitSet) {\nfloat isMapAligned = getBit(a_bitSet, BITSET_MARKER_ALIGNMENT_MAP);\nvec3  offset       = vec3(in_offset, 0.0);\nreturn getMatrix(isMapAligned) * offset;\n}\nfloat filterNaNValues(in float value) {\nreturn value != NAN_MAGIC_NUMBER && value > 0.0 ? value : 0.0;\n}\nvoid main()\n{\nINIT;\nvec2  a_size   = a_size;\nvec2  a_offset = a_offset / 16.0;\nfloat outlineSize = outlineWidth;\nfloat a_bitSet = a_bitSet;\nfloat a_referenceSize = a_referenceSize;\nvec2 a_texCoords = a_texCoords / 4.0;\nvec2 markerSize = getMarkerSize(a_offset, a_size, outlineSize, a_referenceSize, a_bitSet);\nfloat filterFlags = getFilterFlags();\nvec3  pos         = vec3(a_pos / 10.0, 1.0);\nv_opacity      = getOpacity();\nv_id           = norm(a_id);\nv_pos          = displayViewScreenMat3 * pos + getOffset(a_offset, a_bitSet);\nv_offset       = sign(a_texCoords - 0.5);\nv_size         = max(markerSize.x, markerSize.y);\nv_outlineWidth = outlineSize;\nfloat attributeData[10];\nvec4 attributeData3 = getDataDriven0(a_id);\nattributeData[0] = filterNaNValues(attributeData3.x);\nattributeData[1] = filterNaNValues(attributeData3.y);\nattributeData[2] = filterNaNValues(attributeData3.z);\nattributeData[3] = filterNaNValues(attributeData3.w);\n#if (numberOfFields > 4)\nvec4 attributeData4 = getDataDriven1(a_id);\nattributeData[4] = filterNaNValues(attributeData4.x);\nattributeData[5] = filterNaNValues(attributeData4.y);\nattributeData[6] = filterNaNValues(attributeData4.z);\nattributeData[7] = filterNaNValues(attributeData4.w);\n#endif\n#if (numberOfFields > 8)\nvec4 attributeData5 = getDataDriven2(a_id);\nattributeData[8] = filterNaNValues(attributeData5.x);\nattributeData[9] = filterNaNValues(attributeData5.y);\n#endif\nfloat sum = 0.0;\nfor (int i = 0; i < numberOfFields; ++i) {\nsum += attributeData[i];\n}\nfloat sectorAngles[numberOfFields];\nfor (int i = 0; i < numberOfFields; ++i) {\nsectorAngles[i] = 360.0 * attributeData[i] / sum;\n}\nvec2 filteredSectorToColorId[numberOfFields];\nFilteredChartInfo filteredInfo = FilteredChartInfo(0.0, 0);\nint numOfEntries = filterValues(filteredSectorToColorId, filteredInfo, sectorAngles);\nv_numOfEntries = float(numOfEntries);\nv_maxSectorAngle = filteredInfo.endSectorAngle;\nv_filteredSectorToColorId = filteredSectorToColorId;\n#ifdef HITTEST\nhighp vec3 out_pos = vec3(0.0);\nv_color            = vec4(0.0);\nhittestMarker(v_color, out_pos, viewMat3 * tileMat3 *  pos, v_size);\ngl_PointSize = 1.0;\ngl_Position = vec4(clip(v_color, out_pos, filterFlags, a_zoomRange), 1.0);\n#else\ngl_Position = vec4(clip(v_color, v_pos, filterFlags, a_zoomRange), 1.0);\n#endif\n}"},shared:{line:{"common.glsl":"#if !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE) && defined(PATTERN)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump float v_sampleAlphaOnly;\n#endif\nstruct LineData {\nlowp vec4 color;\nmediump vec2 normal;\nmediump float lineHalfWidth;\nlowp float opacity;\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#ifdef PATTERN\nmediump vec4 tlbr;\nmediump vec2 patternSize;\n#endif\n#ifdef SDF\nmediump float lineWidthRatio;\n#endif\n#if defined(PATTERN) || defined(SDF)\nhighp float accumulatedDistance;\n#endif\n#endif\nhighp vec3 id;\n};","line.frag":"uniform lowp float u_blur;\n#if !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE) && !defined(HIGHLIGHT)\n#if defined(PATTERN) || defined(SDF)\nuniform sampler2D u_texture;\nuniform highp float u_pixelRatio;\n#endif\n#endif\n#if defined(SDF) && !defined(HIGHLIGHT) && !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE)\nlowp vec4 getLineColor(LineData line) {\nmediump float adjustedPatternWidth = line.patternSize.x * 2.0 * line.lineWidthRatio;\nmediump float relativeTexX = fract(line.accumulatedDistance / adjustedPatternWidth);\nmediump float relativeTexY = 0.5 + 0.25 * line.normal.y;\nmediump vec2 texCoord = mix(line.tlbr.xy, line.tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * line.lineHalfWidth;\nreturn line.opacity * clamp(0.5 - dist, 0.0, 1.0) * line.color;\n}\n#elif defined(PATTERN) && !defined(HIGHLIGHT) && !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE)\nlowp vec4 getLineColor(LineData line) {\nmediump float lineHalfWidth = line.lineHalfWidth;\nmediump float adjustedPatternHeight = line.patternSize.y * 2.0 * lineHalfWidth / line.patternSize.x;\nmediump float relativeTexY = fract(line.accumulatedDistance / adjustedPatternHeight);\nmediump float relativeTexX = 0.5 + 0.5 * line.normal.y;\nmediump vec2 texCoord = mix(line.tlbr.xy, line.tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\n#ifdef VV_COLOR\nif (v_sampleAlphaOnly > 0.5) {\ncolor.rgb = vec3(color.a);\n}\n#endif\nreturn line.opacity * line.color * color;\n}\n#else\nlowp vec4 getLineColor(LineData line) {\nreturn line.opacity * line.color;\n}\n#endif\nvec4 shadeLine(LineData line)\n{\nmediump float thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(line.lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\nmediump float fragDist = length(line.normal) * line.lineHalfWidth;\nlowp float alpha = clamp(thinLineFactor * (line.lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\nlowp vec4 out_color = getLineColor(line) * alpha;\n#ifdef HIGHLIGHT\nout_color.a = step(1.0 / 255.0, out_color.a);\n#endif\n#ifdef ID\nif (out_color.a < 1.0 / 255.0) {\ndiscard;\n}\nout_color = vec4(line.id, 0.0);\n#endif\nreturn out_color;\n}","line.vert":"float getBaseLineHalfWidth(in float lineHalfWidth, in float referenceHalfWidth) {\n#ifdef VV_SIZE\nfloat refLineWidth = 2.0 * referenceHalfWidth;\nreturn 0.5 * (lineHalfWidth / max(referenceHalfWidth, EPSILON)) * getSize(refLineWidth);\n#else\nreturn lineHalfWidth;\n#endif\n}\nfloat getLineHalfWidth(in float baseWidth, in float aa) {\nfloat halfWidth = max(baseWidth + aa, 0.45) + 0.1 * aa;\n#ifdef HIGHLIGHT\nhalfWidth = max(halfWidth, 2.0);\n#endif\nreturn halfWidth;\n}\nvec2 getDist(in vec2 offset, in float halfWidth) {\nfloat thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(halfWidth, THIN_LINE_HALF_WIDTH), 1.0);\nreturn thinLineFactor * halfWidth * offset;\n}\nLineData buildLine(\nout vec3 out_pos,\nin vec3 in_id,\nin vec2 in_pos,\nin vec4 in_color,\nin vec2 in_offset,\nin vec2 in_normal,\nin float in_accumulatedDist,\nin float in_lineHalfWidth,\nin float in_bitSet,\nin vec4 in_tlbr,\nin vec2 in_segmentDirection,\nin float in_referenceHalfWidth\n)\n{\nfloat aa        = 0.5 * u_antialiasing;\nfloat baseWidth = getBaseLineHalfWidth(in_lineHalfWidth, in_referenceHalfWidth);\nfloat halfWidth = getLineHalfWidth(baseWidth, aa);\nfloat z         = 2.0 * step(baseWidth, 0.0);\nvec2  dist      = getDist(in_offset, halfWidth);\nvec3  offset    = u_displayViewMat3 * vec3(dist, 0.0);\nvec3  pos       = u_dvsMat3 * vec3(in_pos * POSITION_PRECISION, 1.0) + offset;\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\nvec4  color     = in_color;\nfloat opacity   = 1.0;\n#else\nvec4  color     = getColor(in_color, in_bitSet, BITSET_GENERIC_LOCK_COLOR);\nfloat opacity   = getOpacity();\n#ifdef SDF\nconst float SDF_PATTERN_HALF_WIDTH = 15.5;\nfloat scaleDash = getBit(in_bitSet, BITSET_LINE_SCALE_DASH);\nfloat lineWidthRatio = (scaleDash * max(halfWidth - 0.55 * u_antialiasing, 0.25) + (1.0 - scaleDash)) / SDF_PATTERN_HALF_WIDTH;\n#endif\n#endif\n#if !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE) && defined(PATTERN)\nv_sampleAlphaOnly = getBit(in_bitSet, BITSET_GENERIC_CONSIDER_ALPHA_ONLY);\n#endif\nout_pos = vec3(pos.xy, z);\nreturn LineData(\ncolor,\nin_normal,\nhalfWidth,\nopacity,\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#ifdef PATTERN\nin_tlbr / u_mosaicSize.xyxy,\nvec2(in_tlbr.z - in_tlbr.x, in_tlbr.w - in_tlbr.y),\n#endif\n#ifdef SDF\nlineWidthRatio,\n#endif\n#if defined(PATTERN) || defined(SDF)\nin_accumulatedDist * u_zoomFactor + dot(in_segmentDirection, dist),\n#endif\n#endif\nnorm(in_id)\n);\n}"}},"symbologyTypeUtils.glsl":"#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_OUTLINE_FILL || SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_OUTLINE_FILL_SIMPLE\n#define SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#endif\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_SIMPLE || SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_OUTLINE_FILL_SIMPLE\n#define SYMBOLOGY_TYPE_IS_SIMPLE_LIKE\n#endif",text:{"common.glsl":"uniform highp vec2 u_mosaicSize;\nvarying highp vec3 v_id;\nvarying mediump vec3 v_pos;\nvarying lowp float v_opacity;\nvarying lowp vec4 v_color;\nvarying highp vec2 v_tex;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying lowp float v_transparency;","hittest.glsl":"#include <materials/hittest/common.glsl>","text.frag":"precision mediump float;\n#include <materials/text/common.glsl>\nuniform lowp sampler2D u_texture;\n#ifdef HITTEST\nvec4 getColor() {\nreturn v_color;\n}\n#else\nvec4 getColor()\n{\nfloat SDF_CUTOFF = (2.0 / 8.0);\nfloat SDF_BASE_EDGE_DIST = 1.0 - SDF_CUTOFF;\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float edge = SDF_BASE_EDGE_DIST - v_edgeDistanceOffset;\n#ifdef HIGHLIGHT\nedge /= 2.0;\n#endif\nlowp float aa = v_antialiasingWidth;\nlowp float alpha = smoothstep(edge - aa, edge + aa, dist);\nreturn alpha * v_color * v_opacity;\n}\n#endif\nvoid main()\n{\ngl_FragColor = getColor();\n}","text.vert":"precision highp float;\n#include <materials/utils.glsl>\n#include <materials/vcommon.glsl>\n#include <materials/text/common.glsl>\n#include <materials/text/hittest.glsl>\nattribute vec4 a_color;\nattribute vec4 a_haloColor;\nattribute vec4 a_texFontSize;\nattribute vec4 a_aux;\nattribute vec2 a_zoomRange;\nattribute vec2 a_vertexOffset;\nattribute vec2 a_texCoords;\nuniform float u_isHaloPass;\nuniform float u_isBackgroundPass;\nfloat getTextSize(inout vec2 offset, inout float baseSize, in float referenceSize) {\n#ifdef VV_SIZE\nfloat r = getSize(referenceSize) / referenceSize;\nbaseSize *= r;\noffset.xy *= r;\nreturn baseSize;\n#endif\nreturn baseSize;\n}\nvoid main()\n{\nINIT;\nfloat a_isBackground  = a_aux.y;\nfloat a_referenceSize = a_aux.z * a_aux.z / 256.0;\nfloat a_bitSet        = a_aux.w;\nfloat a_fontSize      = a_texFontSize.z;\nvec2  a_offset        = a_vertexOffset * OFFSET_PRECISION;\nvec3  in_pos        = vec3(a_pos * POSITION_PRECISION, 1.0);\nfloat fontSize      = getTextSize(a_offset, a_fontSize, a_referenceSize);\nfloat fontScale     = fontSize / SDF_FONT_SIZE;\nvec3  offset        = getRotation() * vec3(a_offset, 0.0);\nmat3  extrudeMatrix = getBit(a_bitSet, 0) == 1.0 ? u_displayViewMat3 : u_displayMat3;\nfloat isText = 1.0 - a_isBackground;\nfloat isBackground = u_isBackgroundPass * a_isBackground;\nvec4  nonHaloColor  = (isBackground * a_color) + (isText * getColor(a_color, a_bitSet, 1));\nv_color   = u_isHaloPass * a_haloColor + (1.0 - u_isHaloPass) * nonHaloColor;\nv_opacity = getOpacity();\nv_id      = norm(a_id);\nv_tex     = a_texCoords / u_mosaicSize;\nv_pos     = u_dvsMat3 * in_pos + extrudeMatrix * offset;\nfloat isHidden = u_isBackgroundPass * isText + (1.0 - u_isBackgroundPass) * a_isBackground;\nv_pos.z += 2.0 * isHidden;\nv_edgeDistanceOffset = u_isHaloPass * OUTLINE_SCALE * a_texFontSize.w / fontScale / MAX_SDF_DISTANCE;\nv_antialiasingWidth  = 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\n#ifdef HITTEST\nhighp vec3 out_pos  = vec3(0.);\nv_color = vec4(0.);\nhittestMarker(v_color, out_pos, u_viewMat3 * u_tileMat3 *  vec3(a_pos * POSITION_PRECISION, 1.0)\n+ u_tileMat3 * offset, fontSize / 2.);\ngl_PointSize = 1.;\ngl_Position = vec4(clip(v_color, out_pos, getFilterFlags(), a_zoomRange), 1.0);\n#else\ngl_Position =  vec4(clip(v_color, v_pos, getFilterFlags(), a_zoomRange), 1.0);\n#endif\n}"},"utils.glsl":"float rshift(in float u32, in int amount) {\nreturn floor(u32 / pow(2.0, float(amount)));\n}\nfloat getBit(in float bitset, in int bitIndex) {\nfloat offset = pow(2.0, float(bitIndex));\nreturn mod(floor(bitset / offset), 2.0);\n}\nconst int maxHighlightReasons = 6;\nfloat getFilterBit(in float bitset, in int bitIndex) {\nreturn getBit(bitset, bitIndex + maxHighlightReasons);\n}\nfloat getHighlightBit(in float bitset, in int bitIndex) {\nreturn getBit(bitset, bitIndex);\n}\nhighp vec3 unpackDisplayIdTexel(in highp vec3 bitset) {\nfloat isAggregate = getBit(bitset.b, 7);\nreturn (1.0 - isAggregate) * bitset + isAggregate * (vec3(bitset.rgb) - vec3(0.0, 0.0, float(0x80)));\n}\nvec4 unpack(in float u32) {\nfloat r = mod(rshift(u32, 0), 255.0);\nfloat g = mod(rshift(u32, 8), 255.0);\nfloat b = mod(rshift(u32, 16), 255.0);\nfloat a = mod(rshift(u32, 24), 255.0);\nreturn vec4(r, g, b, a);\n}\nvec3 norm(in vec3 v) {\nreturn v /= 255.0;\n}\nvec4 norm(in vec4 v) {\nreturn v /= 255.0;\n}\nfloat max4(vec4 target) {\nreturn max(max(max(target.x, target.y), target.z), target.w);\n}\nvec2 unpack_u8_nf32(vec2 bytes) {\nreturn (bytes - 127.0) / 127.0;\n}\nhighp float rand(in vec2 co) {\nhighp float a = 12.9898;\nhighp float b = 78.233;\nhighp float c = 43758.5453;\nhighp float dt = dot(co, vec2(a,b));\nhighp float sn = mod(dt, 3.14);\nreturn fract(sin(sn) * c);\n}","vcommon.glsl":"#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/attributeData.glsl>\n#include <materials/vv.glsl>\n#include <materials/barycentric.glsl>\nattribute vec2 a_pos;\nattribute highp vec3 a_id;\nuniform highp mat3 displayViewScreenMat3;\nuniform highp mat3 displayViewMat3;\nuniform highp mat3 displayMat3;\nuniform highp mat3 tileMat3;\nuniform highp mat3 viewMat3;\nuniform highp float pixelRatio;\nuniform mediump float zoomFactor;\nuniform mediump float antialiasing;\nuniform mediump float currentScale;\nuniform mediump float currentZoom;\nuniform mediump float metersPerSRUnit;\nuniform mediump float activeReasons;\nuniform mediump float highlightAll;\nvec4 VV_ADATA = vec4(0.0);\nvoid loadVisualVariableData(inout vec4 target) {\ntarget.rgba = getVisualVariableData(a_id);\n}\n#ifdef VV\n#define INIT loadVisualVariableData(VV_ADATA)\n#else\n#define INIT\n#endif\nvec4 getColor(in vec4 a_color, in float a_bitSet, int index) {\n#ifdef VV_COLOR\nfloat isColorLocked   = getBit(a_bitSet, index);\nreturn getVVColor(VV_ADATA[ATTR_VV_COLOR], a_color, isColorLocked);\n#else\nreturn a_color;\n#endif\n}\nfloat getOpacity() {\n#ifdef VV_OPACITY\nreturn getVVOpacity(VV_ADATA[ATTR_VV_OPACITY]);\n#else\nreturn 1.0;\n#endif\n}\nfloat getSize(in float in_size, in float currentScale) {\n#ifdef VV_SIZE\nreturn getVVSize(in_size, VV_ADATA[ATTR_VV_SIZE], currentScale);\n#else\nreturn in_size;\n#endif\n}\nmat3 getRotation() {\n#ifdef VV_ROTATION\nreturn getVVRotationMat3(mod(VV_ADATA[ATTR_VV_ROTATION], 360.0));\n#else\nreturn mat3(1.0);\n#endif\n}\nfloat getFilterFlags() {\n#ifdef IGNORES_SAMPLER_PRECISION\nreturn ceil(getFilterData(a_id).x * 255.0);\n#else\nreturn getFilterData(a_id).x * 255.0;\n#endif\n}\nvec4 getAnimationState() {\nreturn getAnimation(a_id);\n}\nfloat getMinZoom() {\nvec4 data0 = getFilterData(a_id) * 255.0;\nreturn data0.g;\n}\nmat3 getMatrixNoDisplay(float isMapAligned) {\nreturn isMapAligned * viewMat3 * tileMat3 + (1.0 - isMapAligned) * tileMat3;\n}\nmat3 getMatrix(float isMapAligned) {\nreturn isMapAligned * displayViewMat3 + (1.0 - isMapAligned) * displayMat3;\n}\nfloat checkHighlightBit(float filterFlags, int index) {\nreturn getHighlightBit(filterFlags, index) * getBit(activeReasons, index);\n}\nfloat checkHighlight(float filterFlags) {\nfloat result = checkHighlightBit(filterFlags, 0);\nfor (int i = 1; i < maxHighlightReasons; i++) {\nresult = result + checkHighlightBit(filterFlags, i);\n}\nreturn step(0.1, result + highlightAll);\n}\nvec3 clip(inout vec4 color, inout vec3 pos, in float filterFlags, in vec2 minMaxZoom) {\npos.z += 2.0 * (1.0 - getFilterBit(filterFlags, 0));\n#ifdef inside\npos.z += 2.0 * (1.0 - getFilterBit(filterFlags, 1));\n#elif defined(outside)\npos.z += 2.0 * getFilterBit(filterFlags, 1);\n#elif defined(highlight)\npos.z += 2.0 * (1.0 - checkHighlight(filterFlags));\n#endif\npos.z += 2.0 * (step(minMaxZoom.y, currentZoom) + (1.0 - step(minMaxZoom.x, currentZoom)));\nreturn pos;\n}","vv.glsl":"#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n#define VV_SIZE\n#endif\n#if defined(VV_COLOR) || defined(VV_SIZE) || defined(VV_OPACITY) || defined(VV_ROTATION)\n#define VV\n#endif\n#ifdef VV_COLOR\nuniform highp float colorValues[8];\nuniform vec4 colors[8];\n#endif\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform highp vec4 minMaxValueAndSize;\n#endif\n#ifdef VV_SIZE_SCALE_STOPS\nuniform highp float values[8];\nuniform float sizes[8];\n#endif\n#ifdef VV_SIZE_FIELD_STOPS\nuniform highp float values[8];\nuniform float sizes[8];\n#endif\n#ifdef VV_SIZE_UNIT_VALUE\nuniform highp float unitMeterRatio;\n#endif\n#ifdef VV_OPACITY\nuniform highp float opacityValues[8];\nuniform float opacities[8];\n#endif\n#ifdef VV_ROTATION\nuniform lowp float rotationType;\n#endif\nbool isNan(float val) {\nreturn (val == NAN_MAGIC_NUMBER);\n}\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\nif (isNan(sizeValue)) {\nreturn fallback;\n}\nfloat interpolationRatio = (sizeValue  - minMaxValueAndSize.x) / (minMaxValueAndSize.y - minMaxValueAndSize.x);\ninterpolationRatio = clamp(interpolationRatio, 0.0, 1.0);\nreturn minMaxValueAndSize.z + interpolationRatio * (minMaxValueAndSize.w - minMaxValueAndSize.z);\n}\n#endif\n#ifdef VV_SIZE_SCALE_STOPS\nfloat getVVScaleStopsSize(float currentScale) {\nfloat outSize;\nif (currentScale <= values[0]) {\noutSize = sizes[0];\n} else {\nif (currentScale >= values[7]) {\noutSize = sizes[7];\n} else {\nint index;\nindex = -1;\nfor (int i = 0; i < 8; i++) {\nif (values[i] > currentScale) {\nindex = i;\nbreak;\n}\n}\nint prevIndex = index - 1;\nfloat a = currentScale - values[prevIndex];\nfloat b = values[index] - values[prevIndex];\noutSize = mix(sizes[prevIndex], sizes[index], a / b);\n}\n}\nreturn outSize;\n}\n#endif\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 8;\nfloat getVVStopsSize(float sizeValue, float fallback) {\nif (isNan(sizeValue)) {\nreturn fallback;\n}\nif (sizeValue <= values[0]) {\nreturn sizes[0];\n}\nif (sizeValue >= values[VV_SIZE_N - 1]) {\nreturn sizes[VV_SIZE_N - 1];\n}\nfor (int i = 1; i < VV_SIZE_N; ++i) {\nif (values[i] >= sizeValue) {\nfloat f = (sizeValue - values[i-1]) / (values[i] - values[i-1]);\nreturn mix(sizes[i-1], sizes[i], f);\n}\n}\nreturn sizes[VV_SIZE_N - 1];\n}\n#endif\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\nif (isNan(sizeValue)) {\nreturn fallback;\n}\nreturn sizeValue * (metersPerSRUnit / unitMeterRatio);\n}\n#endif\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\nif (isNan(opacityValue)) {\nreturn 1.0;\n}\nif (opacityValue <= opacityValues[0]) {\nreturn opacities[0];\n}\nfor (int i = 1; i < VV_OPACITY_N; ++i) {\nif (opacityValues[i] >= opacityValue) {\nfloat f = (opacityValue - opacityValues[i-1]) / (opacityValues[i] - opacityValues[i-1]);\nreturn mix(opacities[i-1], opacities[i], f);\n}\n}\nreturn opacities[VV_OPACITY_N - 1];\n}\n#endif\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\nif (isNan(rotationValue)) {\nreturn mat4(1, 0, 0, 0,\n0, 1, 0, 0,\n0, 0, 1, 0,\n0, 0, 0, 1);\n}\nfloat rotation = rotationValue;\nif (rotationType == 1.0) {\nrotation = 90.0 - rotation;\n}\nfloat angle = C_DEG_TO_RAD * rotation;\nfloat sinA = sin(angle);\nfloat cosA = cos(angle);\nreturn mat4(cosA, sinA, 0, 0,\n-sinA,  cosA, 0, 0,\n0,     0, 1, 0,\n0,     0, 0, 1);\n}\nmat3 getVVRotationMat3(float rotationValue) {\nif (isNan(rotationValue)) {\nreturn mat3(1, 0, 0,\n0, 1, 0,\n0, 0, 1);\n}\nfloat rotation = rotationValue;\nif (rotationType == 1.0) {\nrotation = 90.0 - rotation;\n}\nfloat angle = C_DEG_TO_RAD * -rotation;\nfloat sinA = sin(angle);\nfloat cosA = cos(angle);\nreturn mat3(cosA, -sinA, 0,\nsinA, cosA, 0,\n0,    0,    1);\n}\n#endif\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\nvec4 getVVColor(float colorValue, vec4 fallback, float isColorLocked) {\nif (isNan(colorValue) || isColorLocked == 1.0) {\nreturn fallback;\n}\nif (colorValue <= colorValues[0]) {\nreturn colors[0];\n}\nfor (int i = 1; i < VV_COLOR_N; ++i) {\nif (colorValues[i] >= colorValue) {\nfloat f = (colorValue - colorValues[i-1]) / (colorValues[i] - colorValues[i-1]);\nreturn mix(colors[i-1], colors[i], f);\n}\n}\nreturn colors[VV_COLOR_N - 1];\n}\n#endif\nfloat getVVSize(in float size, in float vvSize, in float currentScale)  {\n#ifdef VV_SIZE_MIN_MAX_VALUE\nreturn getVVMinMaxSize(vvSize, size);\n#elif defined(VV_SIZE_SCALE_STOPS)\nfloat outSize = getVVScaleStopsSize(currentScale);\nreturn isNan(outSize) ? size : outSize;\n#elif defined(VV_SIZE_FIELD_STOPS)\nfloat outSize = getVVStopsSize(vvSize, size);\nreturn isNan(outSize) ? size : outSize;\n#elif defined(VV_SIZE_UNIT_VALUE)\nreturn getVVUnitValue(vvSize, size);\n#else\nreturn size;\n#endif\n}"},"post-processing":{blit:{"blit.frag":"precision mediump float;\nuniform sampler2D u_texture;\nvarying vec2 v_uv;\nvoid main() {\ngl_FragColor = texture2D(u_texture, v_uv);\n}"},bloom:{composite:{"composite.frag":"precision mediump float;\nvarying vec2 v_uv;\nuniform sampler2D u_blurTexture1;\nuniform sampler2D u_blurTexture2;\nuniform sampler2D u_blurTexture3;\nuniform sampler2D u_blurTexture4;\nuniform sampler2D u_blurTexture5;\nuniform float u_bloomStrength;\nuniform float u_bloomRadius;\nuniform float u_bloomFactors[NUMMIPS];\nuniform vec3 u_bloomTintColors[NUMMIPS];\nfloat lerpBloomFactor(const in float factor) {\nfloat mirrorFactor = 1.2 - factor;\nreturn mix(factor, mirrorFactor, u_bloomRadius);\n}\nvoid main() {\nvec4 color = u_bloomStrength * (\nlerpBloomFactor(u_bloomFactors[0]) * vec4(u_bloomTintColors[0], 1.0) * texture2D(u_blurTexture1, v_uv) +\nlerpBloomFactor(u_bloomFactors[1]) * vec4(u_bloomTintColors[1], 1.0) * texture2D(u_blurTexture2, v_uv) +\nlerpBloomFactor(u_bloomFactors[2]) * vec4(u_bloomTintColors[2], 1.0) * texture2D(u_blurTexture3, v_uv) +\nlerpBloomFactor(u_bloomFactors[3]) * vec4(u_bloomTintColors[3], 1.0) * texture2D(u_blurTexture4, v_uv) +\nlerpBloomFactor(u_bloomFactors[4]) * vec4(u_bloomTintColors[4], 1.0) * texture2D(u_blurTexture5, v_uv)\n);\ngl_FragColor = clamp(color, 0.0, 1.0);\n}"},gaussianBlur:{"gaussianBlur.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nuniform vec2 u_texSize;\nuniform vec2 u_direction;\nvarying vec2 v_uv;\n#define KERNEL_RADIUS RADIUS\n#define SIGMA RADIUS\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x / ( sigma * sigma)) / sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / u_texSize;\nfloat fSigma = float(SIGMA);\nfloat weightSum = gaussianPdf(0.0, fSigma);\nvec4 pixelColorSum = texture2D(u_colorTexture, v_uv) * weightSum;\nfor (int i = 1; i < KERNEL_RADIUS; i ++) {\nfloat x = float(i);\nfloat w = gaussianPdf(x, fSigma);\nvec2 uvOffset = u_direction * invSize * x;\nvec4 sample1 = texture2D(u_colorTexture, v_uv + uvOffset);\nvec4 sample2 = texture2D(u_colorTexture, v_uv - uvOffset);\npixelColorSum += (sample1 + sample2) * w;\nweightSum += 2.0 * w;\n}\ngl_FragColor = pixelColorSum /weightSum;\n}"},luminosityHighPass:{"luminosityHighPass.frag":"precision mediump float;\nuniform sampler2D u_texture;\nuniform vec3 u_defaultColor;\nuniform float u_defaultOpacity;\nuniform float u_luminosityThreshold;\nuniform float u_smoothWidth;\nvarying vec2 v_uv;\nvoid main() {\nvec4 texel = texture2D(u_texture, v_uv);\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat v = dot(texel.xyz, luma);\nvec4 outputColor = vec4(u_defaultColor.rgb, u_defaultOpacity);\nfloat alpha = smoothstep(u_luminosityThreshold, u_luminosityThreshold + u_smoothWidth, v);\ngl_FragColor = mix(outputColor, texel, alpha);\n}"}},blur:{gaussianBlur:{"gaussianBlur.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nuniform vec2 u_texSize;\nuniform vec2 u_direction;\nuniform float u_sigma;\nvarying vec2 v_uv;\n#define KERNEL_RADIUS RADIUS\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x / ( sigma * sigma)) / sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / u_texSize;\nfloat fSigma = u_sigma;\nfloat weightSum = gaussianPdf(0.0, fSigma);\nvec4 pixelColorSum = texture2D(u_colorTexture, v_uv) * weightSum;\nfor (int i = 1; i < KERNEL_RADIUS; i ++) {\nfloat x = float(i);\nfloat w = gaussianPdf(x, fSigma);\nvec2 uvOffset = u_direction * invSize * x;\nvec4 sample1 = texture2D(u_colorTexture, v_uv + uvOffset);\nvec4 sample2 = texture2D(u_colorTexture, v_uv - uvOffset);\npixelColorSum += (sample1 + sample2) * w;\nweightSum += 2.0 * w;\n}\ngl_FragColor = pixelColorSum /weightSum;\n}"},"radial-blur":{"radial-blur.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nvarying vec2 v_uv;\nconst float sampleDist = 1.0;\nconst float sampleStrength = 2.2;\nvoid main(void) {\nfloat samples[10];\nsamples[0] = -0.08;\nsamples[1] = -0.05;\nsamples[2] = -0.03;\nsamples[3] = -0.02;\nsamples[4] = -0.01;\nsamples[5] =  0.01;\nsamples[6] =  0.02;\nsamples[7] =  0.03;\nsamples[8] =  0.05;\nsamples[9] =  0.08;\nvec2 dir = 0.5 - v_uv;\nfloat dist = sqrt(dir.x * dir.x + dir.y * dir.y);\ndir = dir / dist;\nvec4 color = texture2D(u_colorTexture,v_uv);\nvec4 sum = color;\nfor (int i = 0; i < 10; i++) {\nsum += texture2D(u_colorTexture, v_uv + dir * samples[i] * sampleDist);\n}\nsum *= 1.0 / 11.0;\nfloat t = dist * sampleStrength;\nt = clamp(t, 0.0, 1.0);\ngl_FragColor = mix(color, sum, t);\n}"}},dra:{"dra.frag":"precision mediump float;\nuniform sampler2D u_minColor;\nuniform sampler2D u_maxColor;\nuniform sampler2D u_texture;\nvarying vec2 v_uv;\nvoid main() {\nvec4 minColor = texture2D(u_minColor, vec2(0.5));\nvec4 maxColor = texture2D(u_maxColor, vec2(0.5));\nvec4 color = texture2D(u_texture, v_uv);\nvec3 minColorUnpremultiply = minColor.rgb / minColor.a;\nvec3 maxColorUnpremultiply = maxColor.rgb / maxColor.a;\nvec3 colorUnpremultiply = color.rgb / color.a;\nvec3 range = maxColorUnpremultiply - minColorUnpremultiply;\ngl_FragColor = vec4(color.a * (colorUnpremultiply - minColorUnpremultiply) / range, color.a);\n}","min-max":{"min-max.frag":"#extension GL_EXT_draw_buffers : require\nprecision mediump float;\n#define CELL_SIZE 2\nuniform sampler2D u_minTexture;\nuniform sampler2D u_maxTexture;\nuniform vec2 u_srcResolution;\nuniform vec2 u_dstResolution;\nvarying vec2 v_uv;\nvoid main() {\nvec2 srcPixel = floor(gl_FragCoord.xy) * float(CELL_SIZE);\nvec2 onePixel = vec2(1.0) / u_srcResolution;\nvec2 uv = (srcPixel + 0.5) / u_srcResolution;\nvec4 minColor = vec4(1.0);\nvec4 maxColor = vec4(0.0);\nfor (int y = 0; y < CELL_SIZE; ++y) {\nfor (int x = 0; x < CELL_SIZE; ++x) {\nvec2 offset = uv + vec2(x, y) * onePixel;\nminColor = min(minColor, texture2D(u_minTexture, offset));\nmaxColor = max(maxColor, texture2D(u_maxTexture, offset));\n}\n}\ngl_FragData[0] = minColor;\ngl_FragData[1] = maxColor;\n}"}},"drop-shadow":{composite:{"composite.frag":"precision mediump float;\nuniform sampler2D u_layerFBOTexture;\nuniform sampler2D u_blurTexture;\nuniform vec4 u_shadowColor;\nuniform vec2 u_shadowOffset;\nuniform highp mat3 u_displayViewMat3;\nvarying vec2 v_uv;\nvoid main() {\nvec3 offset = u_displayViewMat3 * vec3(u_shadowOffset, 0.0);\nvec4 layerColor = texture2D(u_layerFBOTexture, v_uv);\nvec4 blurColor = texture2D(u_blurTexture, v_uv - offset.xy / 2.0);\ngl_FragColor = ((1.0 - layerColor.a) * blurColor.a * u_shadowColor + layerColor);\n}"}},"edge-detect":{"frei-chen":{"frei-chen.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nuniform vec2 u_texSize;\nvarying vec2 v_uv;\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\nmat3 G[9];\nconst mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\nconst mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\nconst mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\nconst mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\nconst mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\nconst mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\nconst mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\nconst mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\nconst mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\nvoid main() {\nG[0] = g0,\nG[1] = g1,\nG[2] = g2,\nG[3] = g3,\nG[4] = g4,\nG[5] = g5,\nG[6] = g6,\nG[7] = g7,\nG[8] = g8;\nmat3 I;\nfloat cnv[9];\nvec3 sample;\nfor (float i = 0.0; i < 3.0; i++) {\nfor (float j = 0.0; j < 3.0; j++) {\nsample = texture2D(u_colorTexture, v_uv + texel * vec2(i - 1.0,j - 1.0)).rgb;\nI[int(i)][int(j)] = length(sample);\n}\n}\nfor (int i = 0; i < 9; i++) {\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\ncnv[i] = dp3 * dp3;\n}\nfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\nfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\ngl_FragColor = vec4(vec3(sqrt(M / S)), texture2D(u_colorTexture, v_uv).a);\n}"},sobel:{"sobel.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nvarying vec2 v_uv;\nuniform vec2 u_texSize;\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\nmat3 G[2];\nconst mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );\nconst mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );\nvoid main() {\nmat3 I;\nfloat cnv[2];\nvec3 sample;\nG[0] = g0;\nG[1] = g1;\nfor (float i = 0.0; i < 3.0; i++) {\nfor (float j = 0.0; j < 3.0; j++) {\nsample = texture2D( u_colorTexture, v_uv + texel * vec2(i-1.0,j-1.0) ).rgb;\nI[int(i)][int(j)] = length(sample);\n}\n}\nfor (int i = 0; i < 2; i++) {\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\ncnv[i] = dp3 * dp3;\n}\ngl_FragColor = vec4(vec3(0.5 * sqrt(cnv[0] * cnv[0] + cnv[1] * cnv[1])), texture2D(u_colorTexture, v_uv).a);\n}"}},"edge-enhance":{"edge-enhance.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nvarying vec2 v_uv;\nuniform vec2 u_texSize;\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\nmat3 G[2];\nconst mat3 g0 = mat3( 1.0, 0.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0, -1.0 );\nconst mat3 g1 = mat3( 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, -1.0, -1.0, -1.0 );\nvoid main() {\nmat3 I;\nfloat cnv[2];\nvec3 sample;\nG[0] = g0;\nG[1] = g1;\nfor (float i = 0.0; i < 3.0; i++) {\nfor (float j = 0.0; j < 3.0; j++) {\nsample = texture2D( u_colorTexture, v_uv + texel * vec2(i-1.0,j-1.0) ).rgb;\nI[int(i)][int(j)] = length(sample);\n}\n}\nfor (int i = 0; i < 2; i++) {\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\ncnv[i] = dp3 * dp3;\n}\nvec4 color = texture2D(u_colorTexture, v_uv);\ngl_FragColor = vec4(0.5 * sqrt(cnv[0] * cnv[0] + cnv[1] * cnv[1]) * color);\n}"},filterEffect:{"filterEffect.frag":"precision mediump float;\nuniform sampler2D u_colorTexture;\nuniform mat4 u_coefficients;\nvarying vec2 v_uv;\nvoid main() {\nvec4 color = texture2D(u_colorTexture, v_uv);\nvec4 rgbw = u_coefficients * vec4(color.a > 0.0 ? color.rgb / color.a : vec3(0.0), 1.0);\nfloat a = color.a;\ngl_FragColor = vec4(a * rgbw.rgb, a);\n}"},pp:{"pp.vert":"precision mediump float;\nattribute vec2 a_position;\nvarying vec2 v_uv;\nvoid main() {\ngl_Position = vec4(a_position, 0.0, 1.0);\nv_uv = (a_position + 1.0) / 2.0;\n}"}},raster:{common:{"common.glsl":"uniform sampler2D u_image;\nuniform int u_bandCount;\nuniform bool u_flipY;\nuniform float u_opacity;\nuniform int u_resampling;\nuniform vec2 u_srcImageSize;\n#ifdef APPLY_PROJECTION\n#include <raster/common/projection.glsl>\n#endif\n#ifdef BICUBIC\n#include <filtering/bicubic.glsl>\n#endif\n#ifdef BILINEAR\n#include <filtering/bilinear.glsl>\n#endif\nvec2 getPixelLocation(vec2 coords) {\nvec2 targetLocation = u_flipY ? vec2(coords.s, 1.0 - coords.t) : coords;\n#ifdef APPLY_PROJECTION\ntargetLocation = projectPixelLocation(targetLocation);\n#endif\nreturn targetLocation;\n}\nbool isOutside(vec2 coords){\nif (coords.t>1.00001 ||coords.t<-0.00001 || coords.s>1.00001 ||coords.s<-0.00001) {\nreturn true;\n} else {\nreturn false;\n}\n}\nvec4 getPixel(vec2 pixelLocation) {\n#ifdef BICUBIC\nvec4 color = sampleBicubicBSpline(u_image, pixelLocation, u_srcImageSize);\n#elif defined(BILINEAR)\nvec4 color = sampleBilinear(u_image, pixelLocation, u_srcImageSize);\n#else\nvec4 color = texture2D(u_image, pixelLocation);\n#endif\nreturn color;\n}","projection.glsl":"uniform sampler2D u_transformGrid;\nuniform vec2 u_transformSpacing;\nuniform vec2 u_transformGridSize;\nuniform vec2 u_targetImageSize;\nvec2 projectPixelLocation(vec2 coords) {\n#ifdef LOOKUP_PROJECTION\nvec4 pv = texture2D(u_transformGrid, coords);\nreturn vec2(pv.r, pv.g);\n#endif\nvec2 index_image = floor(coords * u_targetImageSize);\nvec2 oneTransformPixel = vec2(0.25 / u_transformGridSize.s, 1.0 / u_transformGridSize.t);\nvec2 index_transform = floor(index_image / u_transformSpacing) / u_transformGridSize;\nvec2 pos = fract((index_image + vec2(0.5, 0.5)) / u_transformSpacing);\nvec2 srcLocation;\nvec2 transform_location = index_transform + oneTransformPixel * 0.5;\nif (pos.s <= pos.t) {\nvec4 ll_abc = texture2D(u_transformGrid, vec2(transform_location.s, transform_location.t));\nvec4 ll_def = texture2D(u_transformGrid, vec2(transform_location.s + oneTransformPixel.s, transform_location.t));\nsrcLocation.s = dot(ll_abc.rgb, vec3(pos, 1.0));\nsrcLocation.t = dot(ll_def.rgb, vec3(pos, 1.0));\n} else {\nvec4 ur_abc = texture2D(u_transformGrid, vec2(transform_location.s + 2.0 * oneTransformPixel.s, transform_location.t));\nvec4 ur_def = texture2D(u_transformGrid, vec2(transform_location.s + 3.0 * oneTransformPixel.s, transform_location.t));\nsrcLocation.s = dot(ur_abc.rgb, vec3(pos, 1.0));\nsrcLocation.t = dot(ur_def.rgb, vec3(pos, 1.0));\n}\nreturn srcLocation;\n}"},flow:{"getFadeOpacity.glsl":"uniform float u_decayRate;\nuniform float u_fadeToZero;\nfloat getFadeOpacity(float x) {\nfloat cutOff = mix(0.0, exp(-u_decayRate), u_fadeToZero);\nreturn (exp(-u_decayRate * x) - cutOff) / (1.0 - cutOff);\n}","getFragmentColor.glsl":"vec4 getFragmentColor(vec4 color, float dist, float size, float featheringSize) {\nfloat featheringStart = clamp(0.5 - featheringSize / size, 0.0, 0.5);\nif (dist > featheringStart) {\ncolor *= 1.0 - (dist - featheringStart) / (0.5 - featheringStart);\n}\nreturn color;\n}",imagery:{"imagery.frag":"precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D u_texture;\nuniform float u_Min;\nuniform float u_Max;\nuniform float u_featheringSize;\n#include <raster/flow/vv.glsl>\nfloat getIntensity(float v) {\nreturn u_Min + v * (u_Max - u_Min);\n}\nvoid main(void) {\nvec4 sampled = texture2D(u_texture, v_texcoord);\nfloat intensity = getIntensity(sampled.r);\ngl_FragColor = getColor(intensity);\ngl_FragColor.a *= getOpacity(sampled.r);\ngl_FragColor.a *= sampled.a;\ngl_FragColor.rgb *= gl_FragColor.a;\n}","imagery.vert":"attribute vec2 a_position;\nattribute vec2 a_texcoord;\nuniform mat3 u_dvsMat3;\nvarying vec2 v_texcoord;\nvoid main(void) {\nvec2 xy = (u_dvsMat3 * vec3(a_position, 1.0)).xy;\ngl_Position = vec4(xy, 0.0, 1.0);\nv_texcoord = a_texcoord;\n}"},particles:{"particles.frag":"precision highp float;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\nvarying float v_size;\nuniform float u_featheringSize;\n#include <raster/flow/getFragmentColor.glsl>\nvoid main(void) {\ngl_FragColor = getFragmentColor(v_color, length(v_texcoord - 0.5), v_size, u_featheringSize);\n}","particles.vert":"attribute vec4 a_xyts0;\nattribute vec4 a_xyts1;\nattribute vec4 a_typeIdDurationSeed;\nattribute vec4 a_extrudeInfo;\nuniform mat3 u_dvsMat3;\nuniform mat3 u_displayViewMat3;\nuniform float u_time;\nuniform float u_trailLength;\nuniform float u_flowSpeed;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\nvarying float v_size;\nuniform float u_featheringSize;\nuniform float u_introFade;\n#include <raster/flow/vv.glsl>\n#include <raster/flow/getFadeOpacity.glsl>\nvoid main(void) {\nvec2 position0 = a_xyts0.xy;\nfloat t0 = a_xyts0.z;\nfloat speed0 = a_xyts0.w;\nvec2 position1 = a_xyts1.xy;\nfloat t1 = a_xyts1.z;\nfloat speed1 = a_xyts1.w;\nfloat type = a_typeIdDurationSeed.x;\nfloat id = a_typeIdDurationSeed.y;\nfloat duration = a_typeIdDurationSeed.z;\nfloat seed = a_typeIdDurationSeed.w;\nvec2 e0 = a_extrudeInfo.xy;\nvec2 e1 = a_extrudeInfo.zw;\nfloat animationPeriod = duration + u_trailLength;\nfloat scaledTime = u_time * u_flowSpeed;\nfloat randomizedTime = scaledTime + seed * animationPeriod;\nfloat t = mod(randomizedTime, animationPeriod);\nfloat fUnclamped = (t - t0) / (t1 - t0);\nfloat f = clamp(fUnclamped, 0.0, 1.0);\nfloat clampedTime = mix(t0, t1, f);\nfloat speed = mix(speed0, speed1, f);\nvec2 extrude;\nvec2 position;\nfloat fadeOpacity;\nfloat introOpacity;\nif (type == 2.0) {\nif (fUnclamped < 0.0 || (fUnclamped > 1.0 && t1 != duration)) {\ngl_Position = vec4(0.0, 0.0, -2.0, 1.0);\nreturn;\n}\nvec2 ortho = mix(e0, e1, f);\nvec2 parallel;\nparallel = normalize(position1 - position0) * 0.5;\nif (id == 1.0) {\nextrude = ortho;\nv_texcoord = vec2(0.5, 0.0);\n} else if (id == 2.0) {\nextrude = -ortho;\nv_texcoord = vec2(0.5, 1.0);\n} else if (id == 3.0) {\nextrude = ortho + parallel;\nv_texcoord = vec2(1.0, 0.0);\n} else if (id == 4.0) {\nextrude = -ortho + parallel;\nv_texcoord = vec2(1.0, 1.0);\n}\nfadeOpacity = getFadeOpacity((t - clampedTime) / u_trailLength);\nintroOpacity = 1.0 - exp(-clampedTime);\nv_size = getSize(speed);\nv_color = getColor(speed);\nv_color.a *= getOpacity(speed);\nposition = mix(position0, position1, f);\n} else {\nif (fUnclamped < 0.0) {\ngl_Position = vec4(0.0, 0.0, -2.0, 1.0);\nreturn;\n}\nif (id == 1.0) {\nextrude = e0;\nv_texcoord = vec2(0.5, 0.0);\nfadeOpacity = getFadeOpacity((t - t0) / u_trailLength);\nintroOpacity = 1.0 - exp(-t0);\nv_size = getSize(speed0);\nv_color = getColor(speed0);\nv_color.a *= getOpacity(speed0);\nposition = position0;\n} else if (id == 2.0) {\nextrude = -e0;\nv_texcoord = vec2(0.5, 1.0);\nfadeOpacity = getFadeOpacity((t - t0) / u_trailLength);\nintroOpacity = 1.0 - exp(-t0);\nv_size = getSize(speed0);\nv_color = getColor(speed0);\nv_color.a *= getOpacity(speed0);\nposition = position0;\n} else if (id == 3.0) {\nextrude = mix(e0, e1, f);\nv_texcoord = vec2(0.5, 0.0);\nfadeOpacity = getFadeOpacity((t - clampedTime) / u_trailLength);\nintroOpacity = 1.0 - exp(-clampedTime);\nv_size = getSize(speed);\nv_color = getColor(speed);\nv_color.a *= getOpacity(speed);\nposition = mix(position0, position1, f);\n} else if (id == 4.0) {\nextrude = -mix(e0, e1, f);\nv_texcoord = vec2(0.5, 1.0);\nfadeOpacity = getFadeOpacity((t - clampedTime) / u_trailLength);\nintroOpacity = 1.0 - exp(-clampedTime);\nv_size = getSize(speed);\nv_color = getColor(speed);\nv_color.a *= getOpacity(speed);\nposition = mix(position0, position1, f);\n}\n}\nvec2 xy = (u_dvsMat3 * vec3(position, 1.0) + u_displayViewMat3 * vec3(extrude * v_size, 0.0)).xy;\ngl_Position = vec4(xy, 0.0, 1.0);\nv_color.a *= fadeOpacity;\nv_color.a *= mix(1.0, introOpacity, u_introFade);\nv_color.rgb *= v_color.a;\n}"},streamlines:{"streamlines.frag":"precision highp float;\nvarying float v_side;\nvarying float v_time;\nvarying float v_totalTime;\nvarying float v_timeSeed;\nvarying vec4 v_color;\nvarying float v_size;\nuniform float u_time;\nuniform float u_trailLength;\nuniform float u_flowSpeed;\nuniform float u_featheringSize;\nuniform float u_introFade;\n#include <raster/flow/getFragmentColor.glsl>\n#include <raster/flow/getFadeOpacity.glsl>\nvoid main(void) {\nfloat t = mod(v_timeSeed * (v_totalTime + u_trailLength) + u_time * u_flowSpeed, v_totalTime + u_trailLength) - v_time;\nvec4 color = v_color * step(0.0, t) * getFadeOpacity(t / u_trailLength);\ncolor *= mix(1.0, 1.0 - exp(-v_time), u_introFade);\ngl_FragColor = getFragmentColor(color, length((v_side + 1.0) / 2.0 - 0.5), v_size, u_featheringSize);\n}","streamlines.vert":"attribute vec3 a_positionAndSide;\nattribute vec3 a_timeInfo;\nattribute vec2 a_extrude;\nattribute float a_speed;\nuniform mat3 u_dvsMat3;\nuniform mat3 u_displayViewMat3;\nvarying float v_time;\nvarying float v_totalTime;\nvarying float v_timeSeed;\nvarying vec4 v_color;\nvarying float v_side;\nvarying float v_size;\nuniform float u_featheringSize;\n#include <raster/flow/vv.glsl>\nvoid main(void) {\nvec4 lineColor = getColor(a_speed);\nfloat lineOpacity = getOpacity(a_speed);\nfloat lineSize = getSize(a_speed);\nvec2 position = a_positionAndSide.xy;\nv_side = a_positionAndSide.z;\nvec2 xy = (u_dvsMat3 * vec3(position, 1.0) + u_displayViewMat3 * vec3(a_extrude * lineSize, 0.0)).xy;\ngl_Position = vec4(xy, 0.0, 1.0);\nv_time = a_timeInfo.x;\nv_totalTime = a_timeInfo.y;\nv_timeSeed = a_timeInfo.z;\nv_color = lineColor;\nv_color.a *= lineOpacity;\nv_color.rgb *= v_color.a;\nv_size = lineSize;\n}"},"vv.glsl":"#define MAX_STOPS 8\n#ifdef VV_COLOR\nuniform float u_color_stops[MAX_STOPS];\nuniform vec4 u_color_values[MAX_STOPS];\nuniform int u_color_count;\n#else\nuniform vec4 u_color;\n#endif\n#ifdef VV_OPACITY\nuniform float u_opacity_stops[MAX_STOPS];\nuniform float u_opacity_values[MAX_STOPS];\nuniform int u_opacity_count;\n#else\nuniform float u_opacity;\n#endif\n#ifdef VV_SIZE\nuniform float u_size_stops[MAX_STOPS];\nuniform float u_size_values[MAX_STOPS];\nuniform int u_size_count;\n#else\nuniform float u_size;\n#endif\nuniform float u_featheringOffset;\nvec4 getColor(float x) {\n#ifdef VV_COLOR\nvec4 color = u_color_values[0];\n{\nfor (int i = 1; i < MAX_STOPS; i++) {\nif (i >= u_color_count) {\nbreak;\n}\nfloat x1 = u_color_stops[i - 1];\nif (x < x1) {\nbreak;\n}\nfloat x2 = u_color_stops[i];\nvec4 y2 = u_color_values[i];\nif (x < x2) {\nvec4 y1 = u_color_values[i - 1];\ncolor = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n} else {\ncolor = y2;\n}\n}\n}\n#else\nvec4 color = u_color;\n#endif\nreturn color;\n}\nfloat getOpacity(float x) {\n#ifdef VV_OPACITY\nfloat opacity = u_opacity_values[0];\n{\nfor (int i = 1; i < MAX_STOPS; i++) {\nif (i >= u_opacity_count) {\nbreak;\n}\nfloat x1 = u_opacity_stops[i - 1];\nif (x < x1) {\nbreak;\n}\nfloat x2 = u_opacity_stops[i];\nfloat y2 = u_opacity_values[i];\nif (x < x2) {\nfloat y1 = u_opacity_values[i - 1];\nopacity = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n} else {\nopacity = y2;\n}\n}\n}\n#else\nfloat opacity = u_opacity;\n#endif\nreturn opacity;\n}\nfloat getSize(float x) {\n#ifdef VV_SIZE\nfloat size = u_size_values[0];\n{\nfor (int i = 1; i < MAX_STOPS; i++) {\nif (i >= u_size_count) {\nbreak;\n}\nfloat x1 = u_size_stops[i - 1];\nif (x < x1) {\nbreak;\n}\nfloat x2 = u_size_stops[i];\nfloat y2 = u_size_values[i];\nif (x < x2) {\nfloat y1 = u_size_values[i - 1];\nsize = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n} else {\nsize = y2;\n}\n}\n}\n#else\nfloat size = u_size;\n#endif\nreturn size + 2.0 * u_featheringSize * u_featheringOffset;\n}"},magdir:{"magdir.frag":"precision mediump float;\nvarying vec4 v_color;\nuniform lowp float u_opacity;\nvoid main() {\ngl_FragColor = v_color * u_opacity;\n}","magdir.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_vv;\nuniform highp mat3 u_dvsMat3;\nuniform highp vec2 u_coordScale;\nuniform vec2 u_symbolSize;\nuniform vec2 u_symbolPercentRange;\nuniform vec2 u_dataRange;\nuniform float u_rotation;\nuniform vec4 u_colors[12];\nvarying vec4 v_color;\nvoid main()\n{\nfloat angle = a_offset.y + u_rotation;\n#ifndef ROTATION_GEOGRAPHIC\nangle = 3.14159265359 * 2.0 - angle - 3.14159265359 / 2.0;\n#endif\nvec2 offset = vec2(cos(angle), sin(angle)) * a_offset.x;\n#ifdef DATA_RANGE\nfloat valuePercentage = clamp((a_vv.y - u_dataRange.x) / (u_dataRange.y - u_dataRange.x), 0.0, 1.0);\nfloat sizeRatio = u_symbolPercentRange.x + valuePercentage * (u_symbolPercentRange.y - u_symbolPercentRange.x);\nfloat sizePercentage = clamp(sizeRatio, u_symbolPercentRange.x, u_symbolPercentRange.y);\n#else\nfloat sizePercentage = (u_symbolPercentRange.x + u_symbolPercentRange.y) / 2.0;\n#endif\nvec2 pos = a_pos + offset * sizePercentage * u_symbolSize;\nv_color = u_colors[int(a_vv.x)];\ngl_Position = vec4(u_dvsMat3 * vec3(pos * u_coordScale, 1.0), 1.0);\n}"},reproject:{"reproject.frag":"precision mediump float;\nvarying vec2 v_texcoord;\n#include <raster/common/common.glsl>\nvoid main() {\nvec2 pixelLocation = getPixelLocation(v_texcoord);\nif (isOutside(pixelLocation)) {\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\ngl_FragColor = vec4(currentPixel.rgb, 1.0) * currentPixel.a * u_opacity;\n}","reproject.vert":"precision mediump float;\nattribute vec2 a_position;\nvarying highp vec2 v_texcoord;\nvoid main()\n{\nv_texcoord = a_position;\ngl_Position = vec4(2.0 * (a_position - 0.5), 0.0, 1.0);\n}"},scalar:{"scalar.frag":"precision mediump float;\nuniform lowp float u_opacity;\nvarying vec2 v_pos;\nconst vec4 outlineColor = vec4(0.2, 0.2, 0.2, 1.0);\nconst float outlineSize = 0.02;\nconst float innerRadius = 0.25;\nconst float outerRadius = 0.42;\nconst float innerSquareLength = 0.15;\nvoid main() {\nmediump float dist = length(v_pos);\nmediump float fillalpha1 = smoothstep(outerRadius, outerRadius + outlineSize, dist);\nfillalpha1 *= (1.0-smoothstep(outerRadius + outlineSize, outerRadius + 0.1 + outlineSize, dist));\n#ifdef INNER_CIRCLE\nmediump float fillalpha2 = smoothstep(innerRadius, innerRadius + outlineSize, dist);\nfillalpha2 *= (1.0-smoothstep(innerRadius + outlineSize, innerRadius + 0.1 + outlineSize, dist));\n#else\nmediump float fillalpha2 = (abs(v_pos.x) < innerSquareLength ? 1.0 : 0.0) * (abs(v_pos.y) < innerSquareLength ? 1.0 : 0.0);\n#endif\ngl_FragColor = (fillalpha2 + fillalpha1) * outlineColor * u_opacity;\n}","scalar.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_vv;\nuniform highp mat3 u_dvsMat3;\nuniform highp vec2 u_coordScale;\nuniform vec2 u_symbolSize;\nuniform vec2 u_symbolPercentRange;\nuniform vec2 u_dataRange;\nvarying vec2 v_pos;\nvoid main()\n{\n#ifdef DATA_RANGE\nfloat valuePercentage = clamp((a_vv.y - u_dataRange.x) / (u_dataRange.y - u_dataRange.x), 0.0, 1.0);\nfloat sizeRatio = u_symbolPercentRange.x + valuePercentage * (u_symbolPercentRange.y - u_symbolPercentRange.x);\nfloat sizePercentage = clamp(sizeRatio, u_symbolPercentRange.x, u_symbolPercentRange.y);\n#else\nfloat sizePercentage = (u_symbolPercentRange.x + u_symbolPercentRange.y) / 2.0;\n#endif\nvec2 size = u_symbolSize * sizePercentage;\nvec2 pos = a_pos + a_offset * size;\nv_pos = a_offset;\ngl_Position = vec4(u_dvsMat3 * vec3(pos * u_coordScale, 1.0), 1.0);\n}"}},stencil:{"stencil.frag":"void main() {\ngl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}","stencil.vert":"attribute vec2 a_pos;\nuniform mat3 u_worldExtent;\nvoid main() {\ngl_Position = vec4(u_worldExtent * vec3(a_pos, 1.0), 1.0);\n}"},test:{"TestShader.common.glsl":"#ifndef RETURN_RED\nvarying    vec4      v_color;\n#endif\nvarying    vec2      v_offset;","TestShader.frag":"precision highp float;\n#include <test/TestShader.common.glsl>\nvoid main() {\nif (v_offset.x > -.5 && v_offset.y > -.5 && v_offset.x < .5 && v_offset.y < .5) {\ndiscard;\n}\n#ifdef RETURN_RED\ngl_FragColor = vec4(1., 0., 0., 1.);\n#else\ngl_FragColor = v_color;\n#endif\n}","TestShader.vert":"const float POS_PRECISION_FACTOR = 10.;\nconst float OFFSET_PRECISION_FACTOR = 10.;\nconst float SIZE_PRECISION_FACTOR = 10.;\nattribute  vec2      a_pos_packed;\nattribute  vec2      a_offset_packed;\nattribute  float     a_size_packed;\n#ifdef DATA_DRIVEN_COLOR\nconst float u_dataDrivenColor_validValues[4] = float[4](0., 0., 1., 0.);\nuniform    vec4      u_dataDrivenColor_colorFallback;\nuniform    vec4      u_dataDrivenColor_color;\n#endif\nuniform    float     u_view_zoomLevel;\n#include <test/TestShader.common.glsl>\n#ifdef DATA_DRIVEN_COLOR\nvec4 getColor(float value) {\nint index = -1;\nfor (int i = 0; i < 4; i++) {\nif (u_dataDrivenColor_validValues[i] == value) {\nindex = i;\nbreak;\n}\n}\nif (index == -1) {\nreturn u_dataDrivenColor_colorFallback;\n}\nreturn u_dataDrivenColor_color;\n}\n#endif\nvoid main() {\nvec2  a_pos = a_pos_packed / POS_PRECISION_FACTOR;\nvec2  a_offset = a_offset_packed / OFFSET_PRECISION_FACTOR;\nfloat a_size = a_size_packed / SIZE_PRECISION_FACTOR;\nvec4 color = vec4(1., 0., 0., 1.);\n#ifdef DATA_DRIVEN_COLOR\ncolor = getColor(1.);\n#endif\nvec2 offsetScaled = a_offset * a_size;\nvec4 pos = vec4(a_pos.xy + offsetScaled, 0., 1.);\ngl_Position = pos;\n#ifndef RETURN_RED\nv_color = color;\n#endif\nv_offset = a_offset;\n}"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\nvoid main(void) {\nlowp vec4 color = texture2D(u_texture, v_tex);\ncolor.rgb *= color.a;\ngl_FragColor = color;\n}","tileInfo.vert":"attribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_coord_ratio;\nuniform mediump vec2 u_delta;\nuniform mediump vec2 u_dimensions;\nvarying mediump vec2 v_tex;\nvoid main() {\nmediump vec2 offset = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\nvec3 v_pos = u_dvsMat3 * vec3(offset, 1.0);\ngl_Position = vec4(v_pos.xy, 0.0, 1.0);\nv_tex = a_pos;\n}"},util:{"atan2.glsl":"float atan2(in float y, in float x) {\nfloat t0, t1, t2, t3, t4;\nt3 = abs(x);\nt1 = abs(y);\nt0 = max(t3, t1);\nt1 = min(t3, t1);\nt3 = 1.0 / t0;\nt3 = t1 * t3;\nt4 = t3 * t3;\nt0 =         - 0.013480470;\nt0 = t0 * t4 + 0.057477314;\nt0 = t0 * t4 - 0.121239071;\nt0 = t0 * t4 + 0.195635925;\nt0 = t0 * t4 - 0.332994597;\nt0 = t0 * t4 + 0.999995630;\nt3 = t0 * t3;\nt3 = (abs(y) > abs(x)) ? 1.570796327 - t3 : t3;\nt3 = x < 0.0 ?  3.141592654 - t3 : t3;\nt3 = y < 0.0 ? -t3 : t3;\nreturn t3;\n}","encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}"}};


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/webgl/util/Reader.js":
/*!************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/webgl/util/Reader.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ t)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
class t{constructor(t){this._pos=0,this._buffer=t,this._i32View=new Int32Array(this._buffer),this._f32View=new Float32Array(this._buffer)}readInt32(){return this._i32View[this._pos++]}readF32(){return this._f32View[this._pos++]}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/webgl/ProgramTemplate.js":
/*!******************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/webgl/ProgramTemplate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createProgram: () => (/* binding */ e)
/* harmony export */ });
/* harmony import */ var _Program_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Program.js */ "./node_modules/@arcgis/core/views/webgl/Program.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
function e(e,t,a=""){return new _Program_js__WEBPACK_IMPORTED_MODULE_0__.Program(e,a+t.shaders.vertexShader,a+t.shaders.fragmentShader,t.attributes)}


/***/ })

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYXJjZ2lzX2NvcmVfdmlld3NfMmRfZW5naW5lX3dlYmdsX1dHTENvbnRhaW5lcl9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDbWdCLFNBQVMsS0FBSyxtRUFBQyxTQUFTLHlFQUFDLGVBQWUsK0VBQUMsZUFBZSwwRkFBQyxTQUFTLDhFQUFDLFNBQVMsOEVBQUMsV0FBVyxrRkFBQyxXQUFXLGtGQUFDLEVBQXVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ovbkI7QUFDQTtBQUNBO0FBQ0E7QUFDd25CLFFBQVEsbUZBQUMsS0FBSyxtRkFBQyxHQUFHLGdCQUFnQixzRUFBQyxDQUFDLHFCQUFxQixjQUFjLHFEQUFDLENBQUMscURBQUMsRUFBRSxVQUFVLGdCQUFnQixnQkFBZ0IseUtBQXlLLHdFQUFDLHNCQUFzQiw2RUFBQyw0REFBNEQsUUFBUSx5RUFBQyxDQUFDLG9GQUFDLGdCQUFnQiw4RUFBQywyQ0FBMkMsY0FBYyw4QkFBOEIsMENBQTBDLDZFQUFDLElBQUksOEVBQUMsUUFBUSwyRUFBQyw2QkFBNkIsMEVBQUMsY0FBYyxvQkFBb0IsT0FBTyxXQUFXLG9GQUFDLFlBQVksbUZBQUMseUJBQXlCLG1GQUFDLHFCQUFxQixtRkFBQyxJQUFJLDJCQUEyQixRQUFRLDZFQUFDLDBDQUEwQywyRUFBQyxNQUFNLG9CQUFvQixtREFBQyxXQUFXLFFBQVEsbURBQUMsMkNBQTJDLGtFQUE0Rjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKaGpEO0FBQ0E7QUFDQTtBQUNBO0FBQ3diLGdCQUFnQiw0REFBQyxDQUFDLGlCQUFpQixtQ0FBbUMsMkJBQTJCLDZEQUFDLHdEQUF3RCx5QkFBeUIsa0JBQWtCLGFBQWEsbUpBQW1KLFVBQVUsd0NBQXdDLGdCQUFnQixrQkFBa0IsNEpBQTRKLHFGQUFxRix1Q0FBdUMsMEVBQUMsWUFBWSx1QkFBdUIsb0JBQW9CLE9BQU8sc0JBQXNC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TEFBbUwsK0JBQStCLHVDQUF1QyxHQUFHLElBQXlCOzs7Ozs7Ozs7Ozs7Ozs7QUNKN3orRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZUFBZSxtSEFBbUgsWUFBWSxrQ0FBa0MsVUFBVSxtQ0FBd0Q7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKMVA7QUFDQTtBQUNBO0FBQ0E7QUFDdUMscUJBQXFCLFdBQVcsZ0RBQUMscUVBQWdHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS9icnVzaGVzLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy8yZC9lbmdpbmUvd2ViZ2wvQUZlYXR1cmVUaWxlLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy8yZC9lbmdpbmUvd2ViZ2wvQ2xpcHBpbmdJbmZvLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy8yZC9lbmdpbmUvd2ViZ2wvRmVhdHVyZURpc3BsYXlMaXN0LmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy8yZC9lbmdpbmUvd2ViZ2wvRmVhdHVyZVRpbGUuanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS93ZWJnbC9NZXNoMkQuanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS93ZWJnbC9Qb29sZWRVaW50MzJBcnJheS5qcyIsIndlYnBhY2s6Ly9wcmVjaXNpb25mYXJtcy8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvdmlld3MvMmQvZW5naW5lL3dlYmdsL1Jlc2h1ZmZsZVBsYW4uanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS93ZWJnbC9XR0xDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS93ZWJnbC9icnVzaGVzL0JydXNoQ2xpcC5qcyIsIndlYnBhY2s6Ly9wcmVjaXNpb25mYXJtcy8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvdmlld3MvMmQvZW5naW5lL3dlYmdsL2JydXNoZXMvV0dMQnJ1c2hTdGVuY2lsLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy8yZC9lbmdpbmUvd2ViZ2wvYnJ1c2hlcy9XR0xCcnVzaFRpbGVEZWJ1Z0luZm8uanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS93ZWJnbC9jcHVNYXBwZWQvQnVmZmVyLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy8yZC9lbmdpbmUvd2ViZ2wvY3B1TWFwcGVkL0ZyZWVMaXN0LmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy8yZC9lbmdpbmUvd2ViZ2wvY3B1TWFwcGVkL01hcHBlZE1lc2guanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS93ZWJnbC9tZXNoL21lc2hEZWJ1Z1V0aWxzLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy8yZC9lbmdpbmUvd2ViZ2wvc2hhZGVycy9CYWNrZ3JvdW5kUHJvZ3JhbXMuanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS93ZWJnbC9zaGFkZXJzL1RpbGVJbmZvUHJvZ3JhbXMuanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS93ZWJnbC9zaGFkZXJzL3NvdXJjZXMvcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzLzJkL2VuZ2luZS93ZWJnbC9zaGFkZXJzL3NvdXJjZXMvc2hhZGVyUmVwb3NpdG9yeS5qcyIsIndlYnBhY2s6Ly9wcmVjaXNpb25mYXJtcy8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvdmlld3MvMmQvZW5naW5lL3dlYmdsL3V0aWwvUmVhZGVyLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy93ZWJnbC9Qcm9ncmFtVGVtcGxhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMzMvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuKi9cbmltcG9ydCByIGZyb21cIi4vd2ViZ2wvYnJ1c2hlcy9CcnVzaENsaXAuanNcIjtpbXBvcnQgcyBmcm9tXCIuL3dlYmdsL2JydXNoZXMvV0dMQnJ1c2hTdGVuY2lsLmpzXCI7aW1wb3J0IGUgZnJvbVwiLi93ZWJnbC9icnVzaGVzL1dHTEJydXNoVGlsZURlYnVnSW5mby5qc1wiO2ltcG9ydHtXR0xCcnVzaFZUTEJhY2tncm91bmQgYXMgbH1mcm9tXCIuL3dlYmdsL2JydXNoZXMvV0dMQnJ1c2hWVExCYWNrZ3JvdW5kLmpzXCI7aW1wb3J0e1dHTEJydXNoVlRMQ2lyY2xlIGFzIG99ZnJvbVwiLi93ZWJnbC9icnVzaGVzL1dHTEJydXNoVlRMQ2lyY2xlLmpzXCI7aW1wb3J0e1dHTEJydXNoVlRMRmlsbCBhcyBifWZyb21cIi4vd2ViZ2wvYnJ1c2hlcy9XR0xCcnVzaFZUTEZpbGwuanNcIjtpbXBvcnR7V0dMQnJ1c2hWVExMaW5lIGFzIGl9ZnJvbVwiLi93ZWJnbC9icnVzaGVzL1dHTEJydXNoVlRMTGluZS5qc1wiO2ltcG9ydHtXR0xCcnVzaFZUTFN5bWJvbCBhcyB1fWZyb21cIi4vd2ViZ2wvYnJ1c2hlcy9XR0xCcnVzaFZUTFN5bWJvbC5qc1wiO2NvbnN0IG09e2NsaXA6cixzdGVuY2lsOnMsdGlsZURlYnVnSW5mbzplLHZ0bEJhY2tncm91bmQ6bCx2dGxGaWxsOmIsdnRsTGluZTppLHZ0bENpcmNsZTpvLHZ0bFN5bWJvbDp1fTtleHBvcnR7bSBhcyBicnVzaGVzfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjMzL2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnR7c2V0IGFzIHQsbXVsdGlwbHkgYXMgc31mcm9tXCIuLi8uLi8uLi8uLi9jb3JlL2xpYnMvZ2wtbWF0cml4LTIvbWF0aC9tYXQyZC5qc1wiO2ltcG9ydHtjcmVhdGUgYXMgaX1mcm9tXCIuLi8uLi8uLi8uLi9jb3JlL2xpYnMvZ2wtbWF0cml4LTIvZmFjdG9yaWVzL21hdDJkZjMyLmpzXCI7aW1wb3J0e3NldCBhcyByLG11bHRpcGx5IGFzIG8saWRlbnRpdHkgYXMgZSx0cmFuc2xhdGUgYXMgYSxyb3RhdGUgYXMgbixzY2FsZSBhcyBsLGludmVydCBhcyBtfWZyb21cIi4uLy4uLy4uLy4uL2NvcmUvbGlicy9nbC1tYXRyaXgtMi9tYXRoL21hdDMuanNcIjtpbXBvcnR7Y3JlYXRlIGFzIGN9ZnJvbVwiLi4vLi4vLi4vLi4vY29yZS9saWJzL2dsLW1hdHJpeC0yL2ZhY3Rvcmllcy9tYXQzZjMyLmpzXCI7aW1wb3J0e2kgYXMgaCxvIGFzIGZ9ZnJvbVwiLi4vLi4vLi4vLi4vY2h1bmtzL3ZlYzMyLmpzXCI7aW1wb3J0e2NyZWF0ZSBhcyBwfWZyb21cIi4uLy4uLy4uLy4uL2NvcmUvbGlicy9nbC1tYXRyaXgtMi9mYWN0b3JpZXMvdmVjM2YzMi5qc1wiO2ltcG9ydHt0aWxlU2l6ZSBhcyBkfWZyb21cIi4vZGVmaW5pdGlvbnMuanNcIjtpbXBvcnR7VGlsZWREaXNwbGF5T2JqZWN0IGFzIHV9ZnJvbVwiLi9UaWxlZERpc3BsYXlPYmplY3QuanNcIjtjb25zdCB4PWMoKSxNPXAoKTtjbGFzcyBnIGV4dGVuZHMgdXtjb25zdHJ1Y3Rvcih0LHMsaSxyKXtzdXBlcih0LHMsaSxyLGQsZCl9ZGVzdHJveSgpe3N1cGVyLmRlc3Ryb3koKX1zZXRUcmFuc2Zvcm0obSl7Y29uc3QgYz10aGlzLnJlc29sdXRpb24vbS5yZXNvbHV0aW9uLGg9dGhpcy50cmFuc2Zvcm1zLnRpbGVNYXQzLFtmLHBdPW0udG9TY3JlZW5Ob1JvdGF0aW9uKFswLDBdLFt0aGlzLngsdGhpcy55XSksZD10aGlzLndpZHRoL3RoaXMucmFuZ2VYKmMsdT10aGlzLmhlaWdodC90aGlzLnJhbmdlWSpjO3IoaCxkLDAsMCwwLHUsMCxmLHAsMSksbyh0aGlzLnRyYW5zZm9ybXMuZGlzcGxheVZpZXdTY3JlZW5NYXQzLG0uZGlzcGxheVZpZXdNYXQzLGgpO2NvbnN0IHg9dChpKCksZCwwLDAsdSxmLHApO3ModGhpcy50cmFuc2Zvcm1zLmxhYmVsTWF0MmQsbS52aWV3TWF0MmQseCk7Y29uc3QgTT1bMCwwXTttLnRvU2NyZWVuKE0sW3RoaXMueCx0aGlzLnldKTtjb25zdCBnPXRoaXMudHJhbnNmb3Jtcy50aWxlVW5pdHNUb1BpeGVscztlKGcpLGEoZyxnLE0pLG4oZyxnLE1hdGguUEkqbS5yb3RhdGlvbi8xODApLGwoZyxnLFtkLHUsMV0pfV9jcmVhdGVUcmFuc2Zvcm1zKCl7cmV0dXJue2xhYmVsTWF0MmQ6aSgpLHRpbGVNYXQzOmMoKSxkaXNwbGF5Vmlld1NjcmVlbk1hdDM6YygpLHRpbGVVbml0c1RvUGl4ZWxzOmMoKX19Y29udGFpbnNTY3JlZW5Qb2ludCh0LHMsaSl7Y29uc3Qgcj1vKHgsdC52aWV3TWF0Myx0aGlzLnRyYW5zZm9ybXMudGlsZU1hdDMpLGU9bSh4LHIpO2lmKG51bGw9PWUpcmV0dXJuITA7aChNLC4uLnMsMSk7Y29uc3QgYT1mKE0sTSxlKSxuPWkqKHRoaXMucmVzb2x1dGlvbi90LnJlc29sdXRpb24pO3JldHVybiBhWzBdPj0tbiYmYVswXTx0aGlzLndpZHRoK24mJmFbMV0+PS1uJiZhWzFdPHRoaXMuaGVpZ2h0K259fWV4cG9ydHtnIGFzIEFGZWF0dXJlVGlsZX07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0IGUgZnJvbVwiLi4vLi4vLi4vLi4vY29yZS9FcnJvci5qc1wiO2ltcG9ydCB0IGZyb21cIi4uLy4uLy4uLy4uL2NvcmUvTG9nZ2VyLmpzXCI7aW1wb3J0e3dhdGNoIGFzIHJ9ZnJvbVwiLi4vLi4vLi4vLi4vY29yZS9yZWFjdGl2ZVV0aWxzLmpzXCI7aW1wb3J0e2NyZWF0ZSBhcyBzfWZyb21cIi4uLy4uLy4uLy4uL2NvcmUvbGlicy9nbC1tYXRyaXgtMi9mYWN0b3JpZXMvbWF0M2YzMi5qc1wiO2ltcG9ydHtEaXNwbGF5T2JqZWN0IGFzIGl9ZnJvbVwiLi4vRGlzcGxheU9iamVjdC5qc1wiO2ltcG9ydCBhIGZyb21cIi4vTWVzaDJELmpzXCI7aW1wb3J0e2NyZWF0ZVNjcmVlbkV4dGVudCBhcyBvfWZyb21cIi4uLy4uL3N1cHBvcnQvY2xpcHBpbmdVdGlscy5qc1wiO2ltcG9ydHtWZXJ0ZXhBcnJheU9iamVjdCBhcyBofWZyb21cIi4uLy4uLy4uL3dlYmdsL1ZlcnRleEFycmF5T2JqZWN0LmpzXCI7Y2xhc3MgYyBleHRlbmRzIGl7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMuX2NsaXA9dCx0aGlzLl9jYWNoZT17fSx0aGlzLnN0YWdlPWUsdGhpcy5faGFuZGxlPXIoKCgpPT50LnZlcnNpb24pLCgoKT0+dGhpcy5faW52YWxpZGF0ZSgpKSksdGhpcy5yZWFkeSgpfXN0YXRpYyBmcm9tQ2xpcEFyZWEoZSx0KXtyZXR1cm4gbmV3IGMoZSx0KX1fZGVzdHJveUdMKCl7bnVsbCE9dGhpcy5fY2FjaGUubWVzaCYmKHRoaXMuX2NhY2hlLm1lc2guZGVzdHJveSgpLHRoaXMuX2NhY2hlLm1lc2g9bnVsbCksbnVsbCE9dGhpcy5fY2FjaGUudmFvJiYodGhpcy5fY2FjaGUudmFvLmRpc3Bvc2UoKSx0aGlzLl9jYWNoZS52YW89bnVsbCl9ZGVzdHJveSgpe3RoaXMuX2Rlc3Ryb3lHTCgpLHRoaXMuX2hhbmRsZS5yZW1vdmUoKX1nZXRWQU8oZSx0LHIscyl7Y29uc3RbaSxhXT10LnNpemU7aWYoXCJnZW9tZXRyeVwiIT09dGhpcy5fY2xpcC50eXBlJiZ0aGlzLl9sYXN0V2lkdGg9PT1pJiZ0aGlzLl9sYXN0SGVpZ2h0PT09YXx8KHRoaXMuX2xhc3RXaWR0aD1pLHRoaXMuX2xhc3RIZWlnaHQ9YSx0aGlzLl9kZXN0cm95R0woKSksbnVsbD09dGhpcy5fY2FjaGUudmFvKXtjb25zdCBpPXRoaXMuX2NyZWF0ZU1lc2godCx0aGlzLl9jbGlwKSxhPWkuZ2V0SW5kZXhCdWZmZXIoZSksbz1pLmdldFZlcnRleEJ1ZmZlcnMoZSk7dGhpcy5fY2FjaGUubWVzaD1pLHRoaXMuX2NhY2hlLnZhbz1uZXcgaChlLHIscyxvLGEpfXJldHVybiB0aGlzLl9jYWNoZS52YW99X2NyZWF0ZVRyYW5zZm9ybXMoKXtyZXR1cm57ZGlzcGxheVZpZXdTY3JlZW5NYXQzOnMoKX19X2ludmFsaWRhdGUoKXt0aGlzLl9kZXN0cm95R0woKSx0aGlzLnJlcXVlc3RSZW5kZXIoKX1fY3JlYXRlTWVzaChyLHMpe3N3aXRjaChzLnR5cGUpe2Nhc2VcInJlY3RcIjpyZXR1cm4gYS5mcm9tU2NyZWVuRXh0ZW50KG8ocyxyLnNpemVbMF0sci5zaXplWzFdKSk7Y2FzZVwicGF0aFwiOnJldHVybiBhLmZyb21QYXRoKHMpO2Nhc2VcImdlb21ldHJ5XCI6cmV0dXJuIGEuZnJvbUdlb21ldHJ5KHIscyk7ZGVmYXVsdDpyZXR1cm4gdC5nZXRMb2dnZXIoXCJlc3JpLnZpZXdzLjJkLmVuZ2luZS53ZWJnbC5DbGlwcGluZ0luZm9cIikuZXJyb3IobmV3IGUoXCJtYXB2aWV3LWJhZC10eXBlXCIsXCJVbmFibGUgdG8gY3JlYXRlIENsaXBwaW5nSW5mbyBtZXNoIGZyb20gY2xpcCBvZiB0eXBlOiAke2NsaXAudHlwZX1cIikpLGEuZnJvbVNjcmVlbkV4dGVudCh7eG1pbjowLHltaW46MCx4bWF4OjEseW1heDoxfSl9fX1leHBvcnR7YyBhcyBkZWZhdWx0fTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjMzL2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnRcIi4uLy4uLy4uLy4uL2NvcmUvaGFzLmpzXCI7aW1wb3J0e0ZlYXR1cmVCYXRjaGluZ1N0cmF0ZWd5IGFzIHQsRmVhdHVyZVN5bWJvbG9neURyYXdPcmRlciBhcyBlfWZyb21cIi4vZW51bXMuanNcIjtpbXBvcnR7TGlzdCBhcyBufWZyb21cIi4vY3B1TWFwcGVkL0ZyZWVMaXN0LmpzXCI7aW1wb3J0e2lzSGl0dGVzdCBhcyBpfWZyb21cIi4vc2hhZGVyR3JhcGgvdGVjaG5pcXVlcy9mZWF0dXJlVGVjaG5pcXVlVXRpbHMuanNcIjtpbXBvcnR7UHJpbWl0aXZlVHlwZSBhcyBhLERhdGFUeXBlIGFzIHN9ZnJvbVwiLi4vLi4vLi4vd2ViZ2wvZW51bXMuanNcIjtmdW5jdGlvbiByKHQsZSl7cmV0dXJuIHQ8PDE2fDI1NSZlfWZ1bmN0aW9uIGQodCl7cmV0dXJuIDI1NSZ0fWNsYXNzIGh7Y29uc3RydWN0b3IodCxlLG4saSxhKXt0aGlzLmluc3RhbmNlPXQsdGhpcy5tYXRlcmlhbEtleT1lLHRoaXMudGFyZ2V0PW4sdGhpcy5zdGFydD1pLHRoaXMuY291bnQ9YX1nZXQgdGV4dHVyZUtleSgpe3JldHVybiBkKHRoaXMubWF0ZXJpYWxLZXkpfWdldCBpbmRleEVuZCgpe3JldHVybiB0aGlzLnN0YXJ0K3RoaXMuY291bnR9ZXh0ZW5kKHQpe3RoaXMuY291bnQrPXR9cmVuZGVyKHQpe3RoaXMuaW5zdGFuY2UudGVjaG5pcXVlUmVmLnJlbmRlcih0LHRoaXMpfWdldCBrZXkoKXtyZXR1cm4gdGhpcy50YXJnZXQua2V5fWdldFN0ZW5jaWxSZWZlcmVuY2UoKXtyZXR1cm4gdGhpcy50YXJnZXQuc3RlbmNpbFJlZn1nZXRBdHRyaWJ1dGVQcmVjaXNpb25QYWNrRmFjdG9ycygpe2NvbnN0IHQ9dGhpcy5pbnN0YW5jZS5pbnN0YW5jZUlkO3JldHVybiB0aGlzLnRhcmdldC5nZXRNZXNoKHQpLmdldEF0dHJpYnV0ZVByZWNpc2lvblBhY2tGYWN0b3JzKCl9ZHJhdyh0LGUpe2kodCk/dGhpcy5kcmF3Q29tcHV0ZSh0LmNvbnRleHQsZSk6dGhpcy5kcmF3R2VvbWV0cnkodC5jb250ZXh0LGUpfWRyYXdDb21wdXRlKHQsZSl7Y29uc3Qgbj10aGlzLmluc3RhbmNlLmluc3RhbmNlSWQsaT10aGlzLnRhcmdldC5nZXRNZXNoKG4pLmdldENvbXB1dGVWQU8odCxlKSxyPXRoaXMuc3RhcnQqVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQvMzt0LmJpbmRWQU8oaSksdC5kcmF3RWxlbWVudHMoYS5QT0lOVFMsdGhpcy5jb3VudC8zLHMuVU5TSUdORURfSU5ULHIpLHQuYmluZFZBTyhudWxsKX1kcmF3R2VvbWV0cnkodCxlKXtjb25zdCBuPXRoaXMuaW5zdGFuY2UuaW5zdGFuY2VJZCxpPXRoaXMudGFyZ2V0LmdldE1lc2gobikuZ2V0R2VvbWV0cnlWQU8odCxlKSxyPXRoaXMuc3RhcnQqVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7dC5iaW5kVkFPKGkpLHQuZHJhd0VsZW1lbnRzKGEuVFJJQU5HTEVTLHRoaXMuY291bnQscy5VTlNJR05FRF9JTlQsciksdC5iaW5kVkFPKG51bGwpfX1jbGFzcyBse2NvbnN0cnVjdG9yKCl7dGhpcy5fbGVuZ3RoPTAsdGhpcy5fbWluT3JkZXJlZExlbmd0aD0wLHRoaXMuX21hdGVyaWFsS2V5cz1uZXcgU2V0fXN0YXRpYyBmcm9tRGlzcGxheUVudGl0aWVzKHQsZSxuLGkpe2NvbnN0IGE9bmV3IGw7Zm9yKGNvbnN0IHMgb2YgdC52YWx1ZXMoKSlmb3IoY29uc3QgdCBvZiBzLnJlY29yZHMpe2NvbnN0IHM9bi5nZXRJbnN0YW5jZSh0Lmluc3RhbmNlSWQpLGQ9cihzLmluc3RhbmNlSWQsdC50ZXh0dXJlS2V5KTthLmFkZFJlY29yZChzLGQsdC5pbmRleFN0YXJ0LHQuaW5kZXhDb3VudCx0LnZlcnRleFN0YXJ0LHQudmVydGV4Q291bnQsZSxpKX1yZXR1cm4gYX1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuX2xlbmd0aH1nZXQgbWluT3JkZXJlZExlbmd0aCgpe3JldHVybiB0aGlzLl9taW5PcmRlcmVkTGVuZ3RofWdldCBtaW5Vbm9yZGVyZWRMZW5ndGgoKXtyZXR1cm4gdGhpcy5fbWF0ZXJpYWxLZXlzLnNpemV9cmVuZGVyKHQsZSl7Y29uc3R7ZHJhd1BoYXNlOm59PXQ7Zm9yKGNvbnN0IGkgb2YgdGhpcy5pbmZvcygpKXtjb25zdCBhPWkuaW5zdGFuY2UudGVjaG5pcXVlUmVmO2EuZHJhd1BoYXNlJm4mJihudWxsPT1lfHxhLnR5cGU9PT1lKSYmaS5yZW5kZXIodCl9fWFkZFJlY29yZChpLGEscyxyLGQsbCxvLGMpe2xldCB1PXMsXz1yO2lmKF98fCh1PWQsXz1sKSwhXylyZXR1cm47aWYobnVsbD09dGhpcy5faGVhZCl7Y29uc3QgdD1uZXcgaChpLGEsbyx1LF8pO3JldHVybiB0aGlzLl9oZWFkPW5ldyBuKHQpLHRoaXMuX3RhaWw9dGhpcy5faGVhZCx0aGlzLl9sZW5ndGgrKyx2b2lkIHRoaXMuX21pbk9yZGVyZWRMZW5ndGgrK31pZihjPT09dC5TVFJJQ1RfT1JERVIpcmV0dXJuIHRoaXMuX2luc2VydChpLGEsbyx1LF8sdGhpcy5fdGFpbCxudWxsKTtsZXQgZz1udWxsLG09dGhpcy5faGVhZDtjb25zdCBmPWkuaW5zdGFuY2VJZCx5PWkudGVjaG5pcXVlUmVmLnN5bWJvbG9neVBsYW5lO2lmKGM9PT10LlNUUklDVF9NQVJLRVJTX0FORF9URVhUJiYoeT09PWUuTUFSS0VSfHx5PT09ZS5URVhUKSlyZXR1cm4gdGhpcy5faW5zZXJ0KGksYSxvLHUsXyx0aGlzLl90YWlsLG51bGwpO2Zvcig7bTspe2NvbnN0IHQ9bS5kYXRhLmluc3RhbmNlLGU9dC5pbnN0YW5jZUlkLG49dC50ZWNobmlxdWVSZWYuc3ltYm9sb2d5UGxhbmUscz1nPy5kYXRhLmluc3RhbmNlLmluc3RhbmNlSWQ7aWYoeTxufHxmPT09cyYmZiE9PWUpcmV0dXJuIHRoaXMuX2luc2VydChpLGEsbyx1LF8sZyxtKTtnPW0sbT1tLm5leHR9dGhpcy5faW5zZXJ0KGksYSxvLHUsXyxnLG51bGwpfSppbmZvcygpe2lmKG51bGwhPXRoaXMuX2hlYWQpZm9yKGNvbnN0IHQgb2YgdGhpcy5faGVhZC52YWx1ZXMoKSl5aWVsZCB0fV9pbnNlcnQodCxlLGksYSxzLHIsZCl7aWYobnVsbD09ciYmbnVsbD09ZCl7Y29uc3Qgcj1uZXcgaCh0LGUsaSxhLHMpO3JldHVybiB0aGlzLl9oZWFkPW5ldyBuKHIpLHRoaXMuX3RhaWw9dGhpcy5faGVhZCx0aGlzLl9sZW5ndGgrKyx2b2lkIHRoaXMuX21pbk9yZGVyZWRMZW5ndGgrK31yZXR1cm4gZSE9PXRoaXMuX3RhaWwuZGF0YS5tYXRlcmlhbEtleSYmdGhpcy5fbWluT3JkZXJlZExlbmd0aCsrLHRoaXMuX21hdGVyaWFsS2V5cy5hZGQoZSksbnVsbD09ciYmbnVsbCE9ZD90aGlzLl9pbnNlcnRBdEhlYWQodCxlLGksYSxzLGQpOm51bGwhPXImJm51bGw9PWQ/dGhpcy5faW5zZXJ0QXRFbmQodCxlLGksYSxzLHIpOm51bGwhPXImJm51bGwhPWQ/dGhpcy5faW5zZXJ0QXRNaWRkbGUodCxlLGksYSxzLHIsZCk6dm9pZCAwfV9pbnNlcnRBdEhlYWQodCxlLGksYSxzLHIpe2NvbnN0IGQ9YStzO2lmKGU9PT1yLmRhdGEubWF0ZXJpYWxLZXkmJmk9PT1yLmRhdGEudGFyZ2V0JiZkPT09ci5kYXRhLnN0YXJ0KXIuZGF0YS5zdGFydD1hLHIuZGF0YS5jb3VudCs9cztlbHNle2NvbnN0IGQ9bmV3IGgodCxlLGksYSxzKTt0aGlzLl9oZWFkPW5ldyBuKGQpLHRoaXMuX2hlYWQubmV4dD1yLHRoaXMuX2xlbmd0aCsrfX1faW5zZXJ0QXRFbmQodCxlLGksYSxzLHIpe2lmKHIuZGF0YS5tYXRlcmlhbEtleT09PWUmJnIuZGF0YS5pbmRleEVuZD09PWEpci5kYXRhLmNvdW50Kz1zO2Vsc2V7Y29uc3QgZD1uZXcgaCh0LGUsaSxhLHMpO3RoaXMuX3RhaWw9bmV3IG4oZCksci5uZXh0PXRoaXMuX3RhaWwsdGhpcy5fbGVuZ3RoKyt9fV9pbnNlcnRBdE1pZGRsZSh0LGUsaSxhLHMscixkKXtjb25zdCBsPWErcztpZihyLmRhdGEubWF0ZXJpYWxLZXk9PT1lJiZyLmRhdGEudGFyZ2V0PT09aSYmci5kYXRhLmluZGV4RW5kPT09YSlyLmRhdGEuY291bnQrPXMsci5kYXRhLm1hdGVyaWFsS2V5PT09ZC5kYXRhLm1hdGVyaWFsS2V5JiZyLmRhdGEudGFyZ2V0PT09ZC5kYXRhLnRhcmdldCYmci5kYXRhLmluZGV4RW5kPT09ZC5kYXRhLnN0YXJ0JiYoci5kYXRhLmNvdW50Kz1kLmRhdGEuY291bnQsci5uZXh0PWQubmV4dCx0aGlzLl9sZW5ndGgtLSk7ZWxzZSBpZihlPT09ZC5kYXRhLm1hdGVyaWFsS2V5JiZpPT09ZC5kYXRhLnRhcmdldCYmbD09PWQuZGF0YS5zdGFydClkLmRhdGEuc3RhcnQ9YSxkLmRhdGEuY291bnQrPXM7ZWxzZXtjb25zdCBsPW5ldyBoKHQsZSxpLGEscyksbz1uZXcgbihsKTtyLm5leHQ9byxvLm5leHQ9ZCx0aGlzLl9sZW5ndGgrK319fWV4cG9ydHtsIGFzIERpc3BsYXlMaXN0LGggYXMgRGlzcGxheUxpc3RJbmZvfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjMzL2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnQgaGFzIGZyb21cIi4uLy4uLy4uLy4uL2NvcmUvaGFzLmpzXCI7aW1wb3J0IGUgZnJvbVwiLi4vLi4vLi4vLi4vY29yZS9Mb2dnZXIuanNcIjtpbXBvcnR7Y3JlYXRlIGFzIHR9ZnJvbVwiLi4vLi4vLi4vLi4vY29yZS9saWJzL2dsLW1hdHJpeC0yL2ZhY3Rvcmllcy9tYXQyZGYzMi5qc1wiO2ltcG9ydHtjcmVhdGUgYXMgc31mcm9tXCIuLi8uLi8uLi8uLi9jb3JlL2xpYnMvZ2wtbWF0cml4LTIvZmFjdG9yaWVzL21hdDNmMzIuanNcIjtpbXBvcnR7QUZlYXR1cmVUaWxlIGFzIGl9ZnJvbVwiLi9BRmVhdHVyZVRpbGUuanNcIjtpbXBvcnR7UkVTSFVGRkxJTkdfRVhFTVBUX01FTU9SWV9CWVRFUyBhcyByLFJFU0hVRkZMSU5HX1RBUkdFVF9NRU1PUllfRUZGSUNJRU5DWSBhcyBvLFJFU0hVRkZMSU5HX0VYRU1QVF9EUkFXX0NBTExTIGFzIGQsUkVTSFVGRkxJTkdfVEFSR0VUX0RSQVdfRUZGSUNJRU5DWSBhcyBuLHRpbGVTaXplIGFzIGh9ZnJvbVwiLi9kZWZpbml0aW9ucy5qc1wiO2ltcG9ydCBhIGZyb21cIi4vRGlzcGxheUVudGl0eS5qc1wiO2ltcG9ydHtGZWF0dXJlQmF0Y2hpbmdTdHJhdGVneSBhcyBsfWZyb21cIi4vZW51bXMuanNcIjtpbXBvcnR7RGlzcGxheUxpc3QgYXMgY31mcm9tXCIuL0ZlYXR1cmVEaXNwbGF5TGlzdC5qc1wiO2ltcG9ydHtSZXNodWZmbGVQbGFuIGFzIGZ9ZnJvbVwiLi9SZXNodWZmbGVQbGFuLmpzXCI7aW1wb3J0e0xhYmVsTWV0cmljIGFzIHV9ZnJvbVwiLi9jb2xsaXNpb25zL0xhYmVsTWV0cmljLmpzXCI7aW1wb3J0e01hcHBlZE1lc2ggYXMgX31mcm9tXCIuL2NwdU1hcHBlZC9NYXBwZWRNZXNoLmpzXCI7aW1wb3J0e2RlYnVnTWVzaERhdGFJbmZvIGFzIG19ZnJvbVwiLi9tZXNoL21lc2hEZWJ1Z1V0aWxzLmpzXCI7aW1wb3J0IHAgZnJvbVwiLi91dGlsL1JlYWRlci5qc1wiO2ltcG9ydHtkZXNlcmlhbGl6ZUxpc3QgYXMgeX1mcm9tXCIuL3V0aWwvc2VyaWFsaXphdGlvblV0aWxzLmpzXCI7Y29uc3QgYj0oKT0+ZS5nZXRMb2dnZXIoXCJlc3JpLnZpZXdzLjJkLmVuZ2luZS53ZWJnbC5GZWF0dXJlVGlsZVwiKTtsZXQgZz0wO2NsYXNzIEkgZXh0ZW5kcyBpe2NvbnN0cnVjdG9yKGUsaSxyLG8sZCxuLGg9ITEpe3N1cGVyKGUsaSxyLG8pLHRoaXMuX2ZhZGVyPWQsdGhpcy5fbGFiZWxJbnN0YW5jZUlkPW4sdGhpcy5fbWVzaGVzPW5ldyBNYXAsdGhpcy5fZW50aXRpZXM9W10sdGhpcy5fZW50aXR5SW5kZXg9bmV3IE1hcCx0aGlzLl9pbnZhbGlkYXRlZD0hMSx0aGlzLl9uZXh0VXBsb2FkQWxsb3dlZD0hMSx0aGlzLnRpbGVBZ2U9ZysrLHRoaXMuX21ldHJpY3M9W10sdGhpcy5fbWV0cmljc1Zpc2liaWxpdHk9bmV3IFNldCx0aGlzLl9lbnRpdHlJZHM9bmV3IFNldCx0aGlzLl9lbnRpdHlJZHNGcm9tQnVmZmVyPW5ldyBTZXQsdGhpcy5fYXR0cmlidXRlRXBvY2g9MCx0aGlzLl9lbmNvdW50ZXJlZEVuZD0hMSx0aGlzLm5lZWRlZEZvckNvdmVyYWdlPSExLHRoaXMuaXNDb3ZlcmFnZT0hMSx0aGlzLnJlbmRlcmluZz0hMSx0aGlzLl9kZWNsdXR0ZXJlZD0hMSx0aGlzLl9vYmplY3RJZE1hcD1udWxsLHRoaXMudmlzaWJsZT0hMCx0aGlzLnRyYW5zZm9ybXMubGFiZWxNYXQyZD10KCksdGhpcy50cmFuc2Zvcm1zLnRpbGVVbml0c1RvUGl4ZWxzPXMoKSx0aGlzLmVuYWJsZURlZmVycmVkVXBsb2Fkcz1ofWRlc3Ryb3koKXtzdXBlci5kZXN0cm95KCksdGhpcy5jbGVhcigpfWNsZWFyKCl7Zm9yKGNvbnN0IGUgb2YgdGhpcy5fbWVzaGVzLnZhbHVlcygpKWUuZGVzdHJveSgpO3RoaXMuX21lc2hlcy5jbGVhcigpLHRoaXMuX2VudGl0aWVzPVtdLHRoaXMuX2ZhZGVyPy5yZW1vdmVGZWF0dXJlVGlsZU1ldHJpY3ModGhpcyx0aGlzLl9tZXRyaWNzKSx0aGlzLl9tZXRyaWNzPVtdLHRoaXMuX2Rpc3BsYXlMaXN0PW51bGwsdGhpcy5faW52YWxpZGF0ZWQ9ITAsdGhpcy5fZW50aXR5SWRzLmNsZWFyKCksdGhpcy5fbmV4dFVwbG9hZEFsbG93ZWQ9ITB9YmVmb3JlUmVuZGVyKGUpe3N1cGVyLmJlZm9yZVJlbmRlcihlKSx0aGlzLl9uZWVkc1Jlc2h1ZmZsZSYmZS5yZXNodWZmbGVNYW5hZ2VyLnNjaGVkdWxlKHRoaXMpfXRyeVJlYWR5KGUpe2NvbnN0IHQ9dGhpcy5faW52YWxpZGF0ZWQmJiF0aGlzLl91cGxvYWRBbGxvd2VkO3JldHVybiEodGhpcy5pc1JlYWR5fHx0fHwhdGhpcy5fZW5jb3VudGVyZWRFbmR8fCEoZT49dGhpcy5fYXR0cmlidXRlRXBvY2gpKSYmKGhhcyhcImVzcmktMmQtdXBkYXRlLWRlYnVnXCIpJiZjb25zb2xlLmRlYnVnKGBUaWxlWyR7dGhpcy5rZXkuaWR9XSBGZWF0dXJlVGlsZS5yZWFkeSBbZXBvY2g9JHtlfV1gKSx0aGlzLnJlYWR5KCksdGhpcy5yZXF1ZXN0UmVuZGVyKCksdGhpcy5kZWNsdXR0ZXJlZD0hMSwhMCl9Z2V0IHN5bWJvbHMoKXtjb25zdCBlPW5ldyBNYXA7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fbWV0cmljcyllLmdldCh0LmxhYmVsQ2xhc3NJZCl8fGUuc2V0KHQubGFiZWxDbGFzc0lkLFtdKSxlLmdldCh0LmxhYmVsQ2xhc3NJZCkucHVzaCh0KTtyZXR1cm4gZX1nZXQgZGVjbHV0dGVyZWQoKXtyZXR1cm4gdGhpcy5fZGVjbHV0dGVyZWR9c2V0IGRlY2x1dHRlcmVkKGUpe3RoaXMuX2RlY2x1dHRlcmVkPWUsdGhpcy5yZXF1ZXN0UmVuZGVyKCl9Z2V0IGlkKCl7cmV0dXJuIHRoaXMua2V5LmlkfWdldCBoYXNEYXRhKCl7cmV0dXJuISF0aGlzLl9tZXNoZXMuc2l6ZX1nZXQgaGFzQW5pbWF0aW9ucygpe3JldHVybiEhdGhpcy5fb2JqZWN0SWRNYXB9Z2V0IG5lZWRzVXBsb2FkKCl7cmV0dXJuIHRoaXMuX2ludmFsaWRhdGVkfWdldCBfdXBsb2FkQWxsb3dlZCgpe3JldHVybiF0aGlzLmVuYWJsZURlZmVycmVkVXBsb2Fkc3x8dGhpcy5fbmV4dFVwbG9hZEFsbG93ZWR9Z2V0IF9oYXNNZXRyaWNzKCl7cmV0dXJuIHRoaXMuX21ldHJpY3MubGVuZ3RoPjB9dXBsb2FkKCl7dGhpcy5fbmV4dFVwbG9hZEFsbG93ZWQ9ITB9Z2V0RGlzcGxheUxpc3QoZSx0KXtpZih0aGlzLl91cGxvYWRBbGxvd2VkJiZ0aGlzLl9pbnZhbGlkYXRlZCl7dGhpcy5fZW50aXRpZXMuc29ydCgoKGUsdCk9Pntjb25zdCBzPXQuc29ydEtleSxpPWUuc29ydEtleTtyZXR1cm4gaT09PXM/ZS5pZC10LmlkOmktc30pKSx0PT09bC5CQVRDSElORyYmdGhpcy5yZXNodWZmbGUoITApLHRoaXMuX2Rpc3BsYXlMaXN0PWMuZnJvbURpc3BsYXlFbnRpdGllcyh0aGlzLl9lbnRpdGllcyx0aGlzLGUsdCk7Zm9yKGNvbnN0IGUgb2YgdGhpcy5fbWVzaGVzLnZhbHVlcygpKWUudXBsb2FkKCk7dGhpcy5kZWJ1Z0luZm8uZGlzcGxheS5sZW5ndGg9dGhpcy5fZGlzcGxheUxpc3QubGVuZ3RoLHRoaXMuZGVidWdJbmZvLmRpc3BsYXkubWluT3JkZXJlZExlbmd0aD10aGlzLl9kaXNwbGF5TGlzdC5taW5PcmRlcmVkTGVuZ3RoLHRoaXMuZGVidWdJbmZvLmRpc3BsYXkubWluVW5vcmRlcmVkTGVuZ3RoPXRoaXMuX2Rpc3BsYXlMaXN0Lm1pblVub3JkZXJlZExlbmd0aCx0aGlzLnJlcXVlc3RSZW5kZXIoKSx0aGlzLl9pbnZhbGlkYXRlZD0hMSx0aGlzLl9uZXh0VXBsb2FkQWxsb3dlZD0hMX1yZXR1cm4gdGhpcy5fZGlzcGxheUxpc3R9Z2V0TWVzaChlKXtpZighdGhpcy5fbWVzaGVzLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsRXJyb3I6IFVuYWJsZSB0byBmaW5kIFZBTyBmb3IgaW5zdGFuY2U6ICR7ZX1gKTtyZXR1cm4gdGhpcy5fbWVzaGVzLmdldChlKX1nZXRTb3J0S2V5cyhlKXtjb25zdCB0PW5ldyBNYXA7Zm9yKGNvbnN0e2lkOnMsc29ydEtleTppfW9mIHRoaXMuX2VudGl0aWVzKWlmKGUuaGFzKHMpJiZ0LnNldChzLGkpLHQuc2l6ZT09PWUuc2l6ZSlicmVhaztyZXR1cm4gdH1vbk1lc3NhZ2UoZSl7aWYoZS5vYmplY3RJZE1hcClmb3IoY29uc3QgdCBpbiBlLm9iamVjdElkTWFwKXRoaXMuX29iamVjdElkTWFwfHwodGhpcy5fb2JqZWN0SWRNYXA9e30pLHRoaXMuX29iamVjdElkTWFwW3RdPWUub2JqZWN0SWRNYXBbdF07c3dpdGNoKGUudHlwZSl7Y2FzZVwiYXBwZW5kXCI6dGhpcy5fb25BcHBlbmRNZXNzYWdlKGUpO2JyZWFrO2Nhc2VcInVwZGF0ZVwiOnRoaXMuX29uVXBkYXRlTWVzc2FnZShlKX1pZih0aGlzLl9hZ2dyZWdhdGVNZW1vcnlTdGF0cygpLHRoaXMucmVxdWVzdFJlbmRlcigpLGUuZW5kKXtpZihoYXMoXCJlc3JpLTJkLXVwZGF0ZS1kZWJ1Z1wiKSYmY29uc29sZS5kZWJ1ZyhgVGlsZVske3RoaXMua2V5LmlkfV0gRmVhdHVyZVRpbGUuZW5kIFtlcG9jaD0ke2UuYXR0cmlidXRlRXBvY2h9XWApLCFlLmF0dHJpYnV0ZUVwb2NoKXRocm93IG5ldyBFcnJvcihcIkludGVybmFsRXJyb3I6IEF0dHJpYnV0ZSBlcG9jaCBub3QgZGVmaW5lZC5cIik7dGhpcy5fYXR0cmlidXRlRXBvY2g9ZS5hdHRyaWJ1dGVFcG9jaCx0aGlzLl9lbmNvdW50ZXJlZEVuZD0hMH10aGlzLl93cml0ZUxhYmVsVmlzaWJpbGl0eVRvTWVzaCgpfV9vbkFwcGVuZE1lc3NhZ2UoZSl7aWYoaGFzKFwiZXNyaS0yZC11cGRhdGUtZGVidWdcIikmJmNvbnNvbGUuZGVidWcoYFRpbGVbJHt0aGlzLmtleS5pZH1dIEZlYXR1cmVUaWxlLmFwcGVuZGAse2FwcGVuZDptKGU/LmFwcGVuZCl9KSxlLmNsZWFyJiZ0aGlzLmNsZWFyKCksIWUuYXBwZW5kKXJldHVybjtjb25zdCB0PXkobmV3IHAoZS5hcHBlbmQuZW50aXRpZXMpLGEpO3RoaXMuX2luc2VydCh0LGUuYXBwZW5kLmRhdGEsITEpfV9vblVwZGF0ZU1lc3NhZ2UoZSl7aGFzKFwiZXNyaS0yZC11cGRhdGUtZGVidWdcIikmJmNvbnNvbGUuZGVidWcoYFRpbGVbJHt0aGlzLmtleS5pZH1dIEZlYXR1cmVUaWxlLnVwZGF0ZWAse2lzUGl4ZWxCdWZmZXI6ZS5pc1BpeGVsQnVmZmVyLG1vZGlmeTptKGUubW9kaWZ5KSxyZW1vdmU6ZS5yZW1vdmV9KTtjb25zdCB0PXkobmV3IHAoZS5tb2RpZnkuZW50aXRpZXMpLGEpLHM9dC5tYXAoKGU9PmUuaWQpKSxpPWUuaXNQaXhlbEJ1ZmZlcj8/ITEscj1bLi4uZS5yZW1vdmUsLi4uc107aT90aGlzLl9yZW1vdmVCeUlkc0Zyb21CdWZmZXIocik6dGhpcy5fcmVtb3ZlQnlJZHMociksdGhpcy5faW5zZXJ0KHQsZS5tb2RpZnkuZGF0YSxpKX1yZXNodWZmbGUoZT0hMSl7aWYodGhpcy5kZXN0cm95ZWQpcmV0dXJuO2NvbnN0IHQ9bmV3IE1hcDtmb3IoY29uc3QgcyBvZiB0aGlzLl9lbnRpdGllcylmb3IoY29uc3QgaSBvZiBzLnJlY29yZHMpe2NvbnN0IHM9dGhpcy5fbWVzaGVzLmdldChpLmluc3RhbmNlSWQpO2xldCByPXQuZ2V0KHMpO3J8fChyPW5ldyBmKGUpLHQuc2V0KHMscikpLHIuY29weVJlY29yZChpKX1mb3IoY29uc3RbcyxpXW9mIHQpcy5yZXNodWZmbGUoaSk7dGhpcy5faW52YWxpZGF0ZWQ9ITAsdGhpcy5fYWdncmVnYXRlTWVtb3J5U3RhdHMoKSxoYXMoXCJlc3JpLTJkLXVwZGF0ZS1kZWJ1Z1wiKSYmYigpLmluZm8oYFRpbGUgJHt0aGlzLmtleS5pZH0gd2FzIHJlc2h1ZmZsZWQuYCl9Y29weVBpeGVsQnVmZmVyZWRFbnRpdGVzRnJvbShlLHQscyxpKXtjb25zdCByPXMqaCxvPWkqaDtmb3IoY29uc3QgZCBvZiBlLl9lbnRpdGllcyl7bGV0IHM9bnVsbDtmb3IoY29uc3QgaSBvZiBkLnJlY29yZHMpaWYoaS5vdmVybGFwcyZ0KXtjb25zdCB0PWUuZ2V0TWVzaChpLmluc3RhbmNlSWQpLG49dGhpcy5fZW5zdXJlTWVzaChpLmluc3RhbmNlSWQsdC5sYXlvdXQsdC51c2VWaXNpYmlsaXR5KS5jb3B5UmVjb3JkRnJvbSh0LGkscixvKTtzfHwocz1uZXcgYShkLmlkLGQuc29ydEtleSksdGhpcy5fZW50aXR5SWRzRnJvbUJ1ZmZlci5hZGQoZC5pZCksdGhpcy5fZW50aXR5SW5kZXguc2V0KHMuaWQscyksdGhpcy5fZW50aXRpZXMucHVzaChzKSkscy5yZWNvcmRzLnB1c2gobil9fXRoaXMuX2ludmFsaWRhdGVkPSEwfWdldCBtZXRyaWNzVmlzaWJpbGl0eSgpe3JldHVybiB0aGlzLl9tZXRyaWNzVmlzaWJpbGl0eX1jb3B5TWV0cmljc1Zpc2liaWxpdHkoZSl7Zm9yKGNvbnN0IHQgb2YgZSl0aGlzLl9tZXRyaWNzVmlzaWJpbGl0eS5hZGQodCk7dGhpcy5fd3JpdGVMYWJlbFZpc2liaWxpdHlUb01lc2goKX11cGRhdGVMYWJlbFZpc2liaWxpdHkoKXt0aGlzLl9tZXRyaWNzVmlzaWJpbGl0eS5jbGVhcigpO2Zvcihjb25zdCBlIG9mIHRoaXMuX21ldHJpY3Mpe2UudW5pcXVlU3ltYm9sLnNob3cmJmUuc2VsZWN0ZWRGb3JSZW5kZXJpbmcmJnRoaXMuX21ldHJpY3NWaXNpYmlsaXR5LmFkZChlLmhhc2gpfXRoaXMuX3dyaXRlTGFiZWxWaXNpYmlsaXR5VG9NZXNoKCl9X3dyaXRlTGFiZWxWaXNpYmlsaXR5VG9NZXNoKCl7Y29uc3QgZT10aGlzLl9tZXNoZXMuZ2V0KHRoaXMuX2xhYmVsSW5zdGFuY2VJZCk7aWYoZSYmdGhpcy5faGFzTWV0cmljcyl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fbWV0cmljcyl7Y29uc3Qgcz10aGlzLl9lbnRpdHlJbmRleC5nZXQodC5pZCk7aWYoIXMpY29udGludWU7Y29uc3QgaT10aGlzLl9tZXRyaWNzVmlzaWJpbGl0eS5oYXModC5oYXNoKTtlLnNldEVudGl0eVJlY29yZFJhbmdlVmlzaWJpbGl0eShzLnJlY29yZHMsdC5yZWNvcmRTdGFydCx0LnJlY29yZENvdW50LGk/MDoyNTUpfXRoaXMuX2ludmFsaWRhdGVkPSEwfX1fZW5zdXJlTWVzaChlLHQscyl7cmV0dXJuIHRoaXMuX21lc2hlcy5oYXMoZSl8fHRoaXMuX21lc2hlcy5zZXQoZSxuZXcgXyh0aGlzLl9zdGFnZS5idWZmZXJQb29sLHQscykpLHRoaXMuX21lc2hlcy5nZXQoZSl9X2luc2VydChlLHQscyl7aWYoIWUubGVuZ3RoKXJldHVybjt0aGlzLl9yZW1vdmVEdXBsaWNhdGVkQnVmZmVyZWRFbnRpdGVzKGUpO2NvbnN0IGk9dGhpcy5faW5zZXJ0VmVydGV4RGF0YSh0KTtmb3IoY29uc3QgciBvZiBlKXtmb3IoY29uc3QgZSBvZiByLnJlY29yZHMpZS51cGRhdGVCYXNlT2Zmc2V0cyhpLmdldChlLmluc3RhbmNlSWQpKTtzP3RoaXMuX3RyeUluc2VydEJ1ZmZlcmVkRW50aXR5KHIpOnRoaXMuX2luc2VydEVudGl0eShyKX10aGlzLl9pbnZhbGlkYXRlZD0hMH1faW5zZXJ0TWV0cmljcyhlKXtmb3IoY29uc3QgdCBvZiBlKXQudGlsZT10aGlzO3RoaXMuX21ldHJpY3MucHVzaCguLi5lKSx0aGlzLl9mYWRlcj8uaW5zZXJ0RmVhdHVyZVRpbGVNZXRyaWNzKHRoaXMsZSl9X2luc2VydFZlcnRleERhdGEoZSl7Y29uc3QgdD1uZXcgTWFwO2Zvcihjb25zdCBzIG9mIGUpe2NvbnN0e2luc3RhbmNlSWQ6ZSxsYXlvdXQ6aX09cyxyPWkuYXR0cmlidXRlcy5zb21lKChlPT5cInZpc2liaWxpdHlcIj09PWUubmFtZSkpLG89dGhpcy5fZW5zdXJlTWVzaChlLGkscikuYXBwZW5kKHMpO2lmKHMubWV0cmljcyl7Y29uc3QgZT15KG5ldyBwKHMubWV0cmljcyksdSk/P1tdO3RoaXMuX2luc2VydE1ldHJpY3MoZSl9dC5zZXQoZSxvKX1yZXR1cm4gdH1faW5zZXJ0RW50aXR5KGUpe2hhcyhcImVzcmktMmQtdXBkYXRlLWRlYnVnXCIpJiZ0aGlzLl9lbnRpdHlJZHMuaGFzKGUuaWQpJiZjb25zb2xlLmVycm9yKGBUaWxlICR7dGhpcy5rZXkuaWR9IGluc2VydEVudGl0eTogQWxyZWFkeSBoYXZlIGVudGl0eUlkICR7ZS5pZH1gKSx0aGlzLl9lbnRpdHlJZHMuYWRkKGUuaWQpLHRoaXMuX2VudGl0eUluZGV4LnNldChlLmlkLGUpLHRoaXMuX2VudGl0aWVzLnB1c2goZSl9X3RyeUluc2VydEJ1ZmZlcmVkRW50aXR5KGUpe3RoaXMuX2VudGl0eUlkcy5oYXMoZS5pZCk/dGhpcy5fcmVtb3ZlUmVjb3Jkc0Zyb21NZXNoKGUucmVjb3Jkcyk6KHRoaXMuX2VudGl0eUlkc0Zyb21CdWZmZXIuYWRkKGUuaWQpLHRoaXMuX2VudGl0eUluZGV4LnNldChlLmlkLGUpLHRoaXMuX2VudGl0aWVzLnB1c2goZSkpfV9yZW1vdmVEdXBsaWNhdGVkQnVmZmVyZWRFbnRpdGVzKGUpe2lmKCF0aGlzLl9lbnRpdHlJZHNGcm9tQnVmZmVyLnNpemUpcmV0dXJuO2NvbnN0IHQ9W107Zm9yKGNvbnN0IHMgb2YgZSl0aGlzLl9lbnRpdHlJZHNGcm9tQnVmZmVyLmhhcyhzLmlkKSYmdC5wdXNoKHMuaWQpO3RoaXMuX3JlbW92ZUJ5SWRzKHQpfV9yZW1vdmVCeUlkc0Zyb21CdWZmZXIoZSl7dGhpcy5fcmVtb3ZlQnlJZHMoZS5maWx0ZXIoKGU9PnRoaXMuX2VudGl0eUlkc0Zyb21CdWZmZXIuaGFzKGUpKSkpfV9yZW1vdmVCeUlkcyhlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuO2NvbnN0IHQ9bmV3IFNldChlKSxzPVtdO2Zvcihjb25zdCByIG9mIHRoaXMuX2VudGl0aWVzKXQuaGFzKHIuaWQpPyh0aGlzLl9yZW1vdmUociksdGhpcy5fZW50aXR5SW5kZXguZGVsZXRlKHIuaWQpKTpzLnB1c2gocik7dGhpcy5fZW50aXRpZXM9cztjb25zdCBpPXRoaXMuX21ldHJpY3MuZmlsdGVyKChlPT50LmhhcyhlLmRpc3BsYXlJZCkpKTt0aGlzLl9tZXRyaWNzPXRoaXMuX21ldHJpY3MuZmlsdGVyKChlPT4hdC5oYXMoZS5kaXNwbGF5SWQpKSksdGhpcy5fZmFkZXI/LnJlbW92ZUZlYXR1cmVUaWxlTWV0cmljcyh0aGlzLGkpLHRoaXMuX2ludmFsaWRhdGVkPSEwfV9yZW1vdmUoZSl7dGhpcy5fcmVtb3ZlUmVjb3Jkc0Zyb21NZXNoKGUucmVjb3JkcyksdGhpcy5fZW50aXR5SWRzLmRlbGV0ZShlLmlkKSx0aGlzLl9lbnRpdHlJZHNGcm9tQnVmZmVyLmRlbGV0ZShlLmlkKX1fcmVtb3ZlUmVjb3Jkc0Zyb21NZXNoKGUpe2Zvcihjb25zdCB0IG9mIGUpe2NvbnN0e2luc3RhbmNlSWQ6ZSxpbmRleFN0YXJ0OnMsaW5kZXhDb3VudDppLHZlcnRleFN0YXJ0OnIsdmVydGV4Q291bnQ6b309dDt0aGlzLl9tZXNoZXMuZ2V0KGUpPy5yZW1vdmUocyxpLHIsbyl9fV9hZ2dyZWdhdGVNZW1vcnlTdGF0cygpe3RoaXMuZGVidWdJbmZvLm1lbW9yeS5ieXRlc1VzZWQ9MCx0aGlzLmRlYnVnSW5mby5tZW1vcnkuYnl0ZXNSZXNlcnZlZD0wO2Zvcihjb25zdCBlIG9mIHRoaXMuX21lc2hlcy52YWx1ZXMoKSl0aGlzLmRlYnVnSW5mby5tZW1vcnkuYnl0ZXNVc2VkKz1lLm1lbW9yeVN0YXRzLmJ5dGVzVXNlZCx0aGlzLmRlYnVnSW5mby5tZW1vcnkuYnl0ZXNSZXNlcnZlZCs9ZS5tZW1vcnlTdGF0cy5ieXRlc1Jlc2VydmVkfWdldCBfbmVlZHNSZXNodWZmbGUoKXtpZih0aGlzLmRlc3Ryb3llZClyZXR1cm4hMTtjb25zdHtieXRlc1VzZWQ6ZSxieXRlc1Jlc2VydmVkOnR9PXRoaXMuZGVidWdJbmZvLm1lbW9yeSxzPWUvdCx7bWluT3JkZXJlZExlbmd0aDppLGxlbmd0aDpofT10aGlzLmRlYnVnSW5mby5kaXNwbGF5O3JldHVybiB0PnImJnM8b3x8aD5kJiZpL2g8bn1nZXQgZW50aXR5SWRzKCl7cmV0dXJuIHRoaXMuX29iamVjdElkTWFwP3RoaXMuX2VudGl0aWVzLm1hcCgoKHtpZDplfSk9Pih7b2JqZWN0SWQ6dGhpcy5fb2JqZWN0SWRNYXBbZV0sZGlzcGxheUlkOmV9KSkpOltdfX1leHBvcnR7SSBhcyBGZWF0dXJlVGlsZX07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0IGUgZnJvbVwiLi4vLi4vLi4vLi4vY29yZS9FcnJvci5qc1wiO2ltcG9ydCByIGZyb21cIi4uLy4uLy4uLy4uL2NvcmUvTG9nZ2VyLmpzXCI7aW1wb3J0e2UgYXMgdH1mcm9tXCIuLi8uLi8uLi8uLi9jaHVua3MvZWFyY3V0LmpzXCI7aW1wb3J0e3NldCBhcyBvfWZyb21cIi4uLy4uLy4uLy4uL2NvcmUvbGlicy9nbC1tYXRyaXgtMi9tYXRoL3ZlYzIuanNcIjtpbXBvcnR7Y3JlYXRlIGFzIG59ZnJvbVwiLi4vLi4vLi4vLi4vY29yZS9saWJzL2dsLW1hdHJpeC0yL2ZhY3Rvcmllcy92ZWMyZjY0LmpzXCI7aW1wb3J0e2NvbnZlcnRGcm9tTmVzdGVkQXJyYXkgYXMgcyxjb252ZXJ0RnJvbVBvbHlnb24gYXMgaX1mcm9tXCIuLi8uLi8uLi8uLi9sYXllcnMvZ3JhcGhpY3MvZmVhdHVyZUNvbnZlcnNpb25VdGlscy5qc1wiO2ltcG9ydCBjIGZyb21cIi4uLy4uLy4uLy4uL2xheWVycy9ncmFwaGljcy9PcHRpbWl6ZWRHZW9tZXRyeS5qc1wiO2ltcG9ydHtpMTYxNnRvMzIgYXMgYX1mcm9tXCIuL251bWJlci5qc1wiO2ltcG9ydHtCdWZmZXJPYmplY3QgYXMgZn1mcm9tXCIuLi8uLi8uLi93ZWJnbC9CdWZmZXJPYmplY3QuanNcIjtpbXBvcnR7UHJpbWl0aXZlVHlwZSBhcyBtLFVzYWdlIGFzIGh9ZnJvbVwiLi4vLi4vLi4vd2ViZ2wvZW51bXMuanNcIjtjb25zdCBsPShlLHIsdCxvKT0+e2xldCBuPTA7Zm9yKGxldCBzPTE7czx0O3MrKyl7Y29uc3QgdD1lWzIqKHIrcy0xKV0sbz1lWzIqKHIrcy0xKSsxXTtuKz0oZVsyKihyK3MpXS10KSooZVsyKihyK3MpKzFdK28pfXJldHVybiBvP24+MDpuPDB9LHU9KHtjb29yZHM6ZSxsZW5ndGhzOnJ9LG8pPT57Y29uc3Qgbj1bXTtmb3IobGV0IHM9MCxpPTA7czxyLmxlbmd0aDtpKz1yW3NdLHMrPTEpe2NvbnN0IGM9aSxhPVtdO2Zvcig7czxyLmxlbmd0aC0xJiZsKGUsaStyW3NdLHJbcysxXSxvKTtzKz0xLGkrPXJbc10pYS5wdXNoKGkrcltzXS1jKTtjb25zdCBmPWUuc2xpY2UoMipjLDIqKGkrcltzXSkpLG09dChmLGEsMik7Zm9yKGNvbnN0IGUgb2YgbSluLnB1c2goZStjKX1yZXR1cm4gbn07Y2xhc3MgeXtjb25zdHJ1Y3RvcihlLHIsdCxvPSExKXt0aGlzLl9jYWNoZT17fSx0aGlzLnZlcnRpY2VzPWUsdGhpcy5pbmRpY2VzPXIsdGhpcy5wcmltaXRpdmVUeXBlPXQsdGhpcy5pc01hcFNwYWNlPW99c3RhdGljIGZyb21QYXRoKGUpe2NvbnN0IHI9cyhuZXcgYyxlLnBhdGgsITEsITEpLHQ9ci5jb29yZHMsbz1uZXcgVWludDMyQXJyYXkodShyLCEwKSksbj1uZXcgVWludDMyQXJyYXkodC5sZW5ndGgvMik7Zm9yKGxldCBzPTA7czxuLmxlbmd0aDtzKyspbltzXT1hKE1hdGguZmxvb3IodFsyKnNdKSxNYXRoLmZsb29yKHRbMipzKzFdKSk7cmV0dXJuIG5ldyB5KHtnZW9tZXRyeTpufSxvLG0uVFJJQU5HTEVTKX1zdGF0aWMgZnJvbUdlb21ldHJ5KHQsbyl7Y29uc3Qgbj1vLmdlb21ldHJ5Py50eXBlO3N3aXRjaChuKXtjYXNlXCJwb2x5Z29uXCI6cmV0dXJuIHkuZnJvbVBvbHlnb24odCxvLmdlb21ldHJ5KTtjYXNlXCJleHRlbnRcIjpyZXR1cm4geS5mcm9tTWFwRXh0ZW50KHQsby5nZW9tZXRyeSk7ZGVmYXVsdDpyZXR1cm4gci5nZXRMb2dnZXIoXCJlc3JpLnZpZXdzLjJkLmVuZ2luZS53ZWJnbC5NZXNoMkRcIikuZXJyb3IobmV3IGUoXCJtYXB2aWV3LWJhZC10eXBlXCIsYFVuYWJsZSB0byBjcmVhdGUgYSBtZXNoIGZyb20gdHlwZSAke259YCxvKSkseS5mcm9tU2NyZWVuRXh0ZW50KHt4bWluOjAseW1pbjowLHhtYXg6MSx5bWF4OjF9KX19c3RhdGljIGZyb21Qb2x5Z29uKGUscil7Y29uc3QgdD1pKG5ldyBjLHIsITEsITEpLHM9dC5jb29yZHMsZj1uZXcgVWludDMyQXJyYXkodSh0LCExKSksaD1uZXcgVWludDMyQXJyYXkocy5sZW5ndGgvMiksbD1uKCkseD1uKCk7Zm9yKGxldCBuPTA7bjxoLmxlbmd0aDtuKyspbyhsLHNbMipuXSxzWzIqbisxXSksZS50b1NjcmVlbih4LGwpLGhbbl09YShNYXRoLmZsb29yKHhbMF0pLE1hdGguZmxvb3IoeFsxXSkpO3JldHVybiBuZXcgeSh7Z2VvbWV0cnk6aH0sZixtLlRSSUFOR0xFUywhMCl9c3RhdGljIGZyb21TY3JlZW5FeHRlbnQoe3htaW46ZSx4bWF4OnIseW1pbjp0LHltYXg6b30pe2NvbnN0IG49e2dlb21ldHJ5Om5ldyBVaW50MzJBcnJheShbYShlLHQpLGEocix0KSxhKGUsbyksYShlLG8pLGEocix0KSxhKHIsbyldKX0scz1uZXcgVWludDMyQXJyYXkoWzAsMSwyLDMsNCw1XSk7cmV0dXJuIG5ldyB5KG4scyxtLlRSSUFOR0xFUyl9c3RhdGljIGZyb21NYXBFeHRlbnQoZSxyKXtjb25zdFt0LG9dPWUudG9TY3JlZW4oWzAsMF0sW3IueG1pbixyLnltaW5dKSxbbixzXT1lLnRvU2NyZWVuKFswLDBdLFtyLnhtYXgsci55bWF4XSksaT17Z2VvbWV0cnk6bmV3IFVpbnQzMkFycmF5KFthKHQsbyksYShuLG8pLGEodCxzKSxhKHQscyksYShuLG8pLGEobixzKV0pfSxjPW5ldyBVaW50MzJBcnJheShbMCwxLDIsMyw0LDVdKTtyZXR1cm4gbmV3IHkoaSxjLG0uVFJJQU5HTEVTKX1kZXN0cm95KCl7bnVsbCE9dGhpcy5fY2FjaGUuaW5kZXhCdWZmZXImJnRoaXMuX2NhY2hlLmluZGV4QnVmZmVyLmRpc3Bvc2UoKSx0aGlzLl9jYWNoZS52ZXJ0ZXhCdWZmZXJzPy5mb3JFYWNoKChlPT5lPy5kaXNwb3NlKCkpKSx0aGlzLl9jYWNoZS5pbmRleEJ1ZmZlcj10aGlzLl9jYWNoZS52ZXJ0ZXhCdWZmZXJzPW51bGx9Z2V0SW5kZXhCdWZmZXIoZSxyPWguU1RBVElDX0RSQVcpe3JldHVybiB0aGlzLl9jYWNoZS5pbmRleEJ1ZmZlcj8/PWYuY3JlYXRlSW5kZXgoZSxyLHRoaXMuaW5kaWNlcyksdGhpcy5fY2FjaGUuaW5kZXhCdWZmZXJ9Z2V0VmVydGV4QnVmZmVycyhlLHI9aC5TVEFUSUNfRFJBVyl7cmV0dXJuIHRoaXMuX2NhY2hlLnZlcnRleEJ1ZmZlcnM/Pz1uZXcgTWFwKE9iamVjdC5rZXlzKHRoaXMudmVydGljZXMpLnJlZHVjZSgoKHQsbyk9Pih0LnB1c2goW28sZi5jcmVhdGVWZXJ0ZXgoZSxyLHRoaXMudmVydGljZXNbb10pXSksdCkpLG5ldyBBcnJheSkpLHRoaXMuX2NhY2hlLnZlcnRleEJ1ZmZlcnN9fWV4cG9ydHt5IGFzIGRlZmF1bHR9O1xuIiwiLypcbkFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMzMvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuKi9cbmltcG9ydCBoYXMgZnJvbVwiLi4vLi4vLi4vLi4vY29yZS9oYXMuanNcIjtpbXBvcnR7YXNzZXJ0SXNTb21lIGFzIHR9ZnJvbVwiLi4vLi4vLi4vLi4vY29yZS9tYXliZS5qc1wiO2ltcG9ydHtGcmVlTGlzdCBhcyBlfWZyb21cIi4vY3B1TWFwcGVkL0ZyZWVMaXN0LmpzXCI7Y29uc3Qgcj1oYXMoXCJlc3JpLTJkLWxvZy1hbGxvY2F0aW9uc1wiKTtjbGFzcyBze3N0YXRpYyBjcmVhdGUodCxlKXtjb25zdCByPWUuYWNxdWlyZVVpbnQzMkFycmF5KHQpO3JldHVybiBuZXcgcyhyLGUpfWNvbnN0cnVjdG9yKHQsZSl7dGhpcy5fYXJyYXk9dCx0aGlzLl9wb29sPWV9Z2V0IGFycmF5KCl7cmV0dXJuIHRoaXMuX2FycmF5fWdldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5fYXJyYXkubGVuZ3RofWdldFVpbnQzMlZpZXcodCxlKXtyZXR1cm4gbmV3IFVpbnQzMkFycmF5KHRoaXMuX2FycmF5LmJ1ZmZlcix0K3RoaXMuX2FycmF5LmJ5dGVPZmZzZXQsZSl9ZXhwYW5kKHQpe2lmKHQ8PXRoaXMuX2FycmF5LmJ5dGVMZW5ndGgpcmV0dXJuO2NvbnN0IGU9dGhpcy5fcG9vbC5hY3F1aXJlVWludDMyQXJyYXkodCk7ZS5zZXQodGhpcy5fYXJyYXkpLHRoaXMuX3Bvb2wucmVsZWFzZVVpbnQzMkFycmF5KHRoaXMuX2FycmF5KSx0aGlzLl9hcnJheT1lfWRlc3Ryb3koKXt0aGlzLl9wb29sLnJlbGVhc2VVaW50MzJBcnJheSh0aGlzLl9hcnJheSl9fWNsYXNzIGF7Y29uc3RydWN0b3IoKXt0aGlzLl9kYXRhPW5ldyBBcnJheUJ1ZmZlcihhLkJZVEVfTEVOR1RIKSx0aGlzLl9mcmVlTGlzdD1uZXcgZSh7c3RhcnQ6MCxlbmQ6dGhpcy5fZGF0YS5ieXRlTGVuZ3RofSl9c3RhdGljIGdldCBCWVRFX0xFTkdUSCgpe3JldHVybiAxNmU2fWdldCBidWZmZXIoKXtyZXR1cm4gdGhpcy5fZGF0YX1hY3F1aXJlVWludDMyQXJyYXkodCl7Y29uc3QgZT10aGlzLl9mcmVlTGlzdC5maXJzdEZpdCh0KTtyZXR1cm4gbnVsbD09ZT9udWxsOm5ldyBVaW50MzJBcnJheSh0aGlzLl9kYXRhLGUsdC9VaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCl9cmVsZWFzZVVpbnQzMkFycmF5KHQpe3RoaXMuX2ZyZWVMaXN0LmZyZWUodC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCl9fWNsYXNzIGl7Y29uc3RydWN0b3IoKXt0aGlzLl9wYWdlcz1bXSx0aGlzLl9wYWdlc0J5QnVmZmVyPW5ldyBNYXAsdGhpcy5fYnl0ZXNBbGxvY2F0ZWQ9MH1kZXN0cm95KCl7dGhpcy5fcGFnZXM9W10sdGhpcy5fcGFnZXNCeUJ1ZmZlcj1udWxsfWdldCBfYnl0ZXNUb3RhbCgpe3JldHVybiB0aGlzLl9wYWdlcy5sZW5ndGgqYS5CWVRFX0xFTkdUSH1hY3F1aXJlVWludDMyQXJyYXkoZSl7aWYodGhpcy5fYnl0ZXNBbGxvY2F0ZWQrPWUsciYmY29uc29sZS5sb2coYEFsbG9jYXRpbmcgJHtlfSwgKCR7dGhpcy5fYnl0ZXNBbGxvY2F0ZWR9IC8gJHt0aGlzLl9ieXRlc1RvdGFsfSlgKSxlPj1hLkJZVEVfTEVOR1RIKXJldHVybiBuZXcgVWludDMyQXJyYXkoZS9VaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fcGFnZXMpe2NvbnN0IHI9dC5hY3F1aXJlVWludDMyQXJyYXkoZSk7aWYobnVsbCE9cilyZXR1cm4gcn1jb25zdCBzPXRoaXMuX2FkZFBhZ2UoKS5hY3F1aXJlVWludDMyQXJyYXkoZSk7cmV0dXJuIHQocyxcIkV4cGVjdGVkIHRvIGFsbG9jYXRlIHBhZ2VcIiksc31yZWxlYXNlVWludDMyQXJyYXkodCl7dGhpcy5fYnl0ZXNBbGxvY2F0ZWQtPXQuYnl0ZUxlbmd0aCxyJiZjb25zb2xlLmxvZyhgRnJlZWluZyAke3QuYnl0ZUxlbmd0aH0sICgke3RoaXMuX2J5dGVzQWxsb2NhdGVkfSAvICR7dGhpcy5fYnl0ZXNUb3RhbH0pYCk7Y29uc3QgZT10aGlzLl9wYWdlc0J5QnVmZmVyLmdldCh0LmJ1ZmZlcik7ZSYmZS5yZWxlYXNlVWludDMyQXJyYXkodCl9X2FkZFBhZ2UoKXtjb25zdCB0PW5ldyBhO3JldHVybiB0aGlzLl9wYWdlcy5wdXNoKHQpLHRoaXMuX3BhZ2VzQnlCdWZmZXIuc2V0KHQuYnVmZmVyLHQpLHR9fWV4cG9ydHtpIGFzIEFycmF5QnVmZmVyUG9vbCxzIGFzIFBvb2xlZFVpbnQzMkFycmF5fTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjMzL2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5jbGFzcyB0e2NvbnN0cnVjdG9yKHQpe3RoaXMuX2luZGV4T25seT10LHRoaXMudmVydGV4PXtjb3VudDowLG9wZXJhdGlvbnM6W119LHRoaXMuaW5kZXg9e2NvdW50OjAsb3BlcmF0aW9uczpbXX19Y29weVJlY29yZCh0KXtsZXQgZT0wO3RoaXMuX2luZGV4T25seXx8KGU9dGhpcy52ZXJ0ZXguY291bnQtdC52ZXJ0ZXhTdGFydCx0aGlzLnZlcnRleC5vcGVyYXRpb25zLnB1c2goe3NyY0Zyb206dC52ZXJ0ZXhTdGFydCxkc3RGcm9tOnRoaXMudmVydGV4LmNvdW50LGNvdW50OnQudmVydGV4Q291bnQsbXV0YXRlOjB9KSx0LnZlcnRleFN0YXJ0PXRoaXMudmVydGV4LmNvdW50LHRoaXMudmVydGV4LmNvdW50Kz10LnZlcnRleENvdW50KTtsZXQgbj0hMTtpZih0aGlzLl9pbmRleE9ubHkmJnRoaXMuaW5kZXgub3BlcmF0aW9ucy5sZW5ndGg+PTEpe2NvbnN0IGU9dGhpcy5pbmRleC5vcGVyYXRpb25zW3RoaXMuaW5kZXgub3BlcmF0aW9ucy5sZW5ndGgtMV07ZS5zcmNGcm9tK2UuY291bnQ9PT10LmluZGV4U3RhcnQmJihlLmNvdW50Kz10LmluZGV4Q291bnQsbj0hMCl9bnx8dGhpcy5pbmRleC5vcGVyYXRpb25zLnB1c2goe3NyY0Zyb206dC5pbmRleFN0YXJ0LGRzdEZyb206dGhpcy5pbmRleC5jb3VudCxjb3VudDp0LmluZGV4Q291bnQsbXV0YXRlOmV9KSx0LmluZGV4U3RhcnQ9dGhpcy5pbmRleC5jb3VudCx0aGlzLmluZGV4LmNvdW50Kz10LmluZGV4Q291bnR9fWV4cG9ydHt0IGFzIFJlc2h1ZmZsZVBsYW59O1xuIiwiLypcbkFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMzMvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuKi9cbmltcG9ydFwiLi4vLi4vLi4vLi4vY29yZS9oYXMuanNcIjtpbXBvcnR7YnJ1c2hlcyBhcyBzfWZyb21cIi4uL2JydXNoZXMuanNcIjtpbXBvcnR7Q29udGFpbmVyIGFzIGV9ZnJvbVwiLi4vQ29udGFpbmVyLmpzXCI7aW1wb3J0IHIgZnJvbVwiLi9DbGlwcGluZ0luZm8uanNcIjtpbXBvcnR7V0dMRHJhd1BoYXNlIGFzIGl9ZnJvbVwiLi9lbnVtcy5qc1wiO2NsYXNzIG4gZXh0ZW5kcyBle3NldCBjbGlwcyhzKXtzdXBlci5jbGlwcz1zLHRoaXMuX3VwZGF0ZUNsaXBwaW5nSW5mbyhzKX1yZW5kZXJDaGlsZHJlbihzKXtzLnBhaW50ZXIuc2V0UGlwZWxpbmVTdGF0ZShudWxsKSxudWxsPT10aGlzLl9yZW5kZXJQYXNzZXMmJih0aGlzLl9yZW5kZXJQYXNzZXM9dGhpcy5wcmVwYXJlUmVuZGVyUGFzc2VzKHMucGFpbnRlcikpO2Zvcihjb25zdCByIG9mIHRoaXMuX3JlbmRlclBhc3Nlcyl0cnl7ci5yZW5kZXIocyl9Y2F0Y2goZSl7fX1wcmVwYXJlUmVuZGVyUGFzc2VzKGUpe3JldHVybltlLnJlZ2lzdGVyUmVuZGVyUGFzcyh7bmFtZTpcImNsaXBcIixicnVzaGVzOltzLmNsaXBdLHRhcmdldDooKT0+dGhpcy5fY2xpcHBpbmdJbmZvcyxkcmF3UGhhc2U6aS5NQVB8aS5MQUJFTHxpLkxBQkVMX0FMUEhBfGkuREVCVUd8aS5ISUdITElHSFR9KV19X3VwZGF0ZUNsaXBwaW5nSW5mbyhzKXtudWxsIT10aGlzLl9jbGlwcGluZ0luZm9zJiYodGhpcy5fY2xpcHBpbmdJbmZvcy5mb3JFYWNoKChzPT5zLmRlc3Ryb3koKSkpLHRoaXMuX2NsaXBwaW5nSW5mb3M9bnVsbCksbnVsbCE9cyYmcy5sZW5ndGgmJih0aGlzLl9jbGlwcGluZ0luZm9zPXMuaXRlbXMubWFwKChzPT5yLmZyb21DbGlwQXJlYSh0aGlzLnN0YWdlLHMpKSkpLHRoaXMucmVxdWVzdFJlbmRlcigpfX1leHBvcnR7biBhcyBkZWZhdWx0fTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjMzL2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnR7ZnJvbVZhbHVlcyBhcyByfWZyb21cIi4uLy4uLy4uLy4uLy4uL2NvcmUvbGlicy9nbC1tYXRyaXgtMi9mYWN0b3JpZXMvdmVjNGYzMi5qc1wiO2ltcG9ydHtjcmVhdGVQcm9ncmFtRGVzY3JpcHRvciBhcyBlfWZyb21cIi4uL1V0aWxzLmpzXCI7aW1wb3J0IHQgZnJvbVwiLi9XR0xCcnVzaC5qc1wiO2ltcG9ydHtiYWNrZ3JvdW5kIGFzIHN9ZnJvbVwiLi4vc2hhZGVycy9CYWNrZ3JvdW5kUHJvZ3JhbXMuanNcIjtpbXBvcnR7U3RlbmNpbE9wZXJhdGlvbiBhcyBvLENvbXBhcmVGdW5jdGlvbiBhcyBpLFByaW1pdGl2ZVR5cGUgYXMgYSxEYXRhVHlwZSBhcyBufWZyb21cIi4uLy4uLy4uLy4uL3dlYmdsL2VudW1zLmpzXCI7aW1wb3J0e2NyZWF0ZVByb2dyYW0gYXMgbH1mcm9tXCIuLi8uLi8uLi8uLi93ZWJnbC9Qcm9ncmFtVGVtcGxhdGUuanNcIjtjb25zdCBtPSgpPT5lKFwiY2xpcFwiLHtnZW9tZXRyeTpbe2xvY2F0aW9uOjAsbmFtZTpcImFfcG9zXCIsY291bnQ6Mix0eXBlOm4uU0hPUlR9XX0pO2NsYXNzIHAgZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLl9jb2xvcj1yKDAsMSwwLDEpfWRpc3Bvc2UoKXt0aGlzLl9wcm9ncmFtJiZ0aGlzLl9wcm9ncmFtLmRpc3Bvc2UoKX1wcmVwYXJlU3RhdGUoe2NvbnRleHQ6cn0pe3Iuc2V0U3RlbmNpbFRlc3RFbmFibGVkKCEwKSxyLnNldEJsZW5kaW5nRW5hYmxlZCghMSksci5zZXRGYWNlQ3VsbGluZ0VuYWJsZWQoITEpLHIuc2V0Q29sb3JNYXNrKCExLCExLCExLCExKSxyLnNldFN0ZW5jaWxPcChvLktFRVAsby5LRUVQLG8uUkVQTEFDRSksci5zZXRTdGVuY2lsV3JpdGVNYXNrKDI1NSksci5zZXRTdGVuY2lsRnVuY3Rpb24oaS5BTFdBWVMsMCwyNTUpfWRyYXcocixlKXtjb25zdHtjb250ZXh0OnQsc3RhdGU6byxyZXF1ZXN0UmVuZGVyOmksYWxsb3dEZWxheWVkUmVuZGVyOnB9PXIsYz1tKCksZD1lLmdldFZBTyh0LG8sYy5hdHRyaWJ1dGVzLGMuYnVmZmVyTGF5b3V0cyk7bnVsbCE9ZC5pbmRleEJ1ZmZlciYmKHRoaXMuX3Byb2dyYW18fCh0aGlzLl9wcm9ncmFtPWwodCxzKSksIXB8fG51bGw9PWl8fHRoaXMuX3Byb2dyYW0uY29tcGlsZWQ/KHQudXNlUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKSx0aGlzLl9wcm9ncmFtLnNldFVuaWZvcm0yZnYoXCJ1X2Nvb3JkX3JhbmdlXCIsWzEsMV0pLHRoaXMuX3Byb2dyYW0uc2V0VW5pZm9ybTRmdihcInVfY29sb3JcIix0aGlzLl9jb2xvciksdGhpcy5fcHJvZ3JhbS5zZXRVbmlmb3JtTWF0cml4M2Z2KFwidV9kdnNNYXQzXCIsby5kaXNwbGF5TWF0MyksdC5iaW5kVkFPKGQpLHQuZHJhd0VsZW1lbnRzKGEuVFJJQU5HTEVTLGQuaW5kZXhCdWZmZXIuc2l6ZSxuLlVOU0lHTkVEX0lOVCwwKSx0LmJpbmRWQU8oKSk6aSgpKX19ZXhwb3J0e3AgYXMgZGVmYXVsdH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e2Zyb21WYWx1ZXMgYXMgZX1mcm9tXCIuLi8uLi8uLi8uLi8uLi9jb3JlL2xpYnMvZ2wtbWF0cml4LTIvZmFjdG9yaWVzL3ZlYzRmMzIuanNcIjtpbXBvcnR7UG9zMmIgYXMgcn1mcm9tXCIuLi9EZWZhdWx0VmVydGV4QXR0cmlidXRlTGF5b3V0cy5qc1wiO2ltcG9ydCB0IGZyb21cIi4vV0dMQnJ1c2guanNcIjtpbXBvcnR7YmFja2dyb3VuZCBhcyBpfWZyb21cIi4uL3NoYWRlcnMvQmFja2dyb3VuZFByb2dyYW1zLmpzXCI7aW1wb3J0e0J1ZmZlck9iamVjdCBhcyBzfWZyb21cIi4uLy4uLy4uLy4uL3dlYmdsL0J1ZmZlck9iamVjdC5qc1wiO2ltcG9ydHtTdGVuY2lsT3BlcmF0aW9uIGFzIG8sRmFjZSBhcyBhLENvbXBhcmVGdW5jdGlvbiBhcyBsLFByaW1pdGl2ZVR5cGUgYXMgbixVc2FnZSBhcyBkfWZyb21cIi4uLy4uLy4uLy4uL3dlYmdsL2VudW1zLmpzXCI7aW1wb3J0e2NyZWF0ZVByb2dyYW0gYXMgbX1mcm9tXCIuLi8uLi8uLi8uLi93ZWJnbC9Qcm9ncmFtVGVtcGxhdGUuanNcIjtpbXBvcnR7VmVydGV4QXJyYXlPYmplY3QgYXMgY31mcm9tXCIuLi8uLi8uLi8uLi93ZWJnbC9WZXJ0ZXhBcnJheU9iamVjdC5qc1wiO2NsYXNzIF8gZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLl9jb2xvcj1lKDEsMCwwLDEpLHRoaXMuX2luaXRpYWxpemVkPSExfWRpc3Bvc2UoKXt0aGlzLl9zb2xpZFByb2dyYW0mJih0aGlzLl9zb2xpZFByb2dyYW0uZGlzcG9zZSgpLHRoaXMuX3NvbGlkUHJvZ3JhbT1udWxsKSx0aGlzLl9zb2xpZFZlcnRleEFycmF5T2JqZWN0JiYodGhpcy5fc29saWRWZXJ0ZXhBcnJheU9iamVjdC5kaXNwb3NlKCksdGhpcy5fc29saWRWZXJ0ZXhBcnJheU9iamVjdD1udWxsKX1wcmVwYXJlU3RhdGUoe2NvbnRleHQ6ZX0pe2Uuc2V0RGVwdGhXcml0ZUVuYWJsZWQoITEpLGUuc2V0RGVwdGhUZXN0RW5hYmxlZCghMSksZS5zZXRTdGVuY2lsVGVzdEVuYWJsZWQoITApLGUuc2V0QmxlbmRpbmdFbmFibGVkKCExKSxlLnNldENvbG9yTWFzayghMSwhMSwhMSwhMSksZS5zZXRTdGVuY2lsT3Aoby5LRUVQLG8uS0VFUCxvLlJFUExBQ0UpLGUuc2V0U3RlbmNpbFdyaXRlTWFzaygyNTUpfWRyYXcoZSxyKXtjb25zdHtjb250ZXh0OnQscmVxdWVzdFJlbmRlcjppLGFsbG93RGVsYXllZFJlbmRlcjpzfT1lO3RoaXMuX2luaXRpYWxpemVkfHx0aGlzLl9pbml0aWFsaXplKHQpLCFzfHxudWxsPT1pfHx0aGlzLl9zb2xpZFByb2dyYW0uY29tcGlsZWQ/KHQuc2V0U3RlbmNpbEZ1bmN0aW9uU2VwYXJhdGUoYS5GUk9OVF9BTkRfQkFDSyxsLkdSRUFURVIsci5zdGVuY2lsUmVmLDI1NSksdC5iaW5kVkFPKHRoaXMuX3NvbGlkVmVydGV4QXJyYXlPYmplY3QpLHQudXNlUHJvZ3JhbSh0aGlzLl9zb2xpZFByb2dyYW0pLHRoaXMuX3NvbGlkUHJvZ3JhbS5zZXRVbmlmb3JtTWF0cml4M2Z2KFwidV9kdnNNYXQzXCIsci50cmFuc2Zvcm1zLmRpc3BsYXlWaWV3U2NyZWVuTWF0MyksdGhpcy5fc29saWRQcm9ncmFtLnNldFVuaWZvcm0yZnYoXCJ1X2Nvb3JkX3JhbmdlXCIsW3IucmFuZ2VYLHIucmFuZ2VZXSksdGhpcy5fc29saWRQcm9ncmFtLnNldFVuaWZvcm0xZihcInVfZGVwdGhcIiwwKSx0aGlzLl9zb2xpZFByb2dyYW0uc2V0VW5pZm9ybTRmdihcInVfY29sb3JcIix0aGlzLl9jb2xvciksdC5kcmF3QXJyYXlzKG4uVFJJQU5HTEVfU1RSSVAsMCw0KSx0LmJpbmRWQU8oKSk6aSgpfV9pbml0aWFsaXplKGUpe2lmKHRoaXMuX2luaXRpYWxpemVkKXJldHVybiEwO2NvbnN0IHQ9bShlLGkpO2lmKCF0KXJldHVybiExO2NvbnN0IG89bmV3IEludDhBcnJheShbMCwwLDEsMCwwLDEsMSwxXSksYT1zLmNyZWF0ZVZlcnRleChlLGQuU1RBVElDX0RSQVcsbyksbD1uZXcgYyhlLGkuYXR0cmlidXRlcyxyLG5ldyBNYXAoW1tcImdlb21ldHJ5XCIsYV1dKSk7cmV0dXJuIHRoaXMuX3NvbGlkUHJvZ3JhbT10LHRoaXMuX3NvbGlkVmVydGV4QXJyYXlPYmplY3Q9bCx0aGlzLl9pbml0aWFsaXplZD0hMCwhMH19ZXhwb3J0e18gYXMgZGVmYXVsdH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e2Zyb21WYWx1ZXMgYXMgZX1mcm9tXCIuLi8uLi8uLi8uLi8uLi9jb3JlL2xpYnMvZ2wtbWF0cml4LTIvZmFjdG9yaWVzL3ZlYzRmMzIuanNcIjtpbXBvcnR7UG9zMmIgYXMgdH1mcm9tXCIuLi9EZWZhdWx0VmVydGV4QXR0cmlidXRlTGF5b3V0cy5qc1wiO2ltcG9ydHtGZWF0dXJlVGlsZSBhcyByfWZyb21cIi4uL0ZlYXR1cmVUaWxlLmpzXCI7aW1wb3J0IG8gZnJvbVwiLi9XR0xCcnVzaC5qc1wiO2ltcG9ydHtiYWNrZ3JvdW5kIGFzIGl9ZnJvbVwiLi4vc2hhZGVycy9CYWNrZ3JvdW5kUHJvZ3JhbXMuanNcIjtpbXBvcnR7dGlsZUluZm8gYXMgc31mcm9tXCIuLi9zaGFkZXJzL1RpbGVJbmZvUHJvZ3JhbXMuanNcIjtpbXBvcnR7QnVmZmVyT2JqZWN0IGFzIG59ZnJvbVwiLi4vLi4vLi4vLi4vd2ViZ2wvQnVmZmVyT2JqZWN0LmpzXCI7aW1wb3J0e0JsZW5kRmFjdG9yIGFzIGEsUHJpbWl0aXZlVHlwZSBhcyBsLFVzYWdlIGFzIGYsVGV4dHVyZVdyYXBNb2RlIGFzIG0sVGV4dHVyZVNhbXBsaW5nTW9kZSBhcyB1fWZyb21cIi4uLy4uLy4uLy4uL3dlYmdsL2VudW1zLmpzXCI7aW1wb3J0e2NyZWF0ZVByb2dyYW0gYXMgY31mcm9tXCIuLi8uLi8uLi8uLi93ZWJnbC9Qcm9ncmFtVGVtcGxhdGUuanNcIjtpbXBvcnR7VGV4dHVyZSBhcyBkfWZyb21cIi4uLy4uLy4uLy4uL3dlYmdsL1RleHR1cmUuanNcIjtpbXBvcnR7VGV4dHVyZURlc2NyaXB0b3IgYXMgaH1mcm9tXCIuLi8uLi8uLi8uLi93ZWJnbC9UZXh0dXJlRGVzY3JpcHRvci5qc1wiO2ltcG9ydHtWZXJ0ZXhBcnJheU9iamVjdCBhcyBnfWZyb21cIi4uLy4uLy4uLy4uL3dlYmdsL1ZlcnRleEFycmF5T2JqZWN0LmpzXCI7Y29uc3QgXz01MTIseD01MTIsYj0xNixwPTgsVD0oeC0yKnApLzU7Y2xhc3MgeSBleHRlbmRzIG97Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuX2NvbG9yPWUoMSwwLDAsMSl9ZGlzcG9zZSgpe3RoaXMuX291dGxpbmVQcm9ncmFtPy5kaXNwb3NlKCksdGhpcy5fb3V0bGluZVByb2dyYW09bnVsbCx0aGlzLl90aWxlSW5mb1Byb2dyYW0/LmRpc3Bvc2UoKSx0aGlzLl90aWxlSW5mb1Byb2dyYW09bnVsbCx0aGlzLl9vdXRsaW5lVmVydGV4QXJyYXlPYmplY3Q/LmRpc3Bvc2UoKSx0aGlzLl9vdXRsaW5lVmVydGV4QXJyYXlPYmplY3Q9bnVsbCx0aGlzLl90aWxlSW5mb1ZlcnRleEFycmF5T2JqZWN0Py5kaXNwb3NlKCksdGhpcy5fdGlsZUluZm9WZXJ0ZXhBcnJheU9iamVjdD1udWxsLHRoaXMuX2N0eD1udWxsfXByZXBhcmVTdGF0ZSh7Y29udGV4dDplfSl7ZS5zZXRCbGVuZGluZ0VuYWJsZWQoITApLGUuc2V0QmxlbmRGdW5jdGlvblNlcGFyYXRlKGEuT05FLGEuT05FX01JTlVTX1NSQ19BTFBIQSxhLk9ORSxhLk9ORV9NSU5VU19TUkNfQUxQSEEpLGUuc2V0Q29sb3JNYXNrKCEwLCEwLCEwLCEwKSxlLnNldFN0ZW5jaWxXcml0ZU1hc2soMCksZS5zZXRTdGVuY2lsVGVzdEVuYWJsZWQoITEpfWRyYXcoZSx0KXtjb25zdHtjb250ZXh0Om8scmVxdWVzdFJlbmRlcjppLGFsbG93RGVsYXllZFJlbmRlcjpzfT1lO2lmKCF0LmlzUmVhZHkmJnQgaW5zdGFuY2VvZiByJiZ0Lmhhc0RhdGEpcmV0dXJuO2lmKHRoaXMuX2xvYWRXR0xSZXNvdXJjZXMobykscyYmbnVsbCE9aSYmKCF0aGlzLl9vdXRsaW5lUHJvZ3JhbS5jb21waWxlZHx8IXRoaXMuX3RpbGVJbmZvUHJvZ3JhbS5jb21waWxlZCkpcmV0dXJuIHZvaWQgaSgpO28uYmluZFZBTyh0aGlzLl9vdXRsaW5lVmVydGV4QXJyYXlPYmplY3QpLG8udXNlUHJvZ3JhbSh0aGlzLl9vdXRsaW5lUHJvZ3JhbSksdGhpcy5fb3V0bGluZVByb2dyYW0uc2V0VW5pZm9ybU1hdHJpeDNmdihcInVfZHZzTWF0M1wiLHQudHJhbnNmb3Jtcy5kaXNwbGF5Vmlld1NjcmVlbk1hdDMpLHRoaXMuX291dGxpbmVQcm9ncmFtLnNldFVuaWZvcm0yZihcInVfY29vcmRfcmFuZ2VcIix0LnJhbmdlWCx0LnJhbmdlWSksdGhpcy5fb3V0bGluZVByb2dyYW0uc2V0VW5pZm9ybTFmKFwidV9kZXB0aFwiLDApLHRoaXMuX291dGxpbmVQcm9ncmFtLnNldFVuaWZvcm00ZnYoXCJ1X2NvbG9yXCIsdGhpcy5fY29sb3IpLG8uZHJhd0FycmF5cyhsLkxJTkVfU1RSSVAsMCw0KTtjb25zdCBuPXRoaXMuX2dldFRleHR1cmUobyx0KTtuPyhvLmJpbmRWQU8odGhpcy5fdGlsZUluZm9WZXJ0ZXhBcnJheU9iamVjdCksby51c2VQcm9ncmFtKHRoaXMuX3RpbGVJbmZvUHJvZ3JhbSksby5iaW5kVGV4dHVyZShuLDApLHRoaXMuX3RpbGVJbmZvUHJvZ3JhbS5zZXRVbmlmb3JtTWF0cml4M2Z2KFwidV9kdnNNYXQzXCIsdC50cmFuc2Zvcm1zLmRpc3BsYXlWaWV3U2NyZWVuTWF0MyksdGhpcy5fdGlsZUluZm9Qcm9ncmFtLnNldFVuaWZvcm0xZihcInVfZGVwdGhcIiwwKSx0aGlzLl90aWxlSW5mb1Byb2dyYW0uc2V0VW5pZm9ybTJmKFwidV9jb29yZF9yYXRpb1wiLHQucmFuZ2VYL3Qud2lkdGgsdC5yYW5nZVkvdC5oZWlnaHQpLHRoaXMuX3RpbGVJbmZvUHJvZ3JhbS5zZXRVbmlmb3JtMmYoXCJ1X2RlbHRhXCIsMCwwKSx0aGlzLl90aWxlSW5mb1Byb2dyYW0uc2V0VW5pZm9ybTJmKFwidV9kaW1lbnNpb25zXCIsbi5kZXNjcmlwdG9yLndpZHRoLG4uZGVzY3JpcHRvci5oZWlnaHQpLG8uZHJhd0FycmF5cyhsLlRSSUFOR0xFX1NUUklQLDAsNCksby5iaW5kVkFPKCkpOm8uYmluZFZBTygpfV9sb2FkV0dMUmVzb3VyY2VzKGUpe2lmKHRoaXMuX291dGxpbmVQcm9ncmFtJiZ0aGlzLl90aWxlSW5mb1Byb2dyYW0pcmV0dXJuO2NvbnN0IHI9YyhlLGkpLG89YyhlLHMpLGE9bmV3IEludDhBcnJheShbMCwwLDEsMCwxLDEsMCwxXSksbD1uLmNyZWF0ZVZlcnRleChlLGYuU1RBVElDX0RSQVcsYSksbT1uZXcgZyhlLGkuYXR0cmlidXRlcyx0LG5ldyBNYXAoW1tcImdlb21ldHJ5XCIsbF1dKSksdT1uZXcgSW50OEFycmF5KFswLDAsMSwwLDAsMSwxLDFdKSxkPW4uY3JlYXRlVmVydGV4KGUsZi5TVEFUSUNfRFJBVyx1KSxoPW5ldyBnKGUscy5hdHRyaWJ1dGVzLHQsbmV3IE1hcChbW1wiZ2VvbWV0cnlcIixkXV0pKTt0aGlzLl9vdXRsaW5lUHJvZ3JhbT1yLHRoaXMuX3RpbGVJbmZvUHJvZ3JhbT1vLHRoaXMuX291dGxpbmVWZXJ0ZXhBcnJheU9iamVjdD1tLHRoaXMuX3RpbGVJbmZvVmVydGV4QXJyYXlPYmplY3Q9aH1fZ2V0VGV4dHVyZShlLHQpe2lmKCF0aGlzLl9jdHgpe2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtlLndpZHRoPV8sZS5oZWlnaHQ9eCx0aGlzLl9jdHg9ZS5nZXRDb250ZXh0KFwiMmRcIil9aWYoIXQudGlsZURlYnVnSW5mb1RleHR1cmUpe2NvbnN0IHI9bmV3IGg7ci53cmFwTW9kZT1tLkNMQU1QX1RPX0VER0Usci5zYW1wbGluZ01vZGU9dS5MSU5FQVIsci5pc0ltbXV0YWJsZT0hMCxyLndpZHRoPV8sci5oZWlnaHQ9eCx0LnRpbGVEZWJ1Z0luZm9UZXh0dXJlPW5ldyBkKGUscil9Y29uc3Qgcj10aGlzLl9jdHg7ci5jbGVhclJlY3QoMCwwLHIuY2FudmFzLndpZHRoLHIuY2FudmFzLmhlaWdodCksci50ZXh0QWxpZ249XCJsZWZ0XCIsci50ZXh0QmFzZWxpbmU9XCJ0b3BcIixyLmZvbnQ9Yi0yK1wicHggc2Fucy1zZXJpZlwiLHIubGluZVdpZHRoPTIsci5maWxsU3R5bGU9XCJ3aGl0ZVwiLHIuc3Ryb2tlU3R5bGU9XCJibGFja1wiO2NvbnN0e2RlYnVnU2xvdDpvfT10O2xldCBpPXArVCpvO2NvbnN0IHM9YCR7b30pICR7dC5rZXkuaWR9ICgke3QuY29uc3RydWN0b3IubmFtZX0pYDtyLnN0cm9rZVRleHQocyxwLGkpLHIuZmlsbFRleHQocyxwLGkpLGkrPWI7Y29uc3R7ZGVidWdJbmZvOm59PXQ7aWYobil7Y29uc3R7bGVuZ3RoOmUsbWluT3JkZXJlZExlbmd0aDp0LG1pblVub3JkZXJlZExlbmd0aDpvLHRyaWFuZ2xlQ291bnQ6c309bi5kaXNwbGF5O2lmKGU+MCl7Y29uc3QgdD1gTGVuZ3RoOiAke2V9YDtyLnN0cm9rZVRleHQodCxwLGkpLHIuZmlsbFRleHQodCxwLGkpLGkrPWJ9aWYodCl7Y29uc3QgZT1gTWluIG9yZGVyZWQgbGVuZ3RoOiAke3R9YDtyLnN0cm9rZVRleHQoZSxwLGkpLHIuZmlsbFRleHQoZSxwLGkpLGkrPWJ9aWYobyl7Y29uc3QgZT1gTWluIHVub3JkZXJlZCBsZW5ndGg6ICR7b31gO3Iuc3Ryb2tlVGV4dChlLHAsaSksci5maWxsVGV4dChlLHAsaSksaSs9Yn1pZihzPjApe3M+MWU1JiYoci5maWxsU3R5bGU9XCJyZWRcIixyLnN0cm9rZVN0eWxlPVwid2hpdGVcIik7Y29uc3QgZT1gVHJpYW5nbGUgY291bnQ6ICR7c31gO3Iuc3Ryb2tlVGV4dChlLHAsaSksci5maWxsVGV4dChlLHAsaSksaSs9Yn1jb25zdHtieXRlc1VzZWQ6YSxieXRlc1Jlc2VydmVkOmx9PW4ubWVtb3J5O2lmKHIuZmlsbFN0eWxlPVwid2hpdGVcIixyLnN0cm9rZVN0eWxlPVwiYmxhY2tcIixhPjB8fGw+MCl7Y29uc3QgZT1gTWVtb3J5IHVzYWdlOiAke2F9IG9mICR7bH0gYnl0ZXNgO3Iuc3Ryb2tlVGV4dChlLHAsaSksci5maWxsVGV4dChlLHAsaSksaSs9Yn19cmV0dXJuIHQudGlsZURlYnVnSW5mb1RleHR1cmUuc2V0RGF0YShyLmNhbnZhcyksdC50aWxlRGVidWdJbmZvVGV4dHVyZX19ZXhwb3J0e3kgYXMgZGVmYXVsdH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0XCIuLi8uLi8uLi8uLi8uLi9jb3JlL2hhcy5qc1wiO2ltcG9ydHthc3NlcnRJc1NvbWUgYXMgdH1mcm9tXCIuLi8uLi8uLi8uLi8uLi9jb3JlL21heWJlLmpzXCI7aW1wb3J0e3RvVWludDMyIGFzIGksdG9GbG9hdDMyIGFzIHJ9ZnJvbVwiLi4vbnVtYmVyLmpzXCI7aW1wb3J0e1Bvb2xlZFVpbnQzMkFycmF5IGFzIGV9ZnJvbVwiLi4vUG9vbGVkVWludDMyQXJyYXkuanNcIjtpbXBvcnR7RnJlZUxpc3QgYXMgc31mcm9tXCIuL0ZyZWVMaXN0LmpzXCI7aW1wb3J0e0J1ZmZlck9iamVjdCBhcyBufWZyb21cIi4uLy4uLy4uLy4uL3dlYmdsL0J1ZmZlck9iamVjdC5qc1wiO2ltcG9ydHtVc2FnZSBhcyBofWZyb21cIi4uLy4uLy4uLy4uL3dlYmdsL2VudW1zLmpzXCI7Y29uc3QgYT0xLjI1LGQ9MzI3NjcsdT1kPDwxNnxkO2NsYXNzIG97Y29uc3RydWN0b3IodCxpLHIscyl7dGhpcy5fcG9vbD1zO2NvbnN0IG49ZS5jcmVhdGUoaSpyKlVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHRoaXMuX3Bvb2wpO3RoaXMuc2l6ZT1pLHRoaXMuc3RyaWRlSW50PXIsdGhpcy5idWZmZXJUeXBlPXQsdGhpcy5kaXJ0eT17c3RhcnQ6MS8wLGVuZDowfSx0aGlzLm1lbW9yeVN0YXRzPXtieXRlc1VzZWQ6MCxieXRlc1Jlc2VydmVkOmkqcipVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVH0sdGhpcy5fZ3B1PW51bGwsdGhpcy5fY3B1PW4sdGhpcy5jbGVhcigpfWdldCBlbGVtZW50U2l6ZSgpe3JldHVybiB0aGlzLl9jcHUubGVuZ3RoL3RoaXMuc3RyaWRlSW50fWdldCBpbnRTaXplKCl7cmV0dXJuIHRoaXMuZmlsbFBvaW50ZXIqdGhpcy5zdHJpZGVJbnR9Z2V0IGJ5dGVTaXplKCl7cmV0dXJuIHRoaXMuaW50U2l6ZSpVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVH1nZXQgaW52YWxpZGF0ZWQoKXtyZXR1cm4gdGhpcy5idWZmZXJTaXplPjAmJiF0aGlzLl9ncHV9Z2V0IGludmFsaWRhdGVkQ29tcHV0ZUJ1ZmZlcigpe3JldHVybiB0aGlzLmJ1ZmZlclNpemU+MCYmIXRoaXMuX2dwdUNvbXB1dGVUcmlhbmdsZXN9aW52YWxpZGF0ZSgpe3RoaXMuX2ludmFsaWRhdGVUcmlhbmdsZUJ1ZmZlcigpLHRoaXMuX2dwdT8uZGlzcG9zZSgpLHRoaXMuX2dwdT1udWxsfV9pbnZhbGlkYXRlVHJpYW5nbGVCdWZmZXIoKXt0aGlzLl9ncHVDb21wdXRlVHJpYW5nbGVzPy5kaXNwb3NlKCksdGhpcy5fZ3B1Q29tcHV0ZVRyaWFuZ2xlcz1udWxsfWRlc3Ryb3koKXt0aGlzLl9ncHU/LmRpc3Bvc2UoKSx0aGlzLl9ncHVDb21wdXRlVHJpYW5nbGVzPy5kaXNwb3NlKCksdGhpcy5fY3B1Py5kZXN0cm95KCl9Y2xlYXIoKXt0aGlzLmRpcnR5LnN0YXJ0PTEvMCx0aGlzLmRpcnR5LmVuZD0wLHRoaXMuZnJlZUxpc3Q9bmV3IHMoe3N0YXJ0OjAsZW5kOnRoaXMuX2NwdS5sZW5ndGgvdGhpcy5zdHJpZGVJbnR9KSx0aGlzLmZpbGxQb2ludGVyPTB9ZW5zdXJlKHQpe2lmKHRoaXMubWF4QXZhaWxhYmxlU3BhY2UoKT49dClyZXR1cm47aWYodCp0aGlzLnN0cmlkZUludD50aGlzLl9jcHUubGVuZ3RoLXRoaXMuZmlsbFBvaW50ZXIpe3RoaXMuaW52YWxpZGF0ZSgpO2NvbnN0IGk9dGhpcy5fY3B1Lmxlbmd0aC90aGlzLnN0cmlkZUludCxyPU1hdGgucm91bmQoKGkrdCkqYSksZT1yKnRoaXMuc3RyaWRlSW50O3RoaXMuX2NwdS5leHBhbmQoZSpVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCksdGhpcy5mcmVlTGlzdC5mcmVlKGksci1pKSx0aGlzLm1lbW9yeVN0YXRzLmJ5dGVzUmVzZXJ2ZWQrPShyLWkpKnRoaXMuc3RyaWRlSW50KlVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UfX1zZXRVMzIodCxpKXt0aGlzLl9jcHUuYXJyYXlbdF0hPT1pJiYodGhpcy5fY3B1LmFycmF5W3RdPWksdGhpcy5kaXJ0eS5zdGFydD1NYXRoLm1pbih0LHRoaXMuZGlydHkuc3RhcnQpLHRoaXMuZGlydHkuZW5kPU1hdGgubWF4KHQrMSx0aGlzLmRpcnR5LmVuZCkpfXNldEYzMih0LHIpe3RoaXMuc2V0VTMyKHQsaShyKSl9c2V0RjMyUmFuZ2UodCxyLGUpe2NvbnN0IHM9aShlKTt0aGlzLl9jcHUuYXJyYXkuZmlsbChzLHQsciksdGhpcy5kaXJ0eS5zdGFydD1NYXRoLm1pbih0LHRoaXMuZGlydHkuc3RhcnQpLHRoaXMuZGlydHkuZW5kPU1hdGgubWF4KHIsdGhpcy5kaXJ0eS5lbmQpfWdldEYzMih0KXtyZXR1cm4gcih0aGlzLl9jcHUuYXJyYXlbdF0pfWdldEdQVUJ1ZmZlcih0LGk9ITEpe2lmKCF0aGlzLmJ1ZmZlclNpemUpcmV0dXJuIG51bGw7aWYoaSl7aWYoXCJpbmRleFwiIT09dGhpcy5idWZmZXJUeXBlKXRocm93IG5ldyBFcnJvcihcIlRpcmVkIHRvIGdldCB0cmlhbmdsZSBidWZmZXIsIGJ1dCB0YXJnZXQgaXMgbm90IGFuIGluZGV4IGJ1ZmZlclwiKTtyZXR1cm4gbnVsbD09dGhpcy5fZ3B1Q29tcHV0ZVRyaWFuZ2xlcyYmKHRoaXMuX2dwdUNvbXB1dGVUcmlhbmdsZXM9dGhpcy5fY3JlYXRlQ29tcHV0ZUJ1ZmZlcih0KSksdGhpcy5fZ3B1Q29tcHV0ZVRyaWFuZ2xlc31yZXR1cm4gbnVsbD09dGhpcy5fZ3B1JiYodGhpcy5fZ3B1PXRoaXMuX2NyZWF0ZUJ1ZmZlcih0KSksdGhpcy5fZ3B1fWdldFZpZXcodCxpKXtyZXR1cm4gdGhpcy5fY3B1LmdldFVpbnQzMlZpZXcodCxpL1VpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKX1nZXQgYnVmZmVyU2l6ZSgpe3JldHVybiB0aGlzLl9jcHUubGVuZ3RoL3RoaXMuc3RyaWRlSW50fW1heEF2YWlsYWJsZVNwYWNlKCl7cmV0dXJuIHRoaXMuZnJlZUxpc3QubWF4QXZhaWxhYmxlU3BhY2UoKX1pbnNlcnQoaSxyLGUscyl7Y29uc3Qgbj1lKnRoaXMuc3RyaWRlSW50O2lmKCFuKXJldHVybiAwO2NvbnN0IGg9cip0aGlzLnN0cmlkZUludCpVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxhPW5ldyBVaW50MzJBcnJheShpLGgsbiksZD10aGlzLmZyZWVMaXN0LmZpcnN0Rml0KGUpO3QoZCxcIkZpcnN0IGZpdCByZWdpb24gbXVzdCBiZSBkZWZpbmVkXCIpO2NvbnN0IHU9ZCp0aGlzLnN0cmlkZUludCxvPW47aWYodGhpcy5fY3B1LmFycmF5LnNldChhLHUpLDAhPT1zKWZvcihsZXQgdD0wO3Q8YS5sZW5ndGg7dCsrKXRoaXMuX2NwdS5hcnJheVt0K3VdKz1zO3JldHVybiB0aGlzLmRpcnR5LnN0YXJ0PU1hdGgubWluKHRoaXMuZGlydHkuc3RhcnQsdSksdGhpcy5kaXJ0eS5lbmQ9TWF0aC5tYXgodGhpcy5kaXJ0eS5lbmQsdStvKSx0aGlzLmZpbGxQb2ludGVyPU1hdGgubWF4KHRoaXMuZmlsbFBvaW50ZXIsdStvKSx0aGlzLm1lbW9yeVN0YXRzLmJ5dGVzVXNlZCs9ZSp0aGlzLnN0cmlkZUludCpVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxkfWNvcHlGcm9tKGkscixlLHMsbil7Y29uc3QgaD1lKnRoaXMuc3RyaWRlSW50O2lmKCFoKXJldHVybiAwO2NvbnN0IGE9cip0aGlzLnN0cmlkZUludCpVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxkPWkuX2NwdS5nZXRVaW50MzJWaWV3KGEsaCksdT10aGlzLmZyZWVMaXN0LmZpcnN0Rml0KGUpO3QodSxcIkZpcnN0IGZpdCByZWdpb24gbXVzdCBiZSBkZWZpbmVkXCIpO2NvbnN0IG89dSp0aGlzLnN0cmlkZUludCxmPWg7aWYodGhpcy5fY3B1LmFycmF5LnNldChkLG8pLDAhPT1zKWZvcihsZXQgdD0wO3Q8aDt0KyspdGhpcy5fY3B1LmFycmF5W28rdCp0aGlzLnN0cmlkZUludCtuXSs9cztyZXR1cm4gdGhpcy5kaXJ0eS5zdGFydD1NYXRoLm1pbih0aGlzLmRpcnR5LnN0YXJ0LG8pLHRoaXMuZGlydHkuZW5kPU1hdGgubWF4KHRoaXMuZGlydHkuZW5kLG8rZiksdGhpcy5maWxsUG9pbnRlcj1NYXRoLm1heCh0aGlzLmZpbGxQb2ludGVyLG8rZiksdGhpcy5tZW1vcnlTdGF0cy5ieXRlc1VzZWQrPWUqdGhpcy5zdHJpZGVJbnQqVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsdX1mcmVlKHQsaSxyKXtjb25zdCBlPXQqdGhpcy5zdHJpZGVJbnQscz0odCtpKSp0aGlzLnN0cmlkZUludDtpZighMD09PXIpZm9yKGxldCBuPXQ7biE9PXQraTtuKyspdGhpcy5fY3B1LmFycmF5W24qdGhpcy5zdHJpZGVJbnRdPXU7dGhpcy5kaXJ0eS5zdGFydD1NYXRoLm1pbih0aGlzLmRpcnR5LnN0YXJ0LGUpLHRoaXMuZGlydHkuZW5kPU1hdGgubWF4KHRoaXMuZGlydHkuZW5kLHMpLHRoaXMuZnJlZUxpc3QuZnJlZSh0LGkpLHRoaXMubWVtb3J5U3RhdHMuYnl0ZXNVc2VkLT1pKnRoaXMuc3RyaWRlSW50KlVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UfXVwbG9hZCgpe2lmKHRoaXMuZGlydHkuZW5kKXtpZih0aGlzLl9pbnZhbGlkYXRlVHJpYW5nbGVCdWZmZXIoKSxudWxsPT10aGlzLl9ncHUpcmV0dXJuIHRoaXMuZGlydHkuc3RhcnQ9MS8wLHZvaWQodGhpcy5kaXJ0eS5lbmQ9MCk7dGhpcy5fZ3B1LnNldFN1YkRhdGEodGhpcy5fY3B1LmFycmF5LHRoaXMuZGlydHkuc3RhcnQsdGhpcy5kaXJ0eS5zdGFydCx0aGlzLmRpcnR5LmVuZCksdGhpcy5kaXJ0eS5zdGFydD0xLzAsdGhpcy5kaXJ0eS5lbmQ9MH19cmVzaHVmZmxlKHQsaSl7aWYoMD09PWkubGVuZ3RoKXJldHVybjtjb25zdCByPXRoaXMuYnl0ZVNpemUscz10KnRoaXMuc3RyaWRlSW50KlVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULG49cj5zLGg9dGhpcy5fY3B1LGE9ZS5jcmVhdGUocyx0aGlzLl9wb29sKTtufHxhLmFycmF5LnNldCh0aGlzLl9jcHUuZ2V0VWludDMyVmlldygwLHRoaXMuaW50U2l6ZSkpO2Zvcihjb25zdCBlIG9mIGkpaWYobnx8ZS5zcmNGcm9tIT09ZS5kc3RGcm9tfHwwIT09ZS5tdXRhdGUpe3RoaXMuZGlydHkuc3RhcnQ9TWF0aC5taW4odGhpcy5kaXJ0eS5zdGFydCxlLmRzdEZyb20qdGhpcy5zdHJpZGVJbnQpLHRoaXMuZGlydHkuZW5kPU1hdGgubWF4KHRoaXMuZGlydHkuZW5kLChlLmRzdEZyb20rZS5jb3VudCkqdGhpcy5zdHJpZGVJbnQpO2ZvcihsZXQgdD0wO3Q8ZS5jb3VudDt0Kyspe2NvbnN0IGk9KGUuZHN0RnJvbSt0KSp0aGlzLnN0cmlkZUludCxyPShlLnNyY0Zyb20rdCkqdGhpcy5zdHJpZGVJbnQ7Zm9yKGxldCB0PTA7dDx0aGlzLnN0cmlkZUludDt0KyspYS5hcnJheVtpK3RdPWguYXJyYXlbcit0XStlLm11dGF0ZX19dGhpcy5fY3B1LmRlc3Ryb3koKSx0aGlzLl9jcHU9YSxuJiZ0aGlzLmludmFsaWRhdGUoKSx0aGlzLmZyZWVMaXN0LmNsZWFyKCksdGhpcy5tZW1vcnlTdGF0cy5ieXRlc1VzZWQ9dGhpcy5tZW1vcnlTdGF0cy5ieXRlc1Jlc2VydmVkPXN9X2NyZWF0ZUJ1ZmZlcih0KXtjb25zdCBpPWguRFlOQU1JQ19EUkFXO3JldHVyblwiaW5kZXhcIj09PXRoaXMuYnVmZmVyVHlwZT9uLmNyZWF0ZUluZGV4KHQsaSx0aGlzLl9jcHUuYXJyYXkpOm4uY3JlYXRlVmVydGV4KHQsaSx0aGlzLl9jcHUuYXJyYXkpfV9jcmVhdGVDb21wdXRlQnVmZmVyKHQpe2NvbnN0IGk9aC5EWU5BTUlDX0RSQVcscj1uZXcgVWludDMyQXJyYXkodGhpcy5maWxsUG9pbnRlci8zKTtmb3IobGV0IGU9MDtlPHRoaXMuZmlsbFBvaW50ZXI7ZSs9MylyW2UvM109dGhpcy5fY3B1LmFycmF5W2VdO3JldHVybiBuLmNyZWF0ZUluZGV4KHQsaSxyKX19ZXhwb3J0e28gYXMgTWFwcGVkQnVmZmVyfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjMzL2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5jbGFzcyB0e2NvbnN0cnVjdG9yKGEpe2lmKHRoaXMubmV4dD1udWxsLCFBcnJheS5pc0FycmF5KGEpKXJldHVybiB2b2lkKHRoaXMuZGF0YT1hKTt0aGlzLmRhdGE9YVswXTtsZXQgZT10aGlzO2ZvcihsZXQgbj0xO248YS5sZW5ndGg7bisrKWUubmV4dD1uZXcgdChbYVtuXV0pLGU9ZS5uZXh0fSp2YWx1ZXMoKXtsZXQgdD10aGlzO2Zvcig7dDspeWllbGQgdC5kYXRhLHQ9dC5uZXh0fWZvckVhY2godCl7bGV0IGE9dGhpcztmb3IoO2E7KXQoYS5kYXRhKSxhPWEubmV4dH1nZXQgbGFzdCgpe3JldHVybiB0aGlzLm5leHQ/dGhpcy5uZXh0Lmxhc3Q6dGhpc319Y2xhc3MgYXtjb25zdHJ1Y3RvcihhKXt0aGlzLl9oZWFkPW51bGwsbnVsbCE9YSYmKHRoaXMuX2hlYWQ9bmV3IHQoYSkpfWdldCBoZWFkKCl7cmV0dXJuIHRoaXMuX2hlYWR9bWF4QXZhaWxhYmxlU3BhY2UoKXtpZihudWxsPT10aGlzLl9oZWFkKXJldHVybiAwO2xldCB0PTA7cmV0dXJuIHRoaXMuX2hlYWQuZm9yRWFjaCgoYT0+e2NvbnN0IGU9YS5lbmQtYS5zdGFydDt0PU1hdGgubWF4KHQsZSl9KSksdH1maXJzdEZpdCh0KXtpZihudWxsPT10aGlzLl9oZWFkKXJldHVybiBudWxsO2xldCBhPW51bGwsZT10aGlzLl9oZWFkO2Zvcig7ZTspe2NvbnN0IG49ZS5kYXRhLmVuZC1lLmRhdGEuc3RhcnQ7aWYobj09PXQpcmV0dXJuIGE/YS5uZXh0PWUubmV4dDp0aGlzLl9oZWFkPWUubmV4dCxlLmRhdGEuc3RhcnQ7aWYobj50KXtjb25zdCBhPWUuZGF0YS5zdGFydDtyZXR1cm4gZS5kYXRhLnN0YXJ0Kz10LGF9YT1lLGU9ZS5uZXh0fXJldHVybiBudWxsfWZyZWUoYSxlKXtjb25zdCBuPWErZTtpZihudWxsPT10aGlzLl9oZWFkKXtjb25zdCBlPW5ldyB0KHtzdGFydDphLGVuZDpufSk7cmV0dXJuIHZvaWQodGhpcy5faGVhZD1lKX1pZihuPD10aGlzLl9oZWFkLmRhdGEuc3RhcnQpe2lmKG49PT10aGlzLl9oZWFkLmRhdGEuc3RhcnQpcmV0dXJuIHZvaWQodGhpcy5faGVhZC5kYXRhLnN0YXJ0LT1lKTtjb25zdCByPW5ldyB0KHtzdGFydDphLGVuZDpufSk7cmV0dXJuIHIubmV4dD10aGlzLl9oZWFkLHZvaWQodGhpcy5faGVhZD1yKX1sZXQgcj10aGlzLl9oZWFkLGQ9ci5uZXh0O2Zvcig7ZDspe2lmKGQuZGF0YS5zdGFydD49bil7aWYoci5kYXRhLmVuZD09PWEpe2lmKHIuZGF0YS5lbmQrPWUsci5kYXRhLmVuZD09PWQuZGF0YS5zdGFydCl7Y29uc3QgdD1kLmRhdGEuZW5kLWQuZGF0YS5zdGFydDtyZXR1cm4gci5kYXRhLmVuZCs9dCx2b2lkKHIubmV4dD1kLm5leHQpfXJldHVybn1pZihkLmRhdGEuc3RhcnQ9PT1uKXJldHVybiB2b2lkKGQuZGF0YS5zdGFydC09ZSk7Y29uc3Qgcz1uZXcgdCh7c3RhcnQ6YSxlbmQ6bn0pO3JldHVybiBzLm5leHQ9ci5uZXh0LHZvaWQoci5uZXh0PXMpfXI9ZCxkPWQubmV4dH1pZihhPT09ci5kYXRhLmVuZClyZXR1cm4gdm9pZChyLmRhdGEuZW5kKz1lKTtjb25zdCBzPW5ldyB0KHtzdGFydDphLGVuZDpufSk7ci5uZXh0PXN9Y2xlYXIoKXt0aGlzLl9oZWFkPW51bGx9fWV4cG9ydHthIGFzIEZyZWVMaXN0LHQgYXMgTGlzdH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0XCIuLi8uLi8uLi8uLi8uLi9jb3JlL2hhcy5qc1wiO2ltcG9ydHtkZXN0cm95TWF5YmUgYXMgZX1mcm9tXCIuLi8uLi8uLi8uLi8uLi9jb3JlL21heWJlLmpzXCI7aW1wb3J0e2kxNjE2dG8zMiBhcyB0fWZyb21cIi4uL251bWJlci5qc1wiO2ltcG9ydHtNYXBwZWRCdWZmZXIgYXMgaX1mcm9tXCIuL0J1ZmZlci5qc1wiO2ltcG9ydHt1bnBhY2tEYXRhVmlldyBhcyByfWZyb21cIi4uL3NoYWRlckdyYXBoL3RlY2huaXF1ZXMvbWVzaC9kYXRhVmlld1V0aWxzLmpzXCI7aW1wb3J0e3ZlcnRleExheW91dEhhc2ggYXMgc31mcm9tXCIuLi9zaGFkZXJHcmFwaC90ZWNobmlxdWVzL21lc2gvdXRpbHMuanNcIjtpbXBvcnR7UHJpbWl0aXZlVHlwZSBhcyBmLERhdGFUeXBlIGFzIG99ZnJvbVwiLi4vLi4vLi4vLi4vd2ViZ2wvZW51bXMuanNcIjtpbXBvcnR7VmVydGV4QXJyYXlPYmplY3QgYXMgbn1mcm9tXCIuLi8uLi8uLi8uLi93ZWJnbC9WZXJ0ZXhBcnJheU9iamVjdC5qc1wiO2NvbnN0IHU9MWUzLGE9NCxoPVt7bmFtZTpcInZpc2liaWxpdHlcIixvZmZzZXQ6MCx0eXBlOm8uRkxPQVQsY291bnQ6MX1dLGw9e2hhc2g6cyhoKSxhdHRyaWJ1dGVzOmgsc3RyaWRlOmF9O2Z1bmN0aW9uIF8oZSx0KXtjb25zdCBpPWUuYXR0cmlidXRlcy5maWx0ZXIoKGU9PnQubG9jYXRpb25zLmhhcyhlLm5hbWUpKSkubWFwKCh0PT4oe25hbWU6dC5uYW1lLHR5cGU6dC50eXBlLGNvdW50OnQuY291bnQsZGl2aXNvcjowLG5vcm1hbGl6ZWQ6dC5ub3JtYWxpemVkPz8hMSxvZmZzZXQ6dC5vZmZzZXQsc3RyaWRlOmUuc3RyaWRlfSkpKTtyZXR1cm4gbmV3IE1hcChbW1wiZ2VvbWV0cnlcIixpXV0pfWZ1bmN0aW9uIGQoZSx0KXtjb25zdCBpPVtdLHI9ZS5hdHRyaWJ1dGVzLmZpbHRlcigoZT0+dC5sb2NhdGlvbnMuaGFzKGUubmFtZSkpKTtmb3IoY29uc3QgcyBvZiByKXtpLnB1c2goe25hbWU6cy5uYW1lLHR5cGU6cy50eXBlLGNvdW50OnMuY291bnQsZGl2aXNvcjowLG5vcm1hbGl6ZWQ6cy5ub3JtYWxpemVkPz8hMSxvZmZzZXQ6cy5vZmZzZXQsc3RyaWRlOmUuc3RyaWRlfSk7Y29uc3Qgcj10LmNvbXB1dGVBdHRyaWJ1dGVNYXBbcy5uYW1lXTtudWxsIT1yJiYyPT09ci5sZW5ndGgmJihpLnB1c2goe25hbWU6clswXSxjb3VudDpzLmNvdW50LGRpdmlzb3I6MCx0eXBlOnMudHlwZSxub3JtYWxpemVkOnMubm9ybWFsaXplZD8/ITEsb2Zmc2V0OnMub2Zmc2V0K2Uuc3RyaWRlLHN0cmlkZTplLnN0cmlkZX0pLGkucHVzaCh7bmFtZTpyWzFdLGNvdW50OnMuY291bnQsZGl2aXNvcjowLHR5cGU6cy50eXBlLG5vcm1hbGl6ZWQ6cy5ub3JtYWxpemVkPz8hMSxvZmZzZXQ6cy5vZmZzZXQrMiplLnN0cmlkZSxzdHJpZGU6ZS5zdHJpZGV9KSl9cmV0dXJuIG5ldyBNYXAoW1tcImdlb21ldHJ5XCIsaV1dKX1jbGFzcyB5e2NvbnN0cnVjdG9yKGUsdCxpKXtpZih0aGlzLl9idWZmZXJQb29sPWUsdGhpcy5fbGF5b3V0PXQsdGhpcy51c2VWaXNpYmlsaXR5PWksdGhpcy5faW52YWxpZGF0ZWRHZW9tZXRyeT0hMSx0aGlzLl9pbnZhbGlkYXRlZENvbXB1dGU9ITEsdGhpcy5fcG9zaXRpb249dGhpcy5fbGF5b3V0LmF0dHJpYnV0ZXMuZmluZCgoZT0+XCJwb3NcIj09PWUubmFtZXx8XCJwb3NpdGlvblwiPT09ZS5uYW1lKSksIXRoaXMuX3Bvc2l0aW9uKXRocm93IG5ldyBFcnJvcihcIkludGVybmFsRXJyb3I6IFVuYWJsZSB0byBmaW5kIHBvc2l0aW9uIGF0dHJpYnV0ZVwiKX1kZXN0cm95KCl7dGhpcy5faW5kZXhCdWZmZXI9ZSh0aGlzLl9pbmRleEJ1ZmZlciksdGhpcy5fdmVydGV4QnVmZmVyPWUodGhpcy5fdmVydGV4QnVmZmVyKSx0aGlzLl92aXNpYmlsaXR5QnVmZmVyPWUodGhpcy5fdmlzaWJpbGl0eUJ1ZmZlciksdGhpcy5fY29tcHV0ZVZBTz8uZGlzcG9zZVZBT09ubHkoKSx0aGlzLl9nZW9tZXRyeVZBTz8uZGlzcG9zZVZBT09ubHkoKX1nZXQgbGF5b3V0KCl7cmV0dXJuIHRoaXMuX2xheW91dH1nZXREcmF3QXJncyhlLHQsaSxyKXtyZXR1cm4gcj97cHJpbWl0aXZlOmYuUE9JTlRTLGNvdW50OnQvMyxvZmZzZXQ6aS8zfTp7cHJpbWl0aXZlOmUsY291bnQ6dCxvZmZzZXQ6aX19Z2V0QXR0cmlidXRlUHJlY2lzaW9uUGFja0ZhY3RvcnMoKXtjb25zdCBlPXt9O2Zvcihjb25zdCB0IG9mIHRoaXMubGF5b3V0LmF0dHJpYnV0ZXMpdC5wYWNrUHJlY2lzaW9uRmFjdG9yJiYoZVt0Lm5hbWVdPXQucGFja1ByZWNpc2lvbkZhY3Rvcik7cmV0dXJuIGV9Z2V0RGVidWdWZXJ0ZXhJbmZvKGU9ITEsdCl7aWYoIXRoaXMuX3ZlcnRleEJ1ZmZlcilyZXR1cm4gbnVsbDtjb25zdCBpPXRoaXMuX2xheW91dCxzPWkuc3RyaWRlLGY9dGhpcy5fdmVydGV4QnVmZmVyLmdldFZpZXcoMCx0aGlzLl92ZXJ0ZXhCdWZmZXIuYnl0ZVNpemUpLG89W107aWYoZSlpZihudWxsPT10KWNvbnNvbGUubG9nKFwibXVzdCBwcm92aWRlIGxvY2F0aW9uIGluZm8gdG8gc2VlIGNvbXB1dGUgYXR0cmlidXRlc1wiKTtlbHNlIGZvcihjb25zdCByIG9mIGkuYXR0cmlidXRlcyl7Y29uc3QgZT10LmNvbXB1dGVBdHRyaWJ1dGVNYXBbci5uYW1lXTtudWxsIT1lJiYyPT09ZS5sZW5ndGgmJihvLnB1c2goey4uLnIsbmFtZTplWzBdLG9mZnNldDpyLm9mZnNldCtzfSksby5wdXNoKHsuLi5yLG5hbWU6ZVsxXSxvZmZzZXQ6ci5vZmZzZXQrMipzfSkpfWNvbnN0IG49bmV3IERhdGFWaWV3KGYuc2xpY2UoKS5idWZmZXIpO2xldCB1PWYuYnl0ZUxlbmd0aC9zO2UmJih1PXRoaXMuX2luZGV4QnVmZmVyLmZpbGxQb2ludGVyLzMpO2NvbnN0IGE9dGhpcy5faW5kZXhCdWZmZXIuZ2V0VmlldygwLHRoaXMuX2luZGV4QnVmZmVyLmJ5dGVTaXplKTtsZXQgaD0wO2NvbnN0IGw9W107Zm9yKGxldCBfPTA7Xzx1O18rKyl7aWYoZSl7aD1hWzMqX10qc31jb25zdCB0PXt9O2Zvcihjb25zdCBlIG9mWy4uLmkuYXR0cmlidXRlcywuLi5vXSl7bGV0IGk9YCR7ZS5vZmZzZXR9ICR7ZS5uYW1lfWAscz1yKG4sZSxoKTtpZihlLnBhY2tQcmVjaXNpb25GYWN0b3IpaWYoaSs9YCAocHJlY2lzaW9uOiAke2UucGFja1ByZWNpc2lvbkZhY3Rvcn0pYCxcIm51bWJlclwiPT10eXBlb2YgcylzLz1lLnBhY2tQcmVjaXNpb25GYWN0b3I7ZWxzZSBmb3IobGV0IHQ9MDt0PHMubGVuZ3RoO3QrKylzW3RdLz1lLnBhY2tQcmVjaXNpb25GYWN0b3I7dFtpXT1zfWgrPXMsbC5wdXNoKHQpfXJldHVybnt2ZXJ0aWNlczpsLGxheW91dDppfX1fZW5zdXJlKGUsdCl7aWYodGhpcy5fdmVydGV4QnVmZmVyJiZ0aGlzLl9pbmRleEJ1ZmZlcil0aGlzLl9pbmRleEJ1ZmZlci5lbnN1cmUoTWF0aC5tYXgoZSx1KSksdGhpcy5fdmVydGV4QnVmZmVyLmVuc3VyZShNYXRoLm1heCh0LHUpKSx0aGlzLl92aXNpYmlsaXR5QnVmZmVyJiZ0aGlzLl92aXNpYmlsaXR5QnVmZmVyLmVuc3VyZShNYXRoLm1heCh0LHUpKTtlbHNle2NvbnN0IHI9dGhpcy5fbGF5b3V0LnN0cmlkZS9VaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDt0aGlzLl9pbmRleEJ1ZmZlcj1uZXcgaShcImluZGV4XCIsTWF0aC5tYXgoZSx1KSwxLHRoaXMuX2J1ZmZlclBvb2wpLHRoaXMuX3ZlcnRleEJ1ZmZlcj1uZXcgaShcInZlcnRleFwiLE1hdGgubWF4KHQsdSkscix0aGlzLl9idWZmZXJQb29sKSx0aGlzLnVzZVZpc2liaWxpdHkmJih0aGlzLl92aXNpYmlsaXR5QnVmZmVyPW5ldyBpKFwidmVydGV4XCIsTWF0aC5tYXgodCx1KSxhL1VpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHRoaXMuX2J1ZmZlclBvb2wpKX19YXBwZW5kKGUpe2NvbnN0IHQ9ZS5sYXlvdXQuc3RyaWRlLGk9ZS5pbmRpY2VzLmJ5dGVMZW5ndGgvVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQscj1lLnZlcnRpY2VzLmJ5dGVMZW5ndGgvdDt0aGlzLl9lbnN1cmUoaSxyKTtjb25zdHt2ZXJ0aWNlczpzLGluZGljZXM6Zn09ZSxvPXRoaXMuX3ZlcnRleEJ1ZmZlci5pbnNlcnQocywwLHMuYnl0ZUxlbmd0aC90LDApLG49bmV3IFVpbnQzMkFycmF5KHIpO25ldyBGbG9hdDMyQXJyYXkobi5idWZmZXIpLmZpbGwoMjU1KSx0aGlzLl92aXNpYmlsaXR5QnVmZmVyJiZ0aGlzLl92aXNpYmlsaXR5QnVmZmVyLmluc2VydChuLDAsbi5ieXRlTGVuZ3RoL2EsMCk7cmV0dXJue3ZlcnRleEZyb206byxpbmRleEZyb206dGhpcy5faW5kZXhCdWZmZXIuaW5zZXJ0KGYsMCxmLmJ5dGVMZW5ndGgvNCxvKX19c2V0RW50aXR5UmVjb3JkUmFuZ2VWaXNpYmlsaXR5KGUsdCxpLHIpe2lmKCEodCtpPmUubGVuZ3RoKSlmb3IobGV0IHM9dDtzPHQraTtzKyspe2NvbnN0e3ZlcnRleFN0YXJ0OnQsdmVydGV4Q291bnQ6aX09ZVtzXTt0aGlzLl92aXNpYmlsaXR5QnVmZmVyLnNldEYzMlJhbmdlKHQsdCtpLHIpfX1nZXRFbnRpdHlSZWNvcmRWaXNpYmlsaXR5KGUsdCl7Y29uc3QgaT1lLnJlY29yZHNbdF07cmV0dXJuIHRoaXMuX3Zpc2liaWxpdHlCdWZmZXIuZ2V0RjMyKGkudmVydGV4U3RhcnQpfWNvcHlSZWNvcmRGcm9tKGUsaSxyLHMpe2NvbnN0e2luZGV4U3RhcnQ6ZixpbmRleENvdW50Om8sdmVydGV4U3RhcnQ6bix2ZXJ0ZXhDb3VudDp1fT1pO3RoaXMuX2Vuc3VyZShvLHUpO2NvbnN0IGE9ZS5fcG9zaXRpb24saD1yKihhLnBhY2tQcmVjaXNpb25GYWN0b3I/PzEpLGw9cyooYS5wYWNrUHJlY2lzaW9uRmFjdG9yPz8xKSxfPWEub2Zmc2V0LGQ9dChoLGwpLHk9dGhpcy5fdmVydGV4QnVmZmVyLmNvcHlGcm9tKGUuX3ZlcnRleEJ1ZmZlcixuLHUsZCxfKTt0aGlzLl92aXNpYmlsaXR5QnVmZmVyJiZlLl92aXNpYmlsaXR5QnVmZmVyJiZ0aGlzLl92aXNpYmlsaXR5QnVmZmVyLmNvcHlGcm9tKGUuX3Zpc2liaWxpdHlCdWZmZXIsbix1LDAsMCk7Y29uc3Qgdj10aGlzLl9pbmRleEJ1ZmZlci5jb3B5RnJvbShlLl9pbmRleEJ1ZmZlcixmLG8seS1uLDApLGM9aS5jbG9uZSgpO3JldHVybiBjLnZlcnRleFN0YXJ0PXksYy5pbmRleFN0YXJ0PXYsYy5vdmVybGFwcz0wLGN9cmVtb3ZlKGUsdCxpLHIpe3RoaXMuX2luZGV4QnVmZmVyLmZyZWUoZSx0KSx0aGlzLl92ZXJ0ZXhCdWZmZXIuZnJlZShpLHIpLHRoaXMuX3Zpc2liaWxpdHlCdWZmZXImJnRoaXMuX3Zpc2liaWxpdHlCdWZmZXIuZnJlZShpLHIpfXVwbG9hZCgpe3RoaXMuX2ludmFsaWRhdGVkR2VvbWV0cnk9ITAsdGhpcy5faW52YWxpZGF0ZWRDb21wdXRlPSEwfWdldEdlb21ldHJ5VkFPKGUsdCl7aWYoIXRoaXMuX3ZlcnRleEJ1ZmZlcnx8IXRoaXMuX2luZGV4QnVmZmVyfHwhdGhpcy5fdmVydGV4QnVmZmVyLmJ1ZmZlclNpemUpcmV0dXJuIG51bGw7aWYodGhpcy5faW52YWxpZGF0ZWRHZW9tZXRyeSl7KHRoaXMuX3ZlcnRleEJ1ZmZlci5pbnZhbGlkYXRlZHx8dGhpcy5faW5kZXhCdWZmZXIuaW52YWxpZGF0ZWR8fHRoaXMuX3Zpc2liaWxpdHlCdWZmZXI/LmludmFsaWRhdGVkKSYmKHRoaXMuX3ZlcnRleEJ1ZmZlci5pbnZhbGlkYXRlKCksdGhpcy5faW5kZXhCdWZmZXIuaW52YWxpZGF0ZSgpLHRoaXMuX3Zpc2liaWxpdHlCdWZmZXImJnRoaXMuX3Zpc2liaWxpdHlCdWZmZXIuaW52YWxpZGF0ZSgpLHRoaXMuX2dlb21ldHJ5VkFPPy5kaXNwb3NlVkFPT25seSgpLHRoaXMuX2dlb21ldHJ5VkFPPW51bGwpLHRoaXMuX3ZlcnRleEJ1ZmZlci51cGxvYWQoKSx0aGlzLl9pbmRleEJ1ZmZlci51cGxvYWQoKSx0aGlzLl92aXNpYmlsaXR5QnVmZmVyJiZ0aGlzLl92aXNpYmlsaXR5QnVmZmVyLnVwbG9hZCgpO2NvbnN0IGk9dGhpcy5faW5kZXhCdWZmZXIuZ2V0R1BVQnVmZmVyKGUsITEpLHI9bmV3IE1hcChbW1wiZ2VvbWV0cnlcIix0aGlzLl92ZXJ0ZXhCdWZmZXIuZ2V0R1BVQnVmZmVyKGUpXV0pO2lmKHRoaXMuX3Zpc2liaWxpdHlCdWZmZXImJnIuc2V0KFwidmlzaWJpbGl0eVwiLHRoaXMuX3Zpc2liaWxpdHlCdWZmZXIuZ2V0R1BVQnVmZmVyKGUpKSwhdGhpcy5fZ2VvbWV0cnlWQU8pe2NvbnN0IHM9Xyh0aGlzLmxheW91dCx0KTtzLnNldChcInZpc2liaWxpdHlcIixfKGwsdCkuZ2V0KFwiZ2VvbWV0cnlcIikpLHRoaXMuX2dlb21ldHJ5VkFPPW5ldyBuKGUsdC5sb2NhdGlvbnMscyxyLGkpfXRoaXMuX2ludmFsaWRhdGVkR2VvbWV0cnk9ITF9cmV0dXJuIHRoaXMuX2dlb21ldHJ5VkFPfWdldENvbXB1dGVWQU8oZSx0KXtpZighdGhpcy5fdmVydGV4QnVmZmVyfHwhdGhpcy5faW5kZXhCdWZmZXJ8fCF0aGlzLl92ZXJ0ZXhCdWZmZXIuYnVmZmVyU2l6ZSlyZXR1cm4gbnVsbDtpZih0aGlzLl9pbnZhbGlkYXRlZENvbXB1dGUpeyh0aGlzLl92ZXJ0ZXhCdWZmZXIuaW52YWxpZGF0ZWR8fHRoaXMuX2luZGV4QnVmZmVyLmludmFsaWRhdGVkQ29tcHV0ZUJ1ZmZlcikmJih0aGlzLl92ZXJ0ZXhCdWZmZXIuaW52YWxpZGF0ZSgpLHRoaXMuX2luZGV4QnVmZmVyLmludmFsaWRhdGUoKSx0aGlzLl92aXNpYmlsaXR5QnVmZmVyJiZ0aGlzLl92aXNpYmlsaXR5QnVmZmVyLmludmFsaWRhdGUoKSx0aGlzLl9jb21wdXRlVkFPPy5kaXNwb3NlVkFPT25seSgpLHRoaXMuX2NvbXB1dGVWQU89bnVsbCksdGhpcy5fdmVydGV4QnVmZmVyLnVwbG9hZCgpLHRoaXMuX2luZGV4QnVmZmVyLnVwbG9hZCgpLHRoaXMuX3Zpc2liaWxpdHlCdWZmZXImJnRoaXMuX3Zpc2liaWxpdHlCdWZmZXIudXBsb2FkKCk7Y29uc3QgaT10aGlzLl9pbmRleEJ1ZmZlci5nZXRHUFVCdWZmZXIoZSwhMCkscj1uZXcgTWFwKFtbXCJnZW9tZXRyeVwiLHRoaXMuX3ZlcnRleEJ1ZmZlci5nZXRHUFVCdWZmZXIoZSldXSk7aWYodGhpcy5fdmlzaWJpbGl0eUJ1ZmZlciYmci5zZXQoXCJ2aXNpYmlsaXR5XCIsdGhpcy5fdmlzaWJpbGl0eUJ1ZmZlci5nZXRHUFVCdWZmZXIoZSkpLCF0aGlzLl9jb21wdXRlVkFPKXtjb25zdCBzPWQodGhpcy5sYXlvdXQsdCk7cy5zZXQoXCJ2aXNpYmlsaXR5XCIsXyhsLHQpLmdldChcImdlb21ldHJ5XCIpKSx0aGlzLl9jb21wdXRlVkFPPW5ldyBuKGUsdC5sb2NhdGlvbnMscyxyLGkpLHRoaXMuX2ludmFsaWRhdGVkQ29tcHV0ZT0hMX19cmV0dXJuIHRoaXMuX2NvbXB1dGVWQU99Z2V0IG1lbW9yeVN0YXRzKCl7cmV0dXJue2J5dGVzVXNlZDp0aGlzLl92ZXJ0ZXhCdWZmZXIubWVtb3J5U3RhdHMuYnl0ZXNVc2VkK3RoaXMuX2luZGV4QnVmZmVyLm1lbW9yeVN0YXRzLmJ5dGVzVXNlZCxieXRlc1Jlc2VydmVkOnRoaXMuX3ZlcnRleEJ1ZmZlci5tZW1vcnlTdGF0cy5ieXRlc1Jlc2VydmVkK3RoaXMuX2luZGV4QnVmZmVyLm1lbW9yeVN0YXRzLmJ5dGVzUmVzZXJ2ZWQsdmVydGV4OnRoaXMuX3ZlcnRleEJ1ZmZlci5tZW1vcnlTdGF0cyxpbmRleDp0aGlzLl9pbmRleEJ1ZmZlci5tZW1vcnlTdGF0c319cmVzaHVmZmxlKGUpe3RoaXMuX3ZlcnRleEJ1ZmZlciYmdGhpcy5fdmVydGV4QnVmZmVyLnJlc2h1ZmZsZShlLnZlcnRleC5jb3VudCxlLnZlcnRleC5vcGVyYXRpb25zKSx0aGlzLl9pbmRleEJ1ZmZlciYmdGhpcy5faW5kZXhCdWZmZXIucmVzaHVmZmxlKGUuaW5kZXguY291bnQsZS5pbmRleC5vcGVyYXRpb25zKSx0aGlzLl92aXNpYmlsaXR5QnVmZmVyJiZ0aGlzLl92aXNpYmlsaXR5QnVmZmVyLnJlc2h1ZmZsZShlLnZlcnRleC5jb3VudCxlLnZlcnRleC5vcGVyYXRpb25zKX19ZXhwb3J0e3kgYXMgTWFwcGVkTWVzaH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0IHQgZnJvbVwiLi4vRGlzcGxheUVudGl0eS5qc1wiO2ltcG9ydHtMYWJlbE1ldHJpYyBhcyBlfWZyb21cIi4uL2NvbGxpc2lvbnMvTGFiZWxNZXRyaWMuanNcIjtpbXBvcnR7dW5wYWNrRGF0YVZpZXcgYXMgaX1mcm9tXCIuLi9zaGFkZXJHcmFwaC90ZWNobmlxdWVzL21lc2gvZGF0YVZpZXdVdGlscy5qc1wiO2ltcG9ydCByIGZyb21cIi4uL3V0aWwvUmVhZGVyLmpzXCI7aW1wb3J0e2Rlc2VyaWFsaXplTGlzdCBhcyBvfWZyb21cIi4uL3V0aWwvc2VyaWFsaXphdGlvblV0aWxzLmpzXCI7ZnVuY3Rpb24gcyhlKXtpZighZSlyZXR1cm4gbnVsbDtyZXR1cm57ZW50aXRpZXM6byhuZXcgcihlLmVudGl0aWVzKSx0KSx2ZXJ0ZXhEYXRhOmUuZGF0YS5tYXAoYSl9fWZ1bmN0aW9uIGEodCl7Y29uc3Qgcz10LmxheW91dC5zdHJpZGUsYT1uZXcgRGF0YVZpZXcodC52ZXJ0aWNlcyksbj1bXSxjPXQudmVydGljZXMuYnl0ZUxlbmd0aC9zO2xldCBsPTA7Zm9yKGxldCBlPTA7ZTxjO2UrKyl7Y29uc3QgZT17fTtmb3IoY29uc3QgciBvZiB0LmxheW91dC5hdHRyaWJ1dGVzKXtsZXQgdD1gJHtyLm9mZnNldH0gJHtyLm5hbWV9YCxvPWkoYSxyLGwpO2lmKHIucGFja1ByZWNpc2lvbkZhY3RvcilpZih0Kz1gIChwcmVjaXNpb246ICR7ci5wYWNrUHJlY2lzaW9uRmFjdG9yfSlgLFwibnVtYmVyXCI9PXR5cGVvZiBvKW8vPXIucGFja1ByZWNpc2lvbkZhY3RvcjtlbHNlIGZvcihsZXQgZT0wO2U8by5sZW5ndGg7ZSsrKW9bZV0vPXIucGFja1ByZWNpc2lvbkZhY3RvcjtlW3RdPW99bCs9cyxuLnB1c2goZSl9Y29uc3QgZj10Lm1ldHJpY3M/byhuZXcgcih0Lm1ldHJpY3MpLGUpPz9bXTpbXTtyZXR1cm57dmVydGljZXM6bixsYXlvdXQ6dC5sYXlvdXQsbWV0cmljczpmfX1leHBvcnR7cyBhcyBkZWJ1Z01lc2hEYXRhSW5mb307XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e3Jlc29sdmVJbmNsdWRlcyBhcyByfWZyb21cIi4vc291cmNlcy9yZXNvbHZlci5qc1wiO2NvbnN0IGU9e3NoYWRlcnM6e3ZlcnRleFNoYWRlcjpyKFwiYmFja2dyb3VuZC9iYWNrZ3JvdW5kLnZlcnRcIiksZnJhZ21lbnRTaGFkZXI6cihcImJhY2tncm91bmQvYmFja2dyb3VuZC5mcmFnXCIpfSxhdHRyaWJ1dGVzOm5ldyBNYXAoW1tcImFfcG9zXCIsMF1dKX07ZXhwb3J0e2UgYXMgYmFja2dyb3VuZH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e3Jlc29sdmVJbmNsdWRlcyBhcyBlfWZyb21cIi4vc291cmNlcy9yZXNvbHZlci5qc1wiO2NvbnN0IHI9e3NoYWRlcnM6e3ZlcnRleFNoYWRlcjplKFwidGlsZUluZm8vdGlsZUluZm8udmVydFwiKSxmcmFnbWVudFNoYWRlcjplKFwidGlsZUluZm8vdGlsZUluZm8uZnJhZ1wiKX0sYXR0cmlidXRlczpuZXcgTWFwKFtbXCJhX3Bvc1wiLDBdXSl9O2V4cG9ydHtyIGFzIHRpbGVJbmZvfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjMzL2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnQgciBmcm9tXCIuL3NoYWRlclJlcG9zaXRvcnkuanNcIjtpbXBvcnR7U2hhZGVyQ29tcGlsZXIgYXMgZX1mcm9tXCIuLi8uLi8uLi8uLi8uLi93ZWJnbC9TaGFkZXJDb21waWxlci5qc1wiO2Z1bmN0aW9uIG8ocil7cmV0dXJuIGZ1bmN0aW9uKGUpe2xldCBvPXI7cmV0dXJuIGUuc3BsaXQoXCIvXCIpLmZvckVhY2goKHI9PntvJiYobz1vW3JdKX0pKSxvfX1jb25zdCB0PW5ldyBlKG8ocikpO2Z1bmN0aW9uIG4ocil7cmV0dXJuIHQucmVzb2x2ZUluY2x1ZGVzKHIpfWV4cG9ydHtuIGFzIHJlc29sdmVJbmNsdWRlc307XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuY29uc3QgZT17YmFja2dyb3VuZDp7XCJiYWNrZ3JvdW5kLmZyYWdcIjpcInVuaWZvcm0gbG93cCB2ZWM0IHVfY29sb3I7XFxudm9pZCBtYWluKCkge1xcbmdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XFxufVwiLFwiYmFja2dyb3VuZC52ZXJ0XCI6XCJhdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kdnNNYXQzO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVfY29vcmRfcmFuZ2U7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfZGVwdGg7XFxudm9pZCBtYWluKCkge1xcbnZlYzMgdl9wb3MgPSB1X2R2c01hdDMgKiB2ZWMzKHVfY29vcmRfcmFuZ2UgKiBhX3BvcywgMS4wKTtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQodl9wb3MueHksIDAuMCwgMS4wKTtcXG59XCJ9LGJpdEJsaXQ6e1wiYml0QmxpdC5mcmFnXCI6XCJ1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIHVfdGV4O1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X29wYWNpdHk7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl91djtcXG52b2lkIG1haW4oKSB7XFxubG93cCB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4LCB2X3V2KTtcXG5nbF9GcmFnQ29sb3IgPSBjb2xvciAqIHVfb3BhY2l0eTtcXG59XCIsXCJiaXRCbGl0LnZlcnRcIjpcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4O1xcbnZhcnlpbmcgbWVkaXVtcCB2ZWMyIHZfdXY7XFxudm9pZCBtYWluKHZvaWQpIHtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQoYV9wb3MgLCAwLjAsIDEuMCk7XFxudl91diA9IGFfdGV4O1xcbn1cIn0sZGVidWc6e292ZXJsYXk6e1wib3ZlcmxheS5mcmFnXCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52b2lkIG1haW4odm9pZCkge1xcbmdsX0ZyYWdDb2xvciA9IHZfY29sb3I7XFxufVwiLFwib3ZlcmxheS52ZXJ0XCI6XCJhdHRyaWJ1dGUgdmVjMyBhX1Bvc2l0aW9uQW5kRmxhZ3M7XFxudW5pZm9ybSBtYXQzIHVfZHZzTWF0MztcXG51bmlmb3JtIHZlYzQgdV9jb2xvcnNbNF07XFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdGllc1s0XTtcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52b2lkIG1haW4odm9pZCkge1xcbnZlYzIgcG9zaXRpb24gPSBhX1Bvc2l0aW9uQW5kRmxhZ3MueHk7XFxuZmxvYXQgZmxhZ3MgPSBhX1Bvc2l0aW9uQW5kRmxhZ3MuejtcXG5pbnQgY29sb3JJbmRleCA9IGludChtb2QoZmxhZ3MsIDQuMCkpO1xcbnZlYzQgY29sb3I7XFxuZm9yIChpbnQgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG5jb2xvciA9IHVfY29sb3JzW2ldO1xcbmlmIChpID09IGNvbG9ySW5kZXgpIHtcXG5icmVhaztcXG59XFxufVxcbmludCBvcGFjaXR5SW5kZXggPSBpbnQobW9kKGZsb29yKGZsYWdzIC8gNC4wKSwgNC4wKSk7XFxuZmxvYXQgb3BhY2l0eTtcXG5mb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKykge1xcbm9wYWNpdHkgPSB1X29wYWNpdGllc1tpXTtcXG5pZiAoaSA9PSBvcGFjaXR5SW5kZXgpIHtcXG5icmVhaztcXG59XFxufVxcbnZfY29sb3IgPSBjb2xvciAqIG9wYWNpdHk7XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KCh1X2R2c01hdDMgKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbn1cIn19LGRvdDp7ZG90OntcImRvdC5mcmFnXCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIGZsb2F0IHZfZG90UmF0aW87XFxudmFyeWluZyBmbG9hdCB2X2ludkVkZ2VSYXRpbztcXG51bmlmb3JtIGhpZ2hwIGZsb2F0IHVfdGlsZVpvb21GYWN0b3I7XFxudm9pZCBtYWluKClcXG57XFxuZmxvYXQgZGlzdCA9IGxlbmd0aChnbF9Qb2ludENvb3JkIC0gdmVjMiguNSwgLjUpKSAqIDIuO1xcbmZsb2F0IGFscGhhID0gc21vb3Roc3RlcCgwLiwgMS4sIHZfaW52RWRnZVJhdGlvICogKGRpc3QgLSB2X2RvdFJhdGlvKSArIDEuKTtcXG5nbF9GcmFnQ29sb3IgPSB2X2NvbG9yICogYWxwaGE7XFxufVwiLFwiZG90LnZlcnRcIjpcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxudW5pZm9ybSBoaWdocCBtYXQzIHVfZHZzTWF0MztcXG51bmlmb3JtIGhpZ2hwIGZsb2F0IHVfdGlsZVpvb21GYWN0b3I7XFxudW5pZm9ybSBoaWdocCBmbG9hdCB1X2RvdFNpemU7XFxudW5pZm9ybSBoaWdocCBmbG9hdCB1X3BpeGVsUmF0aW87XFxudmFyeWluZyB2ZWMyIHZfcG9zO1xcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9kb3RSYXRpbztcXG52YXJ5aW5nIGZsb2F0IHZfaW52RWRnZVJhdGlvO1xcbmNvbnN0IGZsb2F0IEVQU0lMT04gPSAwLjAwMDAwMTtcXG52b2lkIG1haW4oKVxcbntcXG5tYXQzIHRpbGVUb1RpbGVUZXh0dXJlID0gbWF0MyggIDEuLCAwLiwgMC4sXFxuMC4sIC0xLiwgMC4sXFxuMC4sIDEuLCAxLiAgKTtcXG52ZWMzIHRleENvb3JkcyA9IHRpbGVUb1RpbGVUZXh0dXJlICogdmVjMyhhX3Bvcy54eSAvIDUxMi4sIDEuKTtcXG52X2NvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdGV4Q29vcmRzLnh5KTtcXG5mbG9hdCBzbW9vdGhFZGdlV2lkdGggPSBtYXgodV9kb3RTaXplIC8gMi4sIDEuKSA7XFxuZmxvYXQgeiA9IDAuO1xcbnogKz0gMi4wICogc3RlcCh2X2NvbG9yLmEsIEVQU0lMT04pO1xcbmdsX1BvaW50U2l6ZSA9IChzbW9vdGhFZGdlV2lkdGggKyB1X2RvdFNpemUpO1xcbmdsX1Bvc2l0aW9uID0gdmVjNCgodV9kdnNNYXQzICogdmVjMyhhX3BvcyArIC41LCAxLikpLnh5LCB6LCAxLik7XFxudl9kb3RSYXRpbyA9IHVfZG90U2l6ZSAvIGdsX1BvaW50U2l6ZTtcXG52X2ludkVkZ2VSYXRpbyA9IC0xLiAvICggc21vb3RoRWRnZVdpZHRoIC8gZ2xfUG9pbnRTaXplICk7XFxuZ2xfUG9pbnRTaXplICAqPSAodV9waXhlbFJhdGlvICogdV90aWxlWm9vbUZhY3Rvcik7XFxufVwifX0sZmlsdGVyaW5nOntcImJpY3ViaWMuZ2xzbFwiOlwidmVjNCBjb21wdXRlV2VpZ2h0cyhmbG9hdCB2KSB7XFxuZmxvYXQgYiA9IDEuMCAvIDYuMDtcXG5mbG9hdCB2MiA9IHYgKiB2O1xcbmZsb2F0IHYzID0gdjIgKiB2O1xcbmZsb2F0IHcwID0gYiAqICgtdjMgKyAzLjAgKiB2MiAtIDMuMCAqIHYgKyAxLjApO1xcbmZsb2F0IHcxID0gYiAqICgzLjAgKiB2MyAgLSA2LjAgKiB2MiArIDQuMCk7XFxuZmxvYXQgdzIgPSBiICogKC0zLjAgKiB2MyArIDMuMCAqIHYyICsgMy4wICogdiArIDEuMCk7XFxuZmxvYXQgdzMgPSBiICogdjM7XFxucmV0dXJuIHZlYzQodzAsIHcxLCB3MiwgdzMpO1xcbn1cXG52ZWM0IGJpY3ViaWNPZmZzZXRzQW5kV2VpZ2h0cyhmbG9hdCB2KSB7XFxudmVjNCB3ID0gY29tcHV0ZVdlaWdodHModik7XFxuZmxvYXQgZzAgPSB3LnggKyB3Lnk7XFxuZmxvYXQgZzEgPSB3LnogKyB3Lnc7XFxuZmxvYXQgaDAgPSAxLjAgLSAody55IC8gZzApICsgdjtcXG5mbG9hdCBoMSA9IDEuMCArICh3LncgLyBnMSkgLSB2O1xcbnJldHVybiB2ZWM0KGgwLCBoMSwgZzAsIGcxKTtcXG59XFxudmVjNCBzYW1wbGVCaWN1YmljQlNwbGluZShzYW1wbGVyMkQgc2FtcGxlciwgdmVjMiBjb29yZHMsIHZlYzIgdGV4U2l6ZSkge1xcbnZlYzIgZVggPSB2ZWMyKDEuMCAvIHRleFNpemUueCwgMC4wKTtcXG52ZWMyIGVZID0gdmVjMigwLjAsIDEuMCAvIHRleFNpemUueSk7XFxudmVjMiB0ZXhlbCA9IGNvb3JkcyAqIHRleFNpemUgLSAwLjU7XFxudmVjMyBoZ1ggPSBiaWN1YmljT2Zmc2V0c0FuZFdlaWdodHMoZnJhY3QodGV4ZWwpLngpLnh5ejtcXG52ZWMzIGhnWSA9IGJpY3ViaWNPZmZzZXRzQW5kV2VpZ2h0cyhmcmFjdCh0ZXhlbCkueSkueHl6O1xcbnZlYzIgY29vcmRzMTAgPSBjb29yZHMgKyBoZ1gueCAqIGVYO1xcbnZlYzIgY29vcmRzMDAgPSBjb29yZHMgLSBoZ1gueSAqIGVYO1xcbnZlYzIgY29vcmRzMTEgPSBjb29yZHMxMCArIGhnWS54ICogZVk7XFxudmVjMiBjb29yZHMwMSA9IGNvb3JkczAwICsgaGdZLnggKiBlWTtcXG5jb29yZHMxMCA9IGNvb3JkczEwIC0gaGdZLnkgKiBlWTtcXG5jb29yZHMwMCA9IGNvb3JkczAwIC0gaGdZLnkgKiBlWTtcXG52ZWM0IGNvbG9yMDAgPSB0ZXh0dXJlMkQoc2FtcGxlciwgY29vcmRzMDApO1xcbnZlYzQgY29sb3IxMCA9IHRleHR1cmUyRChzYW1wbGVyLCBjb29yZHMxMCk7XFxudmVjNCBjb2xvcjAxID0gdGV4dHVyZTJEKHNhbXBsZXIsIGNvb3JkczAxKTtcXG52ZWM0IGNvbG9yMTEgPSB0ZXh0dXJlMkQoc2FtcGxlciwgY29vcmRzMTEpO1xcbmNvbG9yMDAgPSBtaXgoY29sb3IwMCwgY29sb3IwMSwgaGdZLnopO1xcbmNvbG9yMTAgPSBtaXgoY29sb3IxMCwgY29sb3IxMSwgaGdZLnopO1xcbmNvbG9yMDAgPSBtaXgoY29sb3IwMCwgY29sb3IxMCwgaGdYLnopO1xcbnJldHVybiBjb2xvcjAwO1xcbn1cIixcImJpbGluZWFyLmdsc2xcIjpcInZlYzQgc2FtcGxlQmlsaW5lYXIoc2FtcGxlcjJEIHNhbXBsZXIsIHZlYzIgY29vcmRzLCB2ZWMyIHRleFNpemUpIHtcXG52ZWMyIHRleGVsU3RhcnQgPSBmbG9vcihjb29yZHMgKiB0ZXhTaXplKTtcXG52ZWMyIGNvb3JkMCA9IHRleGVsU3RhcnQgLyB0ZXhTaXplO1xcbnZlYzIgY29vcmQxID0gKHRleGVsU3RhcnQgKyAgdmVjMigxLjAsIDAuMCkpIC8gdGV4U2l6ZTtcXG52ZWMyIGNvb3JkMiA9ICh0ZXhlbFN0YXJ0ICsgIHZlYzIoMC4wLCAxLjApKSAvIHRleFNpemU7XFxudmVjMiBjb29yZDMgPSAodGV4ZWxTdGFydCArICB2ZWMyKDEuMCwgMS4wKSkgLyB0ZXhTaXplO1xcbnZlYzQgY29sb3IwID0gdGV4dHVyZTJEKHNhbXBsZXIsIGNvb3JkMCk7XFxudmVjNCBjb2xvcjEgPSB0ZXh0dXJlMkQoc2FtcGxlciwgY29vcmQxKTtcXG52ZWM0IGNvbG9yMiA9IHRleHR1cmUyRChzYW1wbGVyLCBjb29yZDIpO1xcbnZlYzQgY29sb3IzID0gdGV4dHVyZTJEKHNhbXBsZXIsIGNvb3JkMyk7XFxudmVjMiBibGVuZCA9IGZyYWN0KGNvb3JkcyAqIHRleFNpemUpO1xcbnZlYzQgY29sb3IwMSA9IG1peChjb2xvcjAsIGNvbG9yMSwgYmxlbmQueCk7XFxudmVjNCBjb2xvcjIzID0gbWl4KGNvbG9yMiwgY29sb3IzLCBibGVuZC54KTtcXG52ZWM0IGNvbG9yID0gbWl4KGNvbG9yMDEsIGNvbG9yMjMsIGJsZW5kLnkpO1xcbiNpZmRlZiBOTkVER0VcXG5mbG9hdCBhbHBoYSA9IGZsb29yKGNvbG9yMC5hICogY29sb3IxLmEgKiBjb2xvcjIuYSAqIGNvbG9yMy5hICsgMC41KTtcXG5jb2xvciA9IGNvbG9yICogYWxwaGEgKyAoMS4wIC0gYWxwaGEpICogdGV4dHVyZTJEKHNhbXBsZXIsIGNvb3Jkcyk7XFxuI2VuZGlmXFxucmV0dXJuIGNvbG9yO1xcbn1cIixcImVweC5nbHNsXCI6XCJ2ZWM0IHNhbXBsZUVQWChzYW1wbGVyMkQgc2FtcGxlciwgZmxvYXQgc2l6ZSwgdmVjMiBjb29yZHMsIHZlYzIgdGV4U2l6ZSkge1xcbnZlYzIgaW52U2l6ZSA9IDEuMCAvIHRleFNpemU7XFxudmVjMiB0ZXhlbCA9IGNvb3JkcyAqIHRleFNpemU7XFxudmVjMiB0ZXhlbF9pID0gZmxvb3IodGV4ZWwpO1xcbnZlYzIgdGV4ZWxfZnJhYyA9IGZyYWN0KHRleGVsKTtcXG52ZWM0IGNvbG9yUCA9IHRleHR1cmUyRChzYW1wbGVyLCB0ZXhlbF9pICogaW52U2l6ZSk7XFxudmVjNCBjb2xvclAxID0gdmVjNChjb2xvclApO1xcbnZlYzQgY29sb3JQMiA9IHZlYzQoY29sb3JQKTtcXG52ZWM0IGNvbG9yUDMgPSB2ZWM0KGNvbG9yUCk7XFxudmVjNCBjb2xvclA0ID0gdmVjNChjb2xvclApO1xcbnZlYzQgY29sb3JBID0gdGV4dHVyZTJEKHNhbXBsZXIsICh0ZXhlbF9pIC0gdmVjMigwLjAsIDEuMCkpICogaW52U2l6ZSk7XFxudmVjNCBjb2xvckIgPSB0ZXh0dXJlMkQoc2FtcGxlciwgKHRleGVsX2kgKyB2ZWMyKDEuMCwgMC4wKSkgKiBpbnZTaXplKTtcXG52ZWM0IGNvbG9yQyA9IHRleHR1cmUyRChzYW1wbGVyLCAodGV4ZWxfaSAtIHZlYzIoMS4wLCAwLjApKSAqIGludlNpemUpO1xcbnZlYzQgY29sb3JEID0gdGV4dHVyZTJEKHNhbXBsZXIsICh0ZXhlbF9pICsgdmVjMigwLjAsIDEuMCkpICogaW52U2l6ZSk7XFxuaWYgKGNvbG9yQyA9PSBjb2xvckEgJiYgY29sb3JDICE9IGNvbG9yRCAmJiBjb2xvckEgIT0gY29sb3JCKSB7XFxuY29sb3JQMSA9IGNvbG9yQTtcXG59XFxuaWYgKGNvbG9yQSA9PSBjb2xvckIgJiYgY29sb3JBICE9IGNvbG9yQyAmJiBjb2xvckIgIT0gY29sb3JEKSB7XFxuY29sb3JQMiA9IGNvbG9yQjtcXG59XFxuaWYgKGNvbG9yRCA9PSBjb2xvckMgJiYgY29sb3JEICE9IGNvbG9yQiAmJiBjb2xvckMgIT0gY29sb3JBKSB7XFxuY29sb3JQMyA9IGNvbG9yQztcXG59XFxuaWYgKGNvbG9yQiA9PSBjb2xvckQgJiYgY29sb3JCICE9IGNvbG9yQSAmJiBjb2xvckQgIT0gY29sb3JDKSB7XFxuY29sb3JQNCA9IGNvbG9yRDtcXG59XFxudmVjNCBjb2xvclAxMiA9IG1peChjb2xvclAxLCBjb2xvclAyLCB0ZXhlbF9mcmFjLngpO1xcbnZlYzQgY29sb3JQMzQgPSBtaXgoY29sb3JQMSwgY29sb3JQMiwgdGV4ZWxfZnJhYy54KTtcXG5yZXR1cm4gbWl4KGNvbG9yUDEyLCBjb2xvclAzNCwgdGV4ZWxfZnJhYy55KTtcXG59XCJ9LGhlYXRtYXA6e2hlYXRtYXBSZXNvbHZlOntcImhlYXRtYXBSZXNvbHZlLmZyYWdcIjpcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jaWZkZWYgSEVBVE1BUF9QUkVDSVNJT05fSEFMRl9GTE9BVFxcbiNkZWZpbmUgQ09NUFJFU1NJT05fRkFDVE9SIDQuMFxcbiNlbHNlXFxuI2RlZmluZSBDT01QUkVTU0lPTl9GQUNUT1IgMS4wXFxuI2VuZGlmXFxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfZ3JhZGllbnQ7XFxudW5pZm9ybSB2ZWMyIHVfZGVuc2l0eU1pbkFuZEludlJhbmdlO1xcbnVuaWZvcm0gZmxvYXQgdV9kZW5zaXR5Tm9ybWFsaXphdGlvbjtcXG52YXJ5aW5nIHZlYzIgdl91djtcXG52b2lkIG1haW4oKSB7XFxudmVjNCBkYXRhID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl91dik7XFxuZmxvYXQgZGVuc2l0eSA9IGRhdGEuciAqIENPTVBSRVNTSU9OX0ZBQ1RPUjtcXG5kZW5zaXR5ICo9IHVfZGVuc2l0eU5vcm1hbGl6YXRpb247XFxuZGVuc2l0eSA9IChkZW5zaXR5IC0gdV9kZW5zaXR5TWluQW5kSW52UmFuZ2UueCkgKiB1X2RlbnNpdHlNaW5BbmRJbnZSYW5nZS55O1xcbnZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV9ncmFkaWVudCwgdmVjMihkZW5zaXR5LCAwLjUpKTtcXG5nbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiAqIGNvbG9yLmEsIGNvbG9yLmEpO1xcbn1cIixcImhlYXRtYXBSZXNvbHZlLnZlcnRcIjpcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG52YXJ5aW5nIHZlYzIgdl91djtcXG52b2lkIG1haW4oKSB7XFxudl91diA9IGFfcG9zO1xcbmdsX1Bvc2l0aW9uID0gdmVjNChhX3BvcyAqIDIuMCAtIDEuMCwgMS4sIDEuKTtcXG59XCJ9fSxoaWdobGlnaHQ6e1wiYmx1ci5mcmFnXCI6XCJ2YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RleGNvb3JkO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IHVfZGlyZWN0aW9uO1xcbnVuaWZvcm0gbWVkaXVtcCBtYXQ0IHVfY2hhbm5lbFNlbGVjdG9yO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X3NpZ21hO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5tZWRpdW1wIGZsb2F0IGdhdXNzMShtZWRpdW1wIHZlYzIgZGlyKSB7XFxucmV0dXJuIGV4cCgtZG90KGRpciwgZGlyKSAvICgyLjAgKiB1X3NpZ21hICogdV9zaWdtYSkpO1xcbn1cXG5tZWRpdW1wIHZlYzQgc2VsZWN0Q2hhbm5lbChtZWRpdW1wIHZlYzQgc2FtcGxlKSB7XFxucmV0dXJuIHVfY2hhbm5lbFNlbGVjdG9yICogc2FtcGxlO1xcbn1cXG52b2lkIGFjY3VtR2F1c3MxKG1lZGl1bXAgZmxvYXQgaSwgaW5vdXQgbWVkaXVtcCBmbG9hdCB0b3QsIGlub3V0IG1lZGl1bXAgZmxvYXQgd2VpZ2h0KSB7XFxubWVkaXVtcCBmbG9hdCB3ID0gZ2F1c3MxKGkgKiB1X2RpcmVjdGlvbi54eSk7XFxudG90ICs9IHNlbGVjdENoYW5uZWwodGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXhjb29yZCArIGkgKiB1X2RpcmVjdGlvbi56dykpWzNdICogdztcXG53ZWlnaHQgKz0gdztcXG59XFxudm9pZCBtYWluKHZvaWQpIHtcXG5tZWRpdW1wIGZsb2F0IHRvdCA9IDAuMDtcXG5tZWRpdW1wIGZsb2F0IHdlaWdodCA9IDAuMDtcXG5hY2N1bUdhdXNzMSgtNS4wLCB0b3QsIHdlaWdodCk7XFxuYWNjdW1HYXVzczEoLTQuMCwgdG90LCB3ZWlnaHQpO1xcbmFjY3VtR2F1c3MxKC0zLjAsIHRvdCwgd2VpZ2h0KTtcXG5hY2N1bUdhdXNzMSgtMi4wLCB0b3QsIHdlaWdodCk7XFxuYWNjdW1HYXVzczEoLTEuMCwgdG90LCB3ZWlnaHQpO1xcbmFjY3VtR2F1c3MxKDAuMCwgdG90LCB3ZWlnaHQpO1xcbmFjY3VtR2F1c3MxKDEuMCwgdG90LCB3ZWlnaHQpO1xcbmFjY3VtR2F1c3MxKDIuMCwgdG90LCB3ZWlnaHQpO1xcbmFjY3VtR2F1c3MxKDMuMCwgdG90LCB3ZWlnaHQpO1xcbmFjY3VtR2F1c3MxKDQuMCwgdG90LCB3ZWlnaHQpO1xcbmFjY3VtR2F1c3MxKDUuMCwgdG90LCB3ZWlnaHQpO1xcbmdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgdG90IC8gd2VpZ2h0KTtcXG59XCIsXCJoaWdobGlnaHQuZnJhZ1wiOlwidmFyeWluZyBtZWRpdW1wIHZlYzIgdl90ZXhjb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfc2lnbWE7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9zaGFkZTtcXG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1X21pbk1heERpc3RhbmNlO1xcbm1lZGl1bXAgZmxvYXQgZXN0aW1hdGVEaXN0YW5jZSgpIHtcXG5tZWRpdW1wIGZsb2F0IHkgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3RleGNvb3JkKVszXTtcXG5jb25zdCBtZWRpdW1wIGZsb2F0IHkwID0gMC41O1xcbm1lZGl1bXAgZmxvYXQgbTAgPSAxLjAgLyAoc3FydCgyLjAgKiAzLjE0MTUpICogdV9zaWdtYSk7XFxubWVkaXVtcCBmbG9hdCBkID0gKHkgLSB5MCkgLyBtMDtcXG5yZXR1cm4gZDtcXG59XFxubWVkaXVtcCB2ZWM0IHNoYWRlKG1lZGl1bXAgZmxvYXQgZCkge1xcbm1lZGl1bXAgZmxvYXQgbWFwcGVkRGlzdGFuY2UgPSAoZCAtIHVfbWluTWF4RGlzdGFuY2UueCkgLyAodV9taW5NYXhEaXN0YW5jZS55IC0gdV9taW5NYXhEaXN0YW5jZS54KTtcXG5tYXBwZWREaXN0YW5jZSA9IGNsYW1wKG1hcHBlZERpc3RhbmNlLCAwLjAsIDEuMCk7XFxucmV0dXJuIHRleHR1cmUyRCh1X3NoYWRlLCB2ZWMyKG1hcHBlZERpc3RhbmNlLCAwLjUpKTtcXG59XFxudm9pZCBtYWluKHZvaWQpIHtcXG5tZWRpdW1wIGZsb2F0IGQgPSBlc3RpbWF0ZURpc3RhbmNlKCk7XFxuZ2xfRnJhZ0NvbG9yID0gc2hhZGUoZCk7XFxufVwiLFwidGV4dHVyZWQudmVydFwiOlwiYXR0cmlidXRlIG1lZGl1bXAgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSBtZWRpdW1wIHZlYzIgYV90ZXhjb29yZDtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RleGNvb3JkO1xcbnZvaWQgbWFpbih2b2lkKSB7XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDAuMCwgMS4wKTtcXG52X3RleGNvb3JkID0gYV90ZXhjb29yZDtcXG59XCJ9LG1hdGVyaWFsczp7XCJhdHRyaWJ1dGVEYXRhLmdsc2xcIjpcInVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGZpbHRlckZsYWdzO1xcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGFuaW1hdGlvbjtcXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBncGdwdTtcXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCB2aXN1YWxWYXJpYWJsZURhdGE7XFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGF0YURyaXZlbjA7XFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGF0YURyaXZlbjE7XFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGF0YURyaXZlbjI7XFxudW5pZm9ybSBmbG9hdCBzaXplO1xcbmhpZ2hwIHZlYzIgZ2V0QXR0cmlidXRlRGF0YUNvb3JkcyhpbiBoaWdocCB2ZWMzIGlkKSB7XFxuaGlnaHAgdmVjMyAgdGV4ZWwgPSB1bnBhY2tEaXNwbGF5SWRUZXhlbChpZCk7XFxuaGlnaHAgZmxvYXQgdTMyID0gZmxvYXQoaW50KHRleGVsLnIpICsgaW50KHRleGVsLmcpICogMjU2ICsgaW50KHRleGVsLmIpICogMjU2ICogMjU2KTtcXG5oaWdocCBmbG9hdCBjb2wgPSBtb2QodTMyLCBzaXplKTtcXG5oaWdocCBmbG9hdCByb3cgPSAodTMyIC0gY29sKSAvIHNpemU7XFxuaGlnaHAgZmxvYXQgdSA9IGNvbCAvIHNpemU7XFxuaGlnaHAgZmxvYXQgdiA9IHJvdyAvIHNpemU7XFxucmV0dXJuIHZlYzIodSwgdik7XFxufVxcbmhpZ2hwIHZlYzIgZ2V0QXR0cmlidXRlRGF0YVRleHR1cmVDb29yZHMoaW4gaGlnaHAgdmVjMyBpZCkge1xcbnJldHVybiAoZ2V0QXR0cmlidXRlRGF0YUNvb3JkcyhpZCkgKiAyLjApIC0gMS4wICsgKC41IC8gdmVjMihzaXplKSk7XFxufVxcbmhpZ2hwIHZlYzQgZ2V0RmlsdGVyRGF0YShpbiBoaWdocCB2ZWMzIGlkKSB7XFxudmVjMiBjb29yZHMgPSBnZXRBdHRyaWJ1dGVEYXRhQ29vcmRzKGlkKTtcXG5yZXR1cm4gdGV4dHVyZTJEKGZpbHRlckZsYWdzLCBjb29yZHMpO1xcbn1cXG5oaWdocCB2ZWM0IGdldEFuaW1hdGlvbihpbiBoaWdocCB2ZWMzIGlkKSB7XFxuaGlnaHAgdmVjMiBjb29yZHMgPSBnZXRBdHRyaWJ1dGVEYXRhQ29vcmRzKGlkKTtcXG5yZXR1cm4gdGV4dHVyZTJEKGFuaW1hdGlvbiwgY29vcmRzKTtcXG59XFxuaGlnaHAgdmVjNCBnZXRWaXN1YWxWYXJpYWJsZURhdGEoaW4gaGlnaHAgdmVjMyBpZCkge1xcbmhpZ2hwIHZlYzIgY29vcmRzID0gZ2V0QXR0cmlidXRlRGF0YUNvb3JkcyhpZCk7XFxucmV0dXJuIHRleHR1cmUyRCh2aXN1YWxWYXJpYWJsZURhdGEsIGNvb3Jkcyk7XFxufVxcbmhpZ2hwIHZlYzQgZ2V0RGF0YURyaXZlbjAoaW4gaGlnaHAgdmVjMyBpZCkge1xcbmhpZ2hwIHZlYzIgY29vcmRzID0gZ2V0QXR0cmlidXRlRGF0YUNvb3JkcyhpZCk7XFxucmV0dXJuIHRleHR1cmUyRChkYXRhRHJpdmVuMCwgY29vcmRzKTtcXG59XFxuaGlnaHAgdmVjNCBnZXREYXRhRHJpdmVuMShpbiBoaWdocCB2ZWMzIGlkKSB7XFxuaGlnaHAgdmVjMiBjb29yZHMgPSBnZXRBdHRyaWJ1dGVEYXRhQ29vcmRzKGlkKTtcXG5yZXR1cm4gdGV4dHVyZTJEKGRhdGFEcml2ZW4xLCBjb29yZHMpO1xcbn1cXG5oaWdocCB2ZWM0IGdldEdQR1BVKGluIGhpZ2hwIHZlYzMgaWQpIHtcXG5oaWdocCB2ZWMyIGNvb3JkcyA9IGdldEF0dHJpYnV0ZURhdGFDb29yZHMoaWQpO1xcbnJldHVybiB0ZXh0dXJlMkQoZ3BncHUsIGNvb3Jkcyk7XFxufVxcbmhpZ2hwIHZlYzQgZ2V0RGF0YURyaXZlbjIoaW4gaGlnaHAgdmVjMyBpZCkge1xcbmhpZ2hwIHZlYzIgY29vcmRzID0gZ2V0QXR0cmlidXRlRGF0YUNvb3JkcyhpZCk7XFxucmV0dXJuIHRleHR1cmUyRChkYXRhRHJpdmVuMiwgY29vcmRzKTtcXG59XFxuZmxvYXQgdTg4VlZUb0Zsb2F0KGluIHZlYzIgdikge1xcbmJvb2wgaXNNYWdpYyA9IHYueCA9PSAyNTUuMCAmJiB2LnkgPT0gMjU1LjA7XFxuaWYgKGlzTWFnaWMpIHtcXG5yZXR1cm4gTkFOX01BR0lDX05VTUJFUjtcXG59XFxucmV0dXJuICh2LnggKyB2LnkgKiBmbG9hdCgweDEwMCkpIC0gMzI3NjguMDtcXG59XCIsXCJiYXJ5Y2VudHJpYy5nbHNsXCI6XCJmbG9hdCBpblRyaWFuZ2xlKHZlYzMgYmFyeSkge1xcbnZlYzMgYWJzQmFyeSA9IGFicyhiYXJ5KTtcXG5yZXR1cm4gc3RlcCgoYWJzQmFyeS54ICsgYWJzQmFyeS55ICsgYWJzQmFyeS56KSwgMS4wNSk7XFxufVxcbnZlYzMgeHlUb0JhcnljZW50cmljKGluIHZlYzIgcG9zLCBpbiB2ZWMyIHYwLCAgaW4gdmVjMiB2MSwgaW4gdmVjMiB2Mikge1xcbm1hdDMgeHlUb0JhcnljZW50cmljTWF0MyA9IG1hdDMoXFxudjEueCAqIHYyLnkgLSB2Mi54ICogdjEueSwgdjIueCAqIHYwLnkgLSB2MC54ICogdjIueSwgdjAueCAqIHYxLnkgLSB2MS54ICogdjAueSxcXG52MS55IC0gdjIueSwgdjIueSAtIHYwLnksIHYwLnkgLSB2MS55LFxcbnYyLnggLSB2MS54LCB2MC54IC0gdjIueCwgdjEueCAtIHYwLnhcXG4pO1xcbmZsb2F0IEEyID0gdjAueCAqICh2MS55IC0gdjIueSkgKyB2MS54ICogKHYyLnkgLSB2MC55KSArIHYyLnggKiAodjAueSAtIHYxLnkpO1xcbnJldHVybiAoMS4gLyBBMikgKiB4eVRvQmFyeWNlbnRyaWNNYXQzICogdmVjMygxLiwgcG9zKTtcXG59XCIsXCJjb25zdGFudHMuZ2xzbFwiOlwiY29uc3QgZmxvYXQgQ19ERUdfVE9fUkFEID0gMy4xNDE1OTI2NTM1OSAvIDE4MC4wO1xcbmNvbnN0IGZsb2F0IENfMjU2X1RPX1JBRCA9IDMuMTQxNTkyNjUzNTkgLyAxMjguMDtcXG5jb25zdCBmbG9hdCBDX1JBRF9UT19ERUcgPSAxODAuMCAvIDMuMTQxNTkyNjU0O1xcbmNvbnN0IGZsb2F0IFBPU0lUSU9OX1BSRUNJU0lPTiA9IDEuMCAvIDguMDtcXG5jb25zdCBmbG9hdCBGSUxMX1BPU0lUSU9OX1BSRUNJU0lPTiA9IDEuMCAvIDEuMDtcXG5jb25zdCBmbG9hdCBTT0ZUX0VER0VfUkFUSU8gPSAxLjA7XFxuY29uc3QgZmxvYXQgVEhJTl9MSU5FX1dJRFRIX0ZBQ1RPUiA9IDEuMTtcXG5jb25zdCBmbG9hdCBUSElOX0xJTkVfSEFMRl9XSURUSCA9IDEuMDtcXG5jb25zdCBmbG9hdCBFWFRSVURFX1NDQUxFX1BMQUNFTUVOVF9QQURESU5HID0gMS4wIC8gNC4wO1xcbmNvbnN0IGZsb2F0IE9GRlNFVF9QUkVDSVNJT04gPSAxLjAgLyA4LjA7XFxuY29uc3QgZmxvYXQgT1VUTElORV9TQ0FMRSA9IDEuMCAvIDUuMDtcXG5jb25zdCBmbG9hdCBTREZfRk9OVF9TSVpFID0gMjQuMDtcXG5jb25zdCBmbG9hdCBNQVhfU0RGX0RJU1RBTkNFID0gOC4wO1xcbmNvbnN0IGZsb2F0IFBMQUNFTUVOVF9QQURESU5HID0gOC4wO1xcbmNvbnN0IGZsb2F0IEVQU0lMT04gPSAwLjAwMDAxO1xcbmNvbnN0IGZsb2F0IEVQU0lMT05fSElUVEVTVCA9IDAuMDU7XFxuY29uc3QgaW50IE1BWF9GSUxURVJfQ09VTlQgPSAyO1xcbmNvbnN0IGludCBBVFRSX1ZWX1NJWkUgPSAwO1xcbmNvbnN0IGludCBBVFRSX1ZWX0NPTE9SID0gMTtcXG5jb25zdCBpbnQgQVRUUl9WVl9PUEFDSVRZID0gMjtcXG5jb25zdCBpbnQgQVRUUl9WVl9ST1RBVElPTiA9IDM7XFxuY29uc3QgaGlnaHAgZmxvYXQgTkFOX01BR0lDX05VTUJFUiA9IDFlLTMwO1xcbmNvbnN0IGludCBCSVRTRVRfR0VORVJJQ19MT0NLX0NPTE9SID0gMTtcXG5jb25zdCBpbnQgQklUU0VUX0dFTkVSSUNfQ09OU0lERVJfQUxQSEFfT05MWSA9IDQ7XFxuY29uc3QgaW50IEJJVFNFVF9NQVJLRVJfQUxJR05NRU5UX01BUCA9IDA7XFxuY29uc3QgaW50IEJJVFNFVF9NQVJLRVJfT1VUTElORV9BTExPV19DT0xPUl9PVkVSUklERSA9IDI7XFxuY29uc3QgaW50IEJJVFNFVF9NQVJLRVJfU0NBTEVfU1lNQk9MU19QUk9QT1JUSU9OQUxMWSA9IDM7XFxuY29uc3QgaW50IEJJVFNFVF9UWVBFX0ZJTExfT1VUTElORSA9IDA7XFxuY29uc3QgaW50IEJJVFNFVF9GSUxMX1JBTkRPTV9QQVRURVJOX09GRlNFVCA9IDI7XFxuY29uc3QgaW50IEJJVFNFVF9GSUxMX0hBU19VTlJFU09MVkVEX1JFUExBQ0VNRU5UX0NPTE9SID0gMztcXG5jb25zdCBpbnQgQklUU0VUX0ZJTExfSEFTX1BBVFRFUk5fSEVJR0hUX1BSRUNJU0lPTl9GQUNUT1IgPSA1O1xcbmNvbnN0IGludCBCSVRTRVRfRklMTF9IQVNfUEFUVEVSTl9XSURUSF9QUkVDSVNJT05fRkFDVE9SID0gNjtcXG5jb25zdCBpbnQgQklUU0VUX0xJTkVfU0NBTEVfREFTSCA9IDI7XCIsZmlsbDp7XCJjb21tb24uZ2xzbFwiOlwiI2luY2x1ZGUgPG1hdGVyaWFscy9zeW1ib2xvZ3lUeXBlVXRpbHMuZ2xzbD5cXG4jaWZkZWYgUEFUVEVSTlxcbnVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVfbW9zYWljU2l6ZTtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgdl9zYW1wbGVBbHBoYU9ubHk7XFxuI2VuZGlmXFxuI2lmIFNZTUJPTE9HWV9UWVBFID09IFNZTUJPTE9HWV9UWVBFX0RPVF9ERU5TSVRZXFxudW5pZm9ybSBsb3dwIHZlYzQgdV9pc0FjdGl2ZVsgMiBdO1xcbnVuaWZvcm0gaGlnaHAgZmxvYXQgdV9kb3RWYWx1ZTtcXG51bmlmb3JtIGhpZ2hwIGZsb2F0IHVfdGlsZURvdHNPdmVyQXJlYTtcXG51bmlmb3JtIGhpZ2hwIGZsb2F0IHVfZG90VGV4dHVyZURvdENvdW50O1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X3RpbGVab29tRmFjdG9yO1xcbiNlbmRpZlxcbnZhcnlpbmcgaGlnaHAgdmVjMyB2X2lkO1xcbnZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBsb3dwIGZsb2F0IHZfb3BhY2l0eTtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjNCB2X2F1eDE7XFxuI2lmZGVmIFBBVFRFUk5cXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RpbGVUZXh0dXJlQ29vcmQ7XFxuI2VuZGlmXFxuI2lmZGVmIFNZTUJPTE9HWV9UWVBFX0lTX09VVExJTkVfRklMTF9MSUtFXFxudmFyeWluZyBsb3dwIGZsb2F0IHZfaXNPdXRsaW5lO1xcbiNlbmRpZlxcbiNpZiBTWU1CT0xPR1lfVFlQRSA9PSBTWU1CT0xPR1lfVFlQRV9ET1RfREVOU0lUWVxcbnZhcnlpbmcgaGlnaHAgdmVjMiB2X2RvdFRleHR1cmVDb29yZHM7XFxudmFyeWluZyBoaWdocCB2ZWM0IHZfZG90VGhyZXNob2xkc1sgMiBdO1xcbiNlbmRpZlwiLFwiZmlsbC5mcmFnXCI6XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9jb25zdGFudHMuZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL3V0aWxzLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9maWxsL2NvbW1vbi5nbHNsPlxcbiNpZmRlZiBQQVRURVJOXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuI2VuZGlmXFxuI2lmIFNZTUJPTE9HWV9UWVBFID09IFNZTUJPTE9HWV9UWVBFX0RPVF9ERU5TSVRZXFxudW5pZm9ybSBtZWRpdW1wIG1hdDQgdV9kb3RDb2xvcnNbIDIgXTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2RvdFRleHR1cmVzWyAyIF07XFxudW5pZm9ybSB2ZWM0IHVfZG90QmFja2dyb3VuZENvbG9yO1xcbiNlbmRpZlxcbiNpZmRlZiBTWU1CT0xPR1lfVFlQRV9JU19PVVRMSU5FX0ZJTExfTElLRVxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvc2hhcmVkL2xpbmUvY29tbW9uLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9zaGFyZWQvbGluZS9saW5lLmZyYWc+XFxubG93cCB2ZWM0IGRyYXdMaW5lKCkge1xcbmZsb2F0IHZfbGluZVdpZHRoID0gdl9hdXgxLng7XFxudmVjMiAgdl9ub3JtYWwgICAgPSB2X2F1eDEueXo7XFxuTGluZURhdGEgaW5wdXRzID0gTGluZURhdGEoXFxudl9jb2xvcixcXG52X25vcm1hbCxcXG52X2xpbmVXaWR0aCxcXG52X29wYWNpdHksXFxudl9pZFxcbik7XFxucmV0dXJuIHNoYWRlTGluZShpbnB1dHMpO1xcbn1cXG4jZW5kaWZcXG5sb3dwIHZlYzQgZHJhd0ZpbGwoKSB7XFxubG93cCB2ZWM0IG91dF9jb2xvciA9IHZlYzQoMC4pO1xcbiNpZmRlZiBISVRURVNUXFxub3V0X2NvbG9yID0gdl9jb2xvcjtcXG4jZWxpZiBkZWZpbmVkKFBBVFRFUk4pXFxubWVkaXVtcCB2ZWM0IHZfdGxiciA9IHZfYXV4MTtcXG5tZWRpdW1wIHZlYzIgbm9ybWFsaXplZFRleHR1cmVDb29yZCA9IG1vZCh2X3RpbGVUZXh0dXJlQ29vcmQsIDEuMCk7XFxubWVkaXVtcCB2ZWMyIHNhbXBsZVBvcyA9IG1peCh2X3RsYnIueHksIHZfdGxici56dywgbm9ybWFsaXplZFRleHR1cmVDb29yZCk7XFxubG93cCB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgc2FtcGxlUG9zKTtcXG5pZiAodl9zYW1wbGVBbHBoYU9ubHkgPiAwLjUpIHtcXG5jb2xvci5yZ2IgPSB2ZWMzKGNvbG9yLmEpO1xcbn1cXG5vdXRfY29sb3IgPSB2X29wYWNpdHkgKiB2X2NvbG9yICogY29sb3I7XFxuI2VsaWYgU1lNQk9MT0dZX1RZUEUgPT0gU1lNQk9MT0dZX1RZUEVfRE9UX0RFTlNJVFkgJiYgIWRlZmluZWQoSElHSExJR0hUKVxcbnZlYzQgdGV4dHVyZVRocmVzaG9sZHMwID0gdGV4dHVyZTJEKHVfZG90VGV4dHVyZXNbMF0sIHZfZG90VGV4dHVyZUNvb3Jkcyk7XFxudmVjNCB0ZXh0dXJlVGhyZXNob2xkczEgPSB0ZXh0dXJlMkQodV9kb3RUZXh0dXJlc1sxXSwgdl9kb3RUZXh0dXJlQ29vcmRzKTtcXG52ZWM0IGRpZmZlcmVuY2UwID0gdl9kb3RUaHJlc2hvbGRzWzBdIC0gdGV4dHVyZVRocmVzaG9sZHMwO1xcbnZlYzQgZGlmZmVyZW5jZTEgPSB2X2RvdFRocmVzaG9sZHNbMV0gLSB0ZXh0dXJlVGhyZXNob2xkczE7XFxuI2lmZGVmIEREX0RPVF9CTEVORElOR1xcbnZlYzQgaXNQb3NpdGl2ZTAgPSBzdGVwKDAuMCwgZGlmZmVyZW5jZTApO1xcbnZlYzQgaXNQb3NpdGl2ZTEgPSBzdGVwKDAuMCwgZGlmZmVyZW5jZTEpO1xcbmZsb2F0IHdlaWdodFN1bSA9IGRvdChpc1Bvc2l0aXZlMCwgZGlmZmVyZW5jZTApICsgZG90KGlzUG9zaXRpdmUxLCBkaWZmZXJlbmNlMSk7XFxuZmxvYXQgbGVzc1RoYW5FcVplcm8gPSBzdGVwKHdlaWdodFN1bSwgMC4wKTtcXG5mbG9hdCBncmVhdGVyVGhhblplcm8gPSAxLjAgLSBsZXNzVGhhbkVxWmVybyA7XFxuZmxvYXQgZGl2aXNvciA9ICh3ZWlnaHRTdW0gKyBsZXNzVGhhbkVxWmVybyk7XFxudmVjNCB3ZWlnaHRzMCA9IGRpZmZlcmVuY2UwICogaXNQb3NpdGl2ZTAgLyBkaXZpc29yO1xcbnZlYzQgd2VpZ2h0czEgPSBkaWZmZXJlbmNlMSAqIGlzUG9zaXRpdmUxIC8gZGl2aXNvcjtcXG52ZWM0IGRvdENvbG9yID0gdV9kb3RDb2xvcnNbMF0gKiB3ZWlnaHRzMCArIHVfZG90Q29sb3JzWzFdICogd2VpZ2h0czE7XFxudmVjNCBwcmVFZmZlY3RDb2xvciA9IGdyZWF0ZXJUaGFuWmVybyAqIGRvdENvbG9yICsgbGVzc1RoYW5FcVplcm8gKiB1X2RvdEJhY2tncm91bmRDb2xvcjtcXG4jZWxzZVxcbmZsb2F0IGRpZmZNYXggPSBtYXgobWF4NChkaWZmZXJlbmNlMCksIG1heDQoZGlmZmVyZW5jZTEpKTtcXG5mbG9hdCBsZXNzVGhhblplcm8gPSBzdGVwKGRpZmZNYXgsIDAuMCk7XFxuZmxvYXQgZ3JlYXRlck9yRXFaZXJvID0gMS4wIC0gbGVzc1RoYW5aZXJvO1xcbnZlYzQgaXNNYXgwID0gc3RlcChkaWZmTWF4LCBkaWZmZXJlbmNlMCk7XFxudmVjNCBpc01heDEgPSBzdGVwKGRpZmZNYXgsIGRpZmZlcmVuY2UxKTtcXG52ZWM0IGRvdENvbG9yID0gdV9kb3RDb2xvcnNbMF0gKiBpc01heDAgKyB1X2RvdENvbG9yc1sxXSAqIGlzTWF4MTtcXG52ZWM0IHByZUVmZmVjdENvbG9yID0gZ3JlYXRlck9yRXFaZXJvICogZG90Q29sb3IgKyBsZXNzVGhhblplcm8gKiB1X2RvdEJhY2tncm91bmRDb2xvcjtcXG4jZW5kaWZcXG5vdXRfY29sb3IgPSBwcmVFZmZlY3RDb2xvcjtcXG4jZWxzZVxcbm91dF9jb2xvciA9IHZfb3BhY2l0eSAqIHZfY29sb3I7XFxuI2VuZGlmXFxuI2lmZGVmIEhJR0hMSUdIVFxcbm91dF9jb2xvci5hID0gMS4wO1xcbiNlbmRpZlxcbnJldHVybiBvdXRfY29sb3I7XFxufVxcbnZvaWQgbWFpbigpIHtcXG4jaWZkZWYgU1lNQk9MT0dZX1RZUEVfSVNfT1VUTElORV9GSUxMX0xJS0VcXG5pZiAodl9pc091dGxpbmUgPiAwLjUpIHtcXG5nbF9GcmFnQ29sb3IgPSBkcmF3TGluZSgpO1xcbn0gZWxzZSB7XFxuZ2xfRnJhZ0NvbG9yID0gZHJhd0ZpbGwoKTtcXG59XFxuI2Vsc2VcXG5nbF9GcmFnQ29sb3IgPSBkcmF3RmlsbCgpO1xcbiNlbmRpZlxcbn1cIixcImZpbGwudmVydFwiOlwiI2luY2x1ZGUgPG1hdGVyaWFscy9zeW1ib2xvZ3lUeXBlVXRpbHMuZ2xzbD5cXG4jZGVmaW5lIFBBQ0tFRF9MSU5FXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2JpdHNldDtcXG4jaWYgU1lNQk9MT0dZX1RZUEUgPT0gU1lNQk9MT0dZX1RZUEVfRE9UX0RFTlNJVFlcXG5hdHRyaWJ1dGUgZmxvYXQgYV9pbnZlcnNlQXJlYTtcXG52ZWM0IGFfY29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxudmVjMiBhX3pvb21SYW5nZSA9IHZlYzIoMC4wLCAxMDAwMC4wKTtcXG4jZWxzZVxcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuYXR0cmlidXRlIHZlYzQgYV9hdXgyO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfYXV4MztcXG4jaWZuZGVmIFNZTUJPTE9HWV9UWVBFX0lTX1NJTVBMRV9MSUtFXFxuYXR0cmlidXRlIHZlYzQgYV9hdXgxO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfem9vbVJhbmdlO1xcbiNlbHNlXFxudmVjMiBhX3pvb21SYW5nZSA9IHZlYzIoMC4wLCAxMDAwMC4wKTtcXG4jZW5kaWZcXG4jZW5kaWZcXG51bmlmb3JtIHZlYzIgdV90aWxlT2Zmc2V0O1xcbnVuaWZvcm0gdmVjMiB1X21heEludE51bU9mQ3Jvc3Npbmc7XFxuI2luY2x1ZGUgPHV0aWwvZW5jb2RpbmcuZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL3Zjb21tb24uZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL2ZpbGwvY29tbW9uLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9maWxsL2hpdHRlc3QuZ2xzbD5cXG5jb25zdCBmbG9hdCBJTlZfU0NBTEVfQ09NUFJFU1NJT05fRkFDVE9SID0gMS4wIC8gMTI4LjA7XFxuY29uc3QgZmxvYXQgTUFYX1JFUFJFU0VOVEFCTEVfSU5UID0gMTY3NzcyMTYuMDtcXG4jaWYgU1lNQk9MT0dZX1RZUEUgPT0gU1lNQk9MT0dZX1RZUEVfRE9UX0RFTlNJVFlcXG52ZWM0IGRvdFRocmVzaG9sZCh2ZWM0IGZlYXR1cmVBdHRyT3ZlckZlYXR1cmVBcmVhLCBmbG9hdCBkb3RWYWx1ZSwgZmxvYXQgdGlsZURvdHNPdmVyQXJlYSkge1xcbnJldHVybiBmZWF0dXJlQXR0ck92ZXJGZWF0dXJlQXJlYSAqICgxLjAgLyBkb3RWYWx1ZSkgICogKDEuMCAvIHRpbGVEb3RzT3ZlckFyZWEpO1xcbn1cXG4jZW5kaWZcXG4jaWZkZWYgU1lNQk9MT0dZX1RZUEVfSVNfT1VUTElORV9GSUxMX0xJS0VcXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL3NoYXJlZC9saW5lL2NvbW1vbi5nbHNsPlxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvc2hhcmVkL2xpbmUvbGluZS52ZXJ0PlxcbnZvaWQgZHJhd0xpbmUob3V0IGxvd3AgdmVjNCBvdXRfY29sb3IsIG91dCBoaWdocCB2ZWMzIG91dF9wb3MpIHtcXG5MaW5lRGF0YSBvdXRwdXRzID0gYnVpbGRMaW5lKFxcbm91dF9wb3MsXFxuYV9pZCxcXG5hX3BvcyxcXG5hX2NvbG9yLFxcbihhX2F1eDMueHkgLSAxMjguKSAvIDE2LixcXG4oYV9hdXgzLnp3IC0gMTI4LikgLyAxNi4sXFxuMC4sXFxuYV9hdXgyLnogLyAxNi4sXFxuYV9iaXRzZXQsXFxudmVjNCgwLiksXFxudmVjMigwLiksXFxuYV9hdXgyLncgLyAxNi5cXG4pO1xcbnZfaWQgICAgICA9IG91dHB1dHMuaWQ7XFxudl9vcGFjaXR5ID0gb3V0cHV0cy5vcGFjaXR5O1xcbnZfYXV4MSAgICA9IHZlYzQob3V0cHV0cy5saW5lSGFsZldpZHRoLCBvdXRwdXRzLm5vcm1hbCwgMC4pO1xcbm91dF9jb2xvciA9IG91dHB1dHMuY29sb3I7XFxufVxcbiNlbmRpZlxcbnZvaWQgZHJhd0ZpbGwob3V0IGxvd3AgdmVjNCBvdXRfY29sb3IsIG91dCBoaWdocCB2ZWMzIG91dF9wb3MpIHtcXG5mbG9hdCBhX2JpdFNldCA9IGFfYml0c2V0O1xcbm91dF9jb2xvciA9IGdldENvbG9yKGFfY29sb3IsIGFfYml0U2V0LCBCSVRTRVRfR0VORVJJQ19MT0NLX0NPTE9SKTtcXG52X29wYWNpdHkgPSBnZXRPcGFjaXR5KCk7XFxudl9pZCAgICAgID0gbm9ybShhX2lkKTtcXG4jaWYgU1lNQk9MT0dZX1RZUEUgPT0gU1lNQk9MT0dZX1RZUEVfRE9UX0RFTlNJVFlcXG5tYXQzIHRpbGVUb1RpbGVOb3JtYWxpemVkID0gbWF0MyggIDIuIC8gNTEyLiwgIDAuLCAgMC4sXFxuMC4sIC0yLiAvIDUxMi4sICAwLixcXG4tMS4sICAxLiwgIDEuICApO1xcbm91dF9wb3MgICA9IHRpbGVUb1RpbGVOb3JtYWxpemVkICogdmVjMygoYV9wb3MgKiBGSUxMX1BPU0lUSU9OX1BSRUNJU0lPTiksIDEuKTtcXG4jZWxzZVxcbm91dF9wb3MgICA9IHVfZHZzTWF0MyAqIHZlYzMoYV9wb3MgKiBGSUxMX1BPU0lUSU9OX1BSRUNJU0lPTiwgMS4pO1xcbiNlbmRpZlxcbiNpZmRlZiBQQVRURVJOXFxudmVjNCAgYV90bGJyICAgPSBhX2F1eDE7XFxuZmxvYXQgYV93aWR0aCAgPSBhX2F1eDIueDtcXG5mbG9hdCBhX2hlaWdodCA9IGFfYXV4Mi55O1xcbnZlYzIgIGFfb2Zmc2V0ID0gYV9hdXgyLnp3O1xcbnZlYzIgIGFfc2NhbGUgID0gYV9hdXgzLnh5O1xcbmZsb2F0IGFfYW5nbGUgID0gYV9hdXgzLno7XFxuaWYgKGdldEJpdChhX2JpdHNldCwgQklUU0VUX0ZJTExfSEFTX1BBVFRFUk5fV0lEVEhfUFJFQ0lTSU9OX0ZBQ1RPUikgPiAwLjUpIHtcXG5hX3dpZHRoICo9IElOVl9TQ0FMRV9DT01QUkVTU0lPTl9GQUNUT1I7XFxufVxcbmlmIChnZXRCaXQoYV9iaXRzZXQsIEJJVFNFVF9GSUxMX0hBU19QQVRURVJOX0hFSUdIVF9QUkVDSVNJT05fRkFDVE9SKSA+IDAuNSkge1xcbmFfaGVpZ2h0ICo9IElOVl9TQ0FMRV9DT01QUkVTU0lPTl9GQUNUT1I7XFxufVxcbnZlYzIgc2NhbGUgPSBJTlZfU0NBTEVfQ09NUFJFU1NJT05fRkFDVE9SICogYV9zY2FsZTtcXG5mbG9hdCB3aWR0aCA9IHVfem9vbUZhY3RvciAqIGFfd2lkdGggKiBzY2FsZS54O1xcbmZsb2F0IGhlaWdodCA9IHVfem9vbUZhY3RvciAqIGFfaGVpZ2h0ICogc2NhbGUueTtcXG5mbG9hdCBhbmdsZSA9IENfMjU2X1RPX1JBRCAqIGFfYW5nbGU7XFxuZmxvYXQgc2luQSA9IHNpbihhbmdsZSk7XFxuZmxvYXQgY29zQSA9IGNvcyhhbmdsZSk7XFxuZmxvYXQgZHggPSAwLjA7XFxuZmxvYXQgZHkgPSAwLjA7XFxuaWYgKGdldEJpdChhX2JpdHNldCwgQklUU0VUX0ZJTExfUkFORE9NX1BBVFRFUk5fT0ZGU0VUKSA+IDAuNSkge1xcbmZsb2F0IGlkID0gcmdiYTJmbG9hdCh2ZWM0KGFfaWQsIDAuMCkpO1xcbmR4ID0gcmFuZCh2ZWMyKGlkLCAwLjApKTtcXG5keSA9IHJhbmQodmVjMigwLjAsIGlkKSk7XFxufVxcbm1hdDMgcGF0dGVybk1hdHJpeCA9IG1hdDMoY29zQSAvIHdpZHRoLCBzaW5BIC8gaGVpZ2h0LCAwLFxcbi1zaW5BIC8gd2lkdGgsIGNvc0EgLyBoZWlnaHQsIDAsXFxuZHgsICAgICAgICAgICAgZHksICAgICAgICAgICAxKTtcXG52ZWMyIHBhdHRlcm5TaXplID0gdmVjMihhX3dpZHRoLCBhX2hlaWdodCk7XFxudmVjMiBudW1QYXR0ZXJuc1Blck1heEludCA9IHZlYzIoTUFYX1JFUFJFU0VOVEFCTEVfSU5UKSAvIHBhdHRlcm5TaXplO1xcbnZlYzIgbWF4SW50Q3Jvc3NpbmdPZmZzZXRDb3JyZWN0aW9uID0gcGF0dGVyblNpemUgKiBmcmFjdCh1X21heEludE51bU9mQ3Jvc3NpbmcgKiBudW1QYXR0ZXJuc1Blck1heEludCk7XFxudmVjMiB0aWxlT2Zmc2V0ID0gdV90aWxlT2Zmc2V0ICsgbWF4SW50Q3Jvc3NpbmdPZmZzZXRDb3JyZWN0aW9uIC0gMC41ICogcGF0dGVyblNpemU7XFxudGlsZU9mZnNldCA9IHZlYzIodGlsZU9mZnNldC54ICogY29zQSAtIHRpbGVPZmZzZXQueSAqIHNpbkEsIHRpbGVPZmZzZXQueCAqIHNpbkEgKyB0aWxlT2Zmc2V0LnkgKiBjb3NBKTtcXG50aWxlT2Zmc2V0ID0gbW9kKHRpbGVPZmZzZXQsIHBhdHRlcm5TaXplKTtcXG52ZWMyIHN5bWJvbE9mZnNldCA9IHVfem9vbUZhY3RvciAqIHNjYWxlICogdmVjMihhX29mZnNldCAtIHRpbGVPZmZzZXQpIC8gdmVjMih3aWR0aCwgaGVpZ2h0KTtcXG52X3RpbGVUZXh0dXJlQ29vcmQgPSAocGF0dGVybk1hdHJpeCAqIHZlYzMoYV9wb3MgKiBGSUxMX1BPU0lUSU9OX1BSRUNJU0lPTiwgMS4wKSkueHkgLSBzeW1ib2xPZmZzZXQ7XFxudl9hdXgxID0gYV90bGJyIC8gdV9tb3NhaWNTaXplLnh5eHk7XFxudl9zYW1wbGVBbHBoYU9ubHkgPSBnZXRCaXQoYV9iaXRzZXQsIEJJVFNFVF9HRU5FUklDX0NPTlNJREVSX0FMUEhBX09OTFkpO1xcbmlmIChnZXRCaXQoYV9iaXRTZXQsIEJJVFNFVF9GSUxMX0hBU19VTlJFU09MVkVEX1JFUExBQ0VNRU5UX0NPTE9SKSA+IDAuNSkge1xcbiNpZmRlZiBWVl9DT0xPUlxcbnZfc2FtcGxlQWxwaGFPbmx5ICo9ICgxLjAgLSBmbG9hdChpc05hbihWVl9BREFUQVtBVFRSX1ZWX0NPTE9SXSkpKSAqICgxLjAgLSBnZXRCaXQoYV9iaXRTZXQsIEJJVFNFVF9HRU5FUklDX0xPQ0tfQ09MT1IpKTtcXG4jZWxzZVxcbnZfc2FtcGxlQWxwaGFPbmx5ID0gMC4wO1xcbiNlbmRpZlxcbn1cXG4jZWxpZiBTWU1CT0xPR1lfVFlQRSA9PSBTWU1CT0xPR1lfVFlQRV9ET1RfREVOU0lUWVxcbnZlYzQgZGRBdHRyaWJ1dGVEYXRhMCA9IGdldEF0dHJpYnV0ZURhdGEyKGFfaWQpICogdV9pc0FjdGl2ZVswXSAqIGFfaW52ZXJzZUFyZWE7XFxudmVjNCBkZEF0dHJpYnV0ZURhdGExID0gZ2V0QXR0cmlidXRlRGF0YTMoYV9pZCkgKiB1X2lzQWN0aXZlWzFdICogYV9pbnZlcnNlQXJlYTtcXG5mbG9hdCBzaXplID0gdV90aWxlWm9vbUZhY3RvciAqIDUxMi4wICogMS4wIC8gdV9waXhlbFJhdGlvO1xcbnZfZG90VGhyZXNob2xkc1swXSA9IGRvdFRocmVzaG9sZChkZEF0dHJpYnV0ZURhdGEwLCB1X2RvdFZhbHVlLCB1X3RpbGVEb3RzT3ZlckFyZWEpO1xcbnZfZG90VGhyZXNob2xkc1sxXSA9IGRvdFRocmVzaG9sZChkZEF0dHJpYnV0ZURhdGExLCB1X2RvdFZhbHVlLCB1X3RpbGVEb3RzT3ZlckFyZWEpO1xcbnZfZG90VGV4dHVyZUNvb3JkcyA9IChhX3BvcyAqIEZJTExfUE9TSVRJT05fUFJFQ0lTSU9OICsgMC41KSAvIHNpemU7XFxuI2VuZGlmXFxufVxcbiNpZmRlZiBISVRURVNUXFxudm9pZCBkcmF3KG91dCBsb3dwIHZlYzQgb3V0X2NvbG9yLCBvdXQgaGlnaHAgdmVjMyBvdXRfcG9zKSB7XFxuI2lmZGVmIFNZTUJPTE9HWV9UWVBFX0lTX09VVExJTkVfRklMTF9MSUtFXFxuaWYgKGdldEJpdChhX2JpdHNldCwgQklUU0VUX1RZUEVfRklMTF9PVVRMSU5FKSA+IDAuNSkge1xcbm91dF9wb3MgPSB2ZWMzKDAuLCAwLiwgMi4pO1xcbnJldHVybjtcXG59XFxuI2VuZGlmXFxuaGl0dGVzdEZpbGwob3V0X2NvbG9yLCBvdXRfcG9zKTtcXG5nbF9Qb2ludFNpemUgPSAxLjA7XFxufVxcbiNlbGlmIGRlZmluZWQoU1lNQk9MT0dZX1RZUEVfSVNfT1VUTElORV9GSUxMX0xJS0UpXFxudm9pZCBkcmF3KG91dCBsb3dwIHZlYzQgb3V0X2NvbG9yLCBvdXQgaGlnaHAgdmVjMyBvdXRfcG9zKSB7XFxudl9pc091dGxpbmUgPSBnZXRCaXQoYV9iaXRzZXQsIEJJVFNFVF9UWVBFX0ZJTExfT1VUTElORSk7XFxuaWYgKHZfaXNPdXRsaW5lID4gMC41KSB7XFxuZHJhd0xpbmUob3V0X2NvbG9yLCBvdXRfcG9zKTtcXG59IGVsc2Uge1xcbmRyYXdGaWxsKG91dF9jb2xvciwgb3V0X3Bvcyk7XFxufVxcbn1cXG4jZWxzZVxcbiNkZWZpbmUgZHJhdyBkcmF3RmlsbFxcbiNlbmRpZlxcbnZvaWQgbWFpbigpXFxue1xcbklOSVQ7XFxuaGlnaHAgdmVjMyBwb3MgID0gdmVjMygwLik7XFxuaGlnaHAgdmVjNCBjb2xvciAgPSB2ZWM0KDAuKTtcXG5kcmF3KGNvbG9yLCBwb3MpO1xcbnZfY29sb3IgPSBjb2xvcjtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcCh2X2NvbG9yLCBwb3MsIGdldEZpbHRlckZsYWdzKCksIGFfem9vbVJhbmdlKSwgMS4wKTtcXG59XCIsXCJoaXR0ZXN0Lmdsc2xcIjpcIiNpZmRlZiBISVRURVNUXFxuI2luY2x1ZGUgPG1hdGVyaWFscy9oaXR0ZXN0L2NvbW1vbi5nbHNsPlxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zMTtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvczI7XFxudm9pZCBoaXR0ZXN0RmlsbChcXG5vdXQgbG93cCB2ZWM0IG91dF9jb2xvcixcXG5vdXQgaGlnaHAgdmVjMyBvdXRfcG9zXFxuKSB7XFxudmVjMyBwb3MgICAgICAgID0gdV92aWV3TWF0MyAqIHVfdGlsZU1hdDMgKiB2ZWMzKGFfcG9zICAqIEZJTExfUE9TSVRJT05fUFJFQ0lTSU9OLCAxLik7XFxudmVjMyBwb3MxICAgICAgID0gdV92aWV3TWF0MyAqIHVfdGlsZU1hdDMgKiB2ZWMzKGFfcG9zMSAqIEZJTExfUE9TSVRJT05fUFJFQ0lTSU9OLCAxLik7XFxudmVjMyBwb3MyICAgICAgID0gdV92aWV3TWF0MyAqIHVfdGlsZU1hdDMgKiB2ZWMzKGFfcG9zMiAqIEZJTExfUE9TSVRJT05fUFJFQ0lTSU9OLCAxLik7XFxuZmxvYXQgaGl0dGVzdERpc3QgPSB1X2hpdHRlc3REaXN0O1xcbmZsb2F0IGRpc3QgPSBkaXN0UG9pbnRUcmlhbmdsZSh1X2hpdHRlc3RQb3MsIHBvcy54eSwgcG9zMS54eSwgcG9zMi54eSk7XFxub3V0X3BvcyA9IHZlYzMoZ2V0QXR0cmlidXRlRGF0YVRleHR1cmVDb29yZHMoYV9pZCksIDAuMCk7XFxuaWYgKGRpc3QgPCAwLiB8fCBkaXN0ID49IGhpdHRlc3REaXN0KSB7XFxub3V0X3Bvcy56ICs9IDIuMDtcXG59XFxub3V0X2NvbG9yID0gdmVjNCgxLiAvIDI1NS4sIDAsIDAsIGRpc3QgPT0gMC4gPyAoMS4gLyAyNTUuKSA6IDAuKTtcXG59XFxuI2VuZGlmXCJ9LGhpdHRlc3Q6e1wiY29tbW9uLmdsc2xcIjpcIiNpZmRlZiBISVRURVNUXFxudW5pZm9ybSBmbG9hdCBoaXR0ZXN0RGlzdDtcXG51bmlmb3JtIGhpZ2hwIHZlYzIgaGl0dGVzdFBvcztcXG5mbG9hdCBwcm9qZWN0U2NhbGFyKHZlYzIgYSwgdmVjMiBiKSB7XFxucmV0dXJuIGRvdChhLCBub3JtYWxpemUoYikpO1xcbn1cXG5mbG9hdCBkaXN0UG9pbnRTZWdtZW50KHZlYzIgcDAsIHZlYzIgcDEsIHZlYzIgcDIpIHtcXG52ZWMyIEwgPSBwMiAtIHAxO1xcbnZlYzIgQSA9IHAwIC0gcDE7XFxuZmxvYXQgcHJvakFMID0gcHJvamVjdFNjYWxhcihBLCBMKTtcXG5mbG9hdCB0ID0gY2xhbXAocHJvakFMIC8gbGVuZ3RoKEwpLCAwLiwgMS4pO1xcbnJldHVybiBkaXN0YW5jZShwMCwgcDEgKyB0ICogKHAyIC0gcDEpKTtcXG59XFxudm9pZCBoaXR0ZXN0TWFya2VyKG91dCBsb3dwIHZlYzQgb3V0X2NvbG9yLCBvdXQgaGlnaHAgdmVjMyBvdXRfcG9zLCBpbiBoaWdocCB2ZWMzIHBvcywgZmxvYXQgc2l6ZSkge1xcbmZsb2F0IGRpc3QgPSBkaXN0YW5jZShwb3MsIHZlYzMoaGl0dGVzdFBvcywgMS4pKTtcXG5vdXRfcG9zID0gdmVjMyhnZXRBdHRyaWJ1dGVEYXRhVGV4dHVyZUNvb3JkcyhhX2lkKSwgMC4wKTtcXG5pZiAoKGRpc3QgLSBzaXplKSA+IGhpdHRlc3REaXN0KSB7XFxub3V0X3Bvcy56ICs9IDIuMDtcXG59XFxub3V0X2NvbG9yID0gdmVjNCgxLiAvIDI1NS4sIDAsIDAsIChkaXN0IC0gc2l6ZSkgPCAwLiA/ICgxLiAvIDI1NS4pIDogMC4pO1xcbn1cXG5mbG9hdCBpbnRlcnNlY3RQb2ludFRyaWFuZ2xlQmFyeSh2ZWMyIHAsIHZlYzIgYSwgdmVjMiBiLCB2ZWMyIGMpIHtcXG5yZXR1cm4gaW5UcmlhbmdsZSh4eVRvQmFyeWNlbnRyaWMocCwgYSwgYiwgYykpO1xcbn1cXG5mbG9hdCBkaXN0UG9pbnRUcmlhbmdsZSh2ZWMyIHAsIHZlYzIgYSwgdmVjMiBiLCB2ZWMyIGMpIHtcXG52ZWMyIGJhID0gYiAtIGE7XFxudmVjMiBjYSA9IGMgLSBhO1xcbmZsb2F0IGNyb3NzUHJvZHVjdCA9IGJhLnggKiBjYS55IC0gY2EueCAqIGJhLnk7XFxuYm9vbCBpc1BhcmFsbGVsID0gY3Jvc3NQcm9kdWN0IDwgRVBTSUxPTl9ISVRURVNUICYmIGNyb3NzUHJvZHVjdCA+IC1FUFNJTE9OX0hJVFRFU1Q7XFxuaWYgKGlzUGFyYWxsZWwpIHtcXG5yZXR1cm4gLTEuO1xcbn1cXG5pZiAoaW50ZXJzZWN0UG9pbnRUcmlhbmdsZUJhcnkocC54eSwgYSwgYiwgYykgPT0gMS4pIHtcXG5yZXR1cm4gMC47XFxufVxcbmZsb2F0IGRpc3RBQiA9IGRpc3RQb2ludFNlZ21lbnQocCwgYSwgYik7XFxuZmxvYXQgZGlzdEJDID0gZGlzdFBvaW50U2VnbWVudChwLCBiLCBjKTtcXG5mbG9hdCBkaXN0Q0EgPSBkaXN0UG9pbnRTZWdtZW50KHAsIGMsIGEpO1xcbnJldHVybiBtaW4obWluKGRpc3RBQiwgZGlzdEJDKSwgZGlzdENBKTtcXG59XFxuI2VuZGlmXCJ9LGljb246e1wiY29tbW9uLmdsc2xcIjpcIiNpbmNsdWRlIDx1dGlsL2VuY29kaW5nLmdsc2w+XFxudW5pZm9ybSBsb3dwIHZlYzIgdV9tb3NhaWNTaXplO1xcbnZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBoaWdocCB2ZWMzIHZfaWQ7XFxudmFyeWluZyBoaWdocCB2ZWM0IHZfc2l6ZVRleDtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMyB2X3BvcztcXG52YXJ5aW5nIGxvd3AgZmxvYXQgdl9vcGFjaXR5O1xcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbiNpZmRlZiBTREZcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X291dGxpbmVDb2xvcjtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgdl9vdXRsaW5lV2lkdGg7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfZGlzdFJhdGlvO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X292ZXJyaWRpbmdPdXRsaW5lQ29sb3I7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfaXNUaGluO1xcbiNlbmRpZlxcbiNpZmRlZiBTREZcXG52ZWM0IGdldENvbG9yKHZlYzIgdl9zaXplLCB2ZWMyIHZfdGV4KSB7XFxuI2lmZGVmIEhJVFRFU1RcXG5sb3dwIHZlYzQgZmlsbFBpeGVsQ29sb3IgPSB2ZWM0KDEuMCk7XFxuI2Vsc2VcXG5sb3dwIHZlYzQgZmlsbFBpeGVsQ29sb3IgPSB2X2NvbG9yO1xcbiNlbmRpZlxcbmZsb2F0IGQgPSAwLjUgLSByZ2JhMmZsb2F0KHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4KSk7XFxuZmxvYXQgc2l6ZSA9IG1heCh2X3NpemUueCwgdl9zaXplLnkpO1xcbmZsb2F0IGRpc3QgPSBkICogc2l6ZSAqIFNPRlRfRURHRV9SQVRJTyAqIHZfZGlzdFJhdGlvO1xcbmZpbGxQaXhlbENvbG9yICo9IGNsYW1wKDAuNSAtIGRpc3QsIDAuMCwgMS4wKTtcXG5mbG9hdCBvdXRsaW5lV2lkdGggPSB2X291dGxpbmVXaWR0aDtcXG4jaWZkZWYgSElHSExJR0hUXFxub3V0bGluZVdpZHRoID0gbWF4KG91dGxpbmVXaWR0aCwgNC4wICogdl9pc1RoaW4pO1xcbiNlbmRpZlxcbmlmIChvdXRsaW5lV2lkdGggPiAwLjI1KSB7XFxubG93cCB2ZWM0IG91dGxpbmVQaXhlbENvbG9yID0gdl9vdmVycmlkaW5nT3V0bGluZUNvbG9yICogdl9jb2xvciArICgxLjAgLSB2X292ZXJyaWRpbmdPdXRsaW5lQ29sb3IpICogdl9vdXRsaW5lQ29sb3I7XFxuZmxvYXQgY2xhbXBlZE91dGxpbmVTaXplID0gbWluKG91dGxpbmVXaWR0aCwgc2l6ZSk7XFxub3V0bGluZVBpeGVsQ29sb3IgKj0gY2xhbXAoMC41IC0gYWJzKGRpc3QpICsgY2xhbXBlZE91dGxpbmVTaXplICogMC41LCAwLjAsIDEuMCk7XFxucmV0dXJuIHZfb3BhY2l0eSAqICgoMS4wIC0gb3V0bGluZVBpeGVsQ29sb3IuYSkgKiBmaWxsUGl4ZWxDb2xvciArIG91dGxpbmVQaXhlbENvbG9yKTtcXG59XFxucmV0dXJuIHZfb3BhY2l0eSAqIGZpbGxQaXhlbENvbG9yO1xcbn1cXG4jZWxzZVxcbnZlYzQgZ2V0Q29sb3IodmVjMiBfdl9zaXplLCB2ZWMyIHZfdGV4KSB7XFxubG93cCB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXgpO1xcbnJldHVybiB2X29wYWNpdHkgKiB0ZXhDb2xvciAqIHZfY29sb3I7XFxufVxcbiNlbmRpZlwiLGhlYXRtYXBBY2N1bXVsYXRlOntcImNvbW1vbi5nbHNsXCI6XCJ2YXJ5aW5nIGxvd3AgdmVjNCB2X2hpdHRlc3RSZXN1bHQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl9vZmZzZXRGcm9tQ2VudGVyO1xcbnZhcnlpbmcgaGlnaHAgZmxvYXQgdl9maWVsZFZhbHVlO1wiLFwiaGVhdG1hcEFjY3VtdWxhdGUuZnJhZ1wiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9pY29uL2hlYXRtYXBBY2N1bXVsYXRlL2NvbW1vbi5nbHNsPlxcbiNpZmRlZiBIRUFUTUFQX1BSRUNJU0lPTl9IQUxGX0ZMT0FUXFxuI2RlZmluZSBDT01QUkVTU0lPTl9GQUNUT1IgMC4yNVxcbiNlbHNlXFxuI2RlZmluZSBDT01QUkVTU0lPTl9GQUNUT1IgMS4wXFxuI2VuZGlmXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxudm9pZCBtYWluKCkge1xcbiNpZmRlZiBISVRURVNUXFxuZ2xfRnJhZ0NvbG9yID0gdl9oaXR0ZXN0UmVzdWx0O1xcbiNlbHNlXFxuZmxvYXQgcmFkaXVzID0gbGVuZ3RoKHZfb2Zmc2V0RnJvbUNlbnRlcik7XFxuZmxvYXQgc2hhcGVXZWlnaHQgPSBzdGVwKHJhZGl1cywgMS4wKTtcXG5mbG9hdCBvbmVNaW51c1JhZGl1c1NxdWFyZWQgPSAxLjAgLSByYWRpdXMgKiByYWRpdXM7XFxuZmxvYXQga2VybmVsV2VpZ2h0ID0gb25lTWludXNSYWRpdXNTcXVhcmVkICogb25lTWludXNSYWRpdXNTcXVhcmVkO1xcbmdsX0ZyYWdDb2xvciA9IHZlYzQoc2hhcGVXZWlnaHQgKiBrZXJuZWxXZWlnaHQgKiB2X2ZpZWxkVmFsdWUgKiBDT01QUkVTU0lPTl9GQUNUT1IpO1xcbiNlbmRpZlxcbn1cIixcImhlYXRtYXBBY2N1bXVsYXRlLnZlcnRcIjpcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3ZlcnRleE9mZnNldDtcXG52ZWM0IGFfY29sb3IgPSB2ZWM0KDAuMCk7XFxudmVjMiBhX3pvb21SYW5nZSA9IHZlYzIoMC4wLCAxMDAwMC4wKTtcXG51bmlmb3JtIGZsb2F0IHVfcmFkaXVzO1xcbnVuaWZvcm0gZmxvYXQgdV9pc0ZpZWxkQWN0aXZlO1xcbiNpbmNsdWRlIDxtYXRlcmlhbHMvdmNvbW1vbi5nbHNsPlxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvaGl0dGVzdC9jb21tb24uZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL2ljb24vaGVhdG1hcEFjY3VtdWxhdGUvY29tbW9uLmdsc2w+XFxudm9pZCBtYWluKCkge1xcbmZsb2F0IGZpbHRlckZsYWdzID0gZ2V0RmlsdGVyRmxhZ3MoKTtcXG4jaWZkZWYgSElUVEVTVFxcbmhpZ2hwIHZlYzQgb3V0X2hpdHRlc3RSZXN1bHQgPSB2ZWM0KDAuKTtcXG5oaWdocCB2ZWMzIG91dF9wb3MgPSB2ZWMzKDAuKTtcXG52ZWMzIHBvcyA9IHVfdmlld01hdDMgKiB1X3RpbGVNYXQzICogdmVjMyhhX3BvcyAqIFBPU0lUSU9OX1BSRUNJU0lPTiwgMS4wKTtcXG5oaXR0ZXN0TWFya2VyKG91dF9oaXR0ZXN0UmVzdWx0LCBvdXRfcG9zLCBwb3MsIHVfcmFkaXVzKTtcXG52X2hpdHRlc3RSZXN1bHQgPSBvdXRfaGl0dGVzdFJlc3VsdDtcXG5nbF9Qb2ludFNpemUgPSAxLjtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcChhX2NvbG9yLCBvdXRfcG9zLCBmaWx0ZXJGbGFncywgYV96b29tUmFuZ2UpLCAxLjApO1xcbiNlbHNlXFxudl9vZmZzZXRGcm9tQ2VudGVyID0gc2lnbihhX3ZlcnRleE9mZnNldCk7XFxudl9maWVsZFZhbHVlID0gZ2V0QXR0cmlidXRlRGF0YTIoYV9pZCkueCAqIHVfaXNGaWVsZEFjdGl2ZSArIDEuMCAtIHVfaXNGaWVsZEFjdGl2ZTtcXG52ZWMzIGNlbnRlclBvcyA9IHVfZHZzTWF0MyAqIHZlYzMoYV9wb3MgKiBQT1NJVElPTl9QUkVDSVNJT04sIDEuMCk7XFxudmVjMyB2ZXJ0ZXhQb3MgPSBjZW50ZXJQb3MgKyB1X2Rpc3BsYXlWaWV3TWF0MyAqIHZlYzModl9vZmZzZXRGcm9tQ2VudGVyLCAwLjApICogdV9yYWRpdXM7XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXAoYV9jb2xvciwgdmVydGV4UG9zLCBmaWx0ZXJGbGFncywgYV96b29tUmFuZ2UpLCAxLjApO1xcbiNlbmRpZlxcbn1cIn0sXCJoaXR0ZXN0Lmdsc2xcIjpcIiNpZmRlZiBISVRURVNUXFxuI2luY2x1ZGUgPG1hdGVyaWFscy9oaXR0ZXN0L2NvbW1vbi5nbHNsPlxcbmF0dHJpYnV0ZSB2ZWMyIGFfdmVydGV4T2Zmc2V0MTtcXG5hdHRyaWJ1dGUgdmVjMiBhX3ZlcnRleE9mZnNldDI7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZHMxO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmRzMjtcXG52ZWMyIGdldFRleHR1cmVDb29yZHMoaW4gdmVjMyBiYXJ5LCBpbiB2ZWMyIHRleENvb3JkczAsIGluIHZlYzIgdGV4Q29vcmRzMSwgaW4gdmVjMiB0ZXhDb29yZHMyKSB7XFxucmV0dXJuIHRleENvb3JkczAgKiBiYXJ5LnggKyB0ZXhDb29yZHMxICogYmFyeS55ICsgdGV4Q29vcmRzMiAqIGJhcnkuejtcXG59XFxudm9pZCBoaXR0ZXN0SWNvbihcXG5pbm91dCBsb3dwIHZlYzQgb3V0X2NvbG9yLFxcbm91dCBoaWdocCB2ZWMzIG91dF9wb3MsXFxuaW4gdmVjMyBwb3MsXFxuaW4gdmVjMyBvZmZzZXQsXFxuaW4gdmVjMiBzaXplLFxcbmluIGZsb2F0IHNjYWxlRmFjdG9yLFxcbmluIGZsb2F0IGlzTWFwQWxpZ25lZFxcbikge1xcbm91dF9wb3MgPSB2ZWMzKGdldEF0dHJpYnV0ZURhdGFUZXh0dXJlQ29vcmRzKGFfaWQpLCAwLjApO1xcbnZlYzMgcG9zQmFzZSA9IHVfdmlld01hdDMgKiB1X3RpbGVNYXQzICAqIHBvcztcXG52ZWMzIG9mZnNldDEgPSBzY2FsZUZhY3RvciAqIHZlYzMoYV92ZXJ0ZXhPZmZzZXQxIC8gMTYuMCwgMC4pO1xcbnZlYzMgb2Zmc2V0MiA9IHNjYWxlRmFjdG9yICogdmVjMyhhX3ZlcnRleE9mZnNldDIgLyAxNi4wLCAwLik7XFxudmVjMiBwb3MwICAgID0gKHBvc0Jhc2UgKyBnZXRNYXRyaXhOb0Rpc3BsYXkoaXNNYXBBbGlnbmVkKSAqIG9mZnNldCkueHk7XFxudmVjMiBwb3MxICAgID0gKHBvc0Jhc2UgKyBnZXRNYXRyaXhOb0Rpc3BsYXkoaXNNYXBBbGlnbmVkKSAqIG9mZnNldDEpLnh5O1xcbnZlYzIgcG9zMiAgICA9IChwb3NCYXNlICsgZ2V0TWF0cml4Tm9EaXNwbGF5KGlzTWFwQWxpZ25lZCkgKiBvZmZzZXQyKS54eTtcXG52ZWMzIGJhcnkwID0geHlUb0JhcnljZW50cmljKHVfaGl0dGVzdFBvcyArIHZlYzIoLXVfaGl0dGVzdERpc3QsIC11X2hpdHRlc3REaXN0KSwgcG9zMCwgcG9zMSwgcG9zMik7XFxudmVjMyBiYXJ5MSA9IHh5VG9CYXJ5Y2VudHJpYyh1X2hpdHRlc3RQb3MgKyB2ZWMyKDAuLCAtdV9oaXR0ZXN0RGlzdCksIHBvczAsIHBvczEsIHBvczIpO1xcbnZlYzMgYmFyeTIgPSB4eVRvQmFyeWNlbnRyaWModV9oaXR0ZXN0UG9zICsgdmVjMih1X2hpdHRlc3REaXN0LCAtdV9oaXR0ZXN0RGlzdCksIHBvczAsIHBvczEsIHBvczIpO1xcbnZlYzMgYmFyeTMgPSB4eVRvQmFyeWNlbnRyaWModV9oaXR0ZXN0UG9zICsgdmVjMigtdV9oaXR0ZXN0RGlzdCwgMC4pLCBwb3MwLCBwb3MxLCBwb3MyKTtcXG52ZWMzIGJhcnk0ID0geHlUb0JhcnljZW50cmljKHVfaGl0dGVzdFBvcywgcG9zMCwgcG9zMSwgcG9zMik7XFxudmVjMyBiYXJ5NSA9IHh5VG9CYXJ5Y2VudHJpYyh1X2hpdHRlc3RQb3MgKyB2ZWMyKHVfaGl0dGVzdERpc3QsIDAuKSwgcG9zMCwgcG9zMSwgcG9zMik7XFxudmVjMyBiYXJ5NiA9IHh5VG9CYXJ5Y2VudHJpYyh1X2hpdHRlc3RQb3MgKyB2ZWMyKC11X2hpdHRlc3REaXN0LCB1X2hpdHRlc3REaXN0KSwgcG9zMCwgcG9zMSwgcG9zMik7XFxudmVjMyBiYXJ5NyA9IHh5VG9CYXJ5Y2VudHJpYyh1X2hpdHRlc3RQb3MgKyB2ZWMyKDAuLCB1X2hpdHRlc3REaXN0KSwgcG9zMCwgcG9zMSwgcG9zMik7XFxudmVjMyBiYXJ5OCA9IHh5VG9CYXJ5Y2VudHJpYyh1X2hpdHRlc3RQb3MgKyB2ZWMyKHVfaGl0dGVzdERpc3QsIHVfaGl0dGVzdERpc3QpLCBwb3MwLCBwb3MxLCBwb3MyKTtcXG52ZWMyIHRleDAgPSBhX3RleENvb3JkcyAgLyB1X21vc2FpY1NpemU7XFxudmVjMiB0ZXgxID0gYV90ZXhDb29yZHMxIC8gdV9tb3NhaWNTaXplO1xcbnZlYzIgdGV4MiA9IGFfdGV4Q29vcmRzMiAvIHVfbW9zYWljU2l6ZTtcXG5mbG9hdCBhbHBoYVN1bSA9IDAuO1xcbmFscGhhU3VtICs9IGluVHJpYW5nbGUoYmFyeTApICogZ2V0Q29sb3Ioc2l6ZSwgZ2V0VGV4dHVyZUNvb3JkcyhiYXJ5MCwgdGV4MCwgdGV4MSwgdGV4MikpLmE7XFxuYWxwaGFTdW0gKz0gaW5UcmlhbmdsZShiYXJ5MSkgKiBnZXRDb2xvcihzaXplLCBnZXRUZXh0dXJlQ29vcmRzKGJhcnkxLCB0ZXgwLCB0ZXgxLCB0ZXgyKSkuYTtcXG5hbHBoYVN1bSArPSBpblRyaWFuZ2xlKGJhcnkyKSAqIGdldENvbG9yKHNpemUsIGdldFRleHR1cmVDb29yZHMoYmFyeTIsIHRleDAsIHRleDEsIHRleDIpKS5hO1xcbmFscGhhU3VtICs9IGluVHJpYW5nbGUoYmFyeTMpICogZ2V0Q29sb3Ioc2l6ZSwgZ2V0VGV4dHVyZUNvb3JkcyhiYXJ5MywgdGV4MCwgdGV4MSwgdGV4MikpLmE7XFxuYWxwaGFTdW0gKz0gaW5UcmlhbmdsZShiYXJ5NCkgKiBnZXRDb2xvcihzaXplLCBnZXRUZXh0dXJlQ29vcmRzKGJhcnk0LCB0ZXgwLCB0ZXgxLCB0ZXgyKSkuYTtcXG5hbHBoYVN1bSArPSBpblRyaWFuZ2xlKGJhcnk1KSAqIGdldENvbG9yKHNpemUsIGdldFRleHR1cmVDb29yZHMoYmFyeTUsIHRleDAsIHRleDEsIHRleDIpKS5hO1xcbmFscGhhU3VtICs9IGluVHJpYW5nbGUoYmFyeTYpICogZ2V0Q29sb3Ioc2l6ZSwgZ2V0VGV4dHVyZUNvb3JkcyhiYXJ5NiwgdGV4MCwgdGV4MSwgdGV4MikpLmE7XFxuYWxwaGFTdW0gKz0gaW5UcmlhbmdsZShiYXJ5NykgKiBnZXRDb2xvcihzaXplLCBnZXRUZXh0dXJlQ29vcmRzKGJhcnk3LCB0ZXgwLCB0ZXgxLCB0ZXgyKSkuYTtcXG5vdXRfcG9zLnogKz0gc3RlcChhbHBoYVN1bSwgLjA1KSAqIDIuMDtcXG5vdXRfY29sb3IgPSB2ZWM0KDEuIC8gMjU1LiwgMC4sIDAuLCBhbHBoYVN1bSAvIDI1NS4pO1xcbn1cXG4jZW5kaWZcIixcImljb24uZnJhZ1wiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9jb25zdGFudHMuZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL3V0aWxzLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9pY29uL2NvbW1vbi5nbHNsPlxcbnZvaWQgbWFpbigpXFxue1xcbiNpZmRlZiBISVRURVNUXFxudmVjNCBjb2xvciA9IHZfY29sb3I7XFxuI2Vsc2VcXG52ZWM0IGNvbG9yID0gZ2V0Q29sb3Iodl9zaXplVGV4Lnh5LCB2X3NpemVUZXguencpO1xcbiNlbmRpZlxcbiNpZmRlZiBISUdITElHSFRcXG5jb2xvci5hID0gc3RlcCgxLjAgLyAyNTUuMCwgY29sb3IuYSk7XFxuI2VuZGlmXFxuZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVwiLFwiaWNvbi52ZXJ0XCI6XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjNCBhX291dGxpbmVDb2xvcjtcXG5hdHRyaWJ1dGUgdmVjNCBhX3NpemVBbmRPdXRsaW5lV2lkdGg7XFxuYXR0cmlidXRlIHZlYzIgYV92ZXJ0ZXhPZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZHM7XFxuYXR0cmlidXRlIHZlYzIgYV9iaXRTZXRBbmREaXN0UmF0aW87XFxuYXR0cmlidXRlIHZlYzIgYV96b29tUmFuZ2U7XFxuI2luY2x1ZGUgPG1hdGVyaWFscy92Y29tbW9uLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9pY29uL2NvbW1vbi5nbHNsPlxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvaWNvbi9oaXR0ZXN0Lmdsc2w+XFxuZmxvYXQgZ2V0TWFya2VyU2NhbGVGYWN0b3IoaW5vdXQgdmVjMiBzaXplLCBpbiBmbG9hdCByZWZlcmVuY2VTaXplKSB7XFxuI2lmZGVmIFZWX1NJWkVcXG5mbG9hdCBmID0gZ2V0U2l6ZShzaXplLnkpIC8gc2l6ZS55O1xcbmZsb2F0IHNpemVGYWN0b3IgPSBzaXplLnkgLyByZWZlcmVuY2VTaXplO1xcbnJldHVybiBnZXRTaXplKHJlZmVyZW5jZVNpemUpIC8gcmVmZXJlbmNlU2l6ZTtcXG4jZWxzZVxcbnJldHVybiAxLjtcXG4jZW5kaWZcXG59XFxudm9pZCBtYWluKClcXG57XFxuSU5JVDtcXG5mbG9hdCBhX2JpdFNldCA9IGFfYml0U2V0QW5kRGlzdFJhdGlvLng7XFxudmVjMyAgcG9zICAgICAgICAgICA9IHZlYzMoYV9wb3MgKiBQT1NJVElPTl9QUkVDSVNJT04sIDEuMCk7XFxudmVjMiAgc2l6ZSAgICAgICAgICA9IGFfc2l6ZUFuZE91dGxpbmVXaWR0aC54eSAqIGFfc2l6ZUFuZE91dGxpbmVXaWR0aC54eSAvIDEyOC4wO1xcbnZlYzMgIG9mZnNldCAgICAgICAgPSB2ZWMzKGFfdmVydGV4T2Zmc2V0IC8gMTYuMCwgMC4pO1xcbmZsb2F0IG91dGxpbmVTaXplICAgPSBhX3NpemVBbmRPdXRsaW5lV2lkdGgueiAqIGFfc2l6ZUFuZE91dGxpbmVXaWR0aC56IC8gMTI4LjA7XFxuZmxvYXQgaXNNYXBBbGlnbmVkICA9IGdldEJpdChhX2JpdFNldCwgQklUU0VUX01BUktFUl9BTElHTk1FTlRfTUFQKTtcXG5mbG9hdCByZWZlcmVuY2VTaXplID0gYV9zaXplQW5kT3V0bGluZVdpZHRoLncgKiBhX3NpemVBbmRPdXRsaW5lV2lkdGgudyAvIDEyOC4wO1xcbmZsb2F0IHNjYWxlU3ltYm9sUHJvcG9ydGlvbmFsbHkgPSBnZXRCaXQoYV9iaXRTZXQsIEJJVFNFVF9NQVJLRVJfU0NBTEVfU1lNQk9MU19QUk9QT1JUSU9OQUxMWSk7XFxuZmxvYXQgc2NhbGVGYWN0b3IgICAgICAgICAgICAgICA9IGdldE1hcmtlclNjYWxlRmFjdG9yKHNpemUsIHJlZmVyZW5jZVNpemUpO1xcbnNpemUueHkgICAgICo9IHNjYWxlRmFjdG9yO1xcbm9mZnNldC54eSAgICo9IHNjYWxlRmFjdG9yO1xcbm91dGxpbmVTaXplICo9IHNjYWxlU3ltYm9sUHJvcG9ydGlvbmFsbHkgKiAoc2NhbGVGYWN0b3IgLSAxLjApICsgMS4wO1xcbnZlYzIgdl90ZXggICA9IGFfdGV4Q29vcmRzIC8gdV9tb3NhaWNTaXplO1xcbmZsb2F0IGZpbHRlckZsYWdzID0gZ2V0RmlsdGVyRmxhZ3MoKTtcXG52X2NvbG9yICAgID0gZ2V0Q29sb3IoYV9jb2xvciwgYV9iaXRTZXQsIEJJVFNFVF9HRU5FUklDX0xPQ0tfQ09MT1IpO1xcbnZfb3BhY2l0eSAgPSBnZXRPcGFjaXR5KCk7XFxudl9pZCAgICAgICA9IG5vcm0oYV9pZCk7XFxudl9wb3MgICAgICA9IHVfZHZzTWF0MyAqIHBvcyArIGdldE1hdHJpeChpc01hcEFsaWduZWQpICogZ2V0Um90YXRpb24oKSAgKiBvZmZzZXQ7XFxudl9zaXplVGV4ICA9IHZlYzQoc2l6ZS54eSwgdl90ZXgueHkpO1xcbiNpZmRlZiBTREZcXG52X2lzVGhpbiAgID0gZ2V0Qml0KGFfYml0U2V0LCBCSVRTRVRfTUFSS0VSX09VVExJTkVfQUxMT1dfQ09MT1JfT1ZFUlJJREUpO1xcbiNpZmRlZiBWVl9DT0xPUlxcbnZfb3ZlcnJpZGluZ091dGxpbmVDb2xvciA9IHZfaXNUaGluO1xcbiNlbHNlXFxudl9vdmVycmlkaW5nT3V0bGluZUNvbG9yID0gMC4wO1xcbiNlbmRpZlxcbnZfb3V0bGluZVdpZHRoID0gbWluKG91dGxpbmVTaXplLCBtYXgobWF4KHNpemUueCwgc2l6ZS55KSAtIDAuOTksIDAuMCkpO1xcbnZfb3V0bGluZUNvbG9yID0gYV9vdXRsaW5lQ29sb3I7XFxudl9kaXN0UmF0aW8gPSBhX2JpdFNldEFuZERpc3RSYXRpby55IC8gMTI4LjA7XFxuI2VuZGlmXFxuI2lmZGVmIEhJVFRFU1RcXG5oaWdocCB2ZWM0IG91dF9jb2xvciA9IHZlYzQoMC4pO1xcbmhpZ2hwIHZlYzMgb3V0X3BvcyAgID0gdmVjMygwLik7XFxuaGl0dGVzdEljb24ob3V0X2NvbG9yLCBvdXRfcG9zLCBwb3MsIG9mZnNldCwgc2l6ZSwgc2NhbGVGYWN0b3IsIGlzTWFwQWxpZ25lZCk7XFxudl9jb2xvciA9IG91dF9jb2xvcjtcXG5nbF9Qb2ludFNpemUgPSAxLjtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcCh2X2NvbG9yLCBvdXRfcG9zLCBmaWx0ZXJGbGFncywgYV96b29tUmFuZ2UpLCAxLjApO1xcbiNlbHNlXFxuZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXAodl9jb2xvciwgdl9wb3MsIGZpbHRlckZsYWdzLCBhX3pvb21SYW5nZSksIDEuMCk7XFxuI2VuZGlmXFxufVwifSxsYWJlbDp7XCJjb21tb24uZ2xzbFwiOlwidW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfem9vbUxldmVsO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X21hcFJvdGF0aW9uO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X21hcEFsaWduZWQ7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzIgdV9tb3NhaWNTaXplO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2FudGlhbGlhc2luZ1dpZHRoO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2VkZ2VEaXN0YW5jZU9mZnNldDtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RleDtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IHZfYW5pbWF0aW9uO1wiLFwibGFiZWwuZnJhZ1wiOlwiI2luY2x1ZGUgPG1hdGVyaWFscy90ZXh0L3RleHQuZnJhZz5cIixcImxhYmVsLnZlcnRcIjpcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL3Zjb21tb24uZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL3RleHQvY29tbW9uLmdsc2w+XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjNCBhX2hhbG9Db2xvcjtcXG5hdHRyaWJ1dGUgdmVjNCBhX3RleEFuZFNpemU7XFxuYXR0cmlidXRlIHZlYzQgYV9yZWZTeW1ib2xBbmRQbGFjZW1lbnRPZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzQgYV9nbHlwaERhdGE7XFxuYXR0cmlidXRlIHZlYzIgYV92ZXJ0ZXhPZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZHM7XFxudW5pZm9ybSBmbG9hdCB1X2lzSGFsb1Bhc3M7XFxudW5pZm9ybSBmbG9hdCB1X2lzQmFja2dyb3VuZFBhc3M7XFxudW5pZm9ybSBmbG9hdCB1X21hcFJvdGF0aW9uO1xcbnVuaWZvcm0gZmxvYXQgdV9tYXBBbGlnbmVkO1xcbmZsb2F0IGdldFooaW4gZmxvYXQgbWluWm9vbSwgaW4gZmxvYXQgbWF4Wm9vbSwgaW4gZmxvYXQgYW5nbGUpIHtcXG5mbG9hdCBnbHlwaEFuZ2xlID0gYW5nbGUgKiAzNjAuMCAvIDI1NC4wO1xcbmZsb2F0IG1hcEFuZ2xlID0gdV9tYXBSb3RhdGlvbiAqIDM2MC4wIC8gMjU0LjA7XFxuZmxvYXQgZGlmZkFuZ2xlID0gbWluKDM2MC4wIC0gYWJzKG1hcEFuZ2xlIC0gZ2x5cGhBbmdsZSksIGFicyhtYXBBbmdsZSAtIGdseXBoQW5nbGUpKTtcXG5mbG9hdCB6ID0gMC4wO1xcbnogKz0gdV9tYXBBbGlnbmVkICogKDIuMCAqICgxLjAgLSBzdGVwKG1pblpvb20sIHVfY3VycmVudFpvb20pKSk7XFxueiArPSB1X21hcEFsaWduZWQgKiAyLjAgKiBzdGVwKDkwLjAsIGRpZmZBbmdsZSk7XFxueiArPSAyLjAgKiAoMS4wIC0gc3RlcCh1X2N1cnJlbnRab29tLCBtYXhab29tKSk7XFxucmV0dXJuIHo7XFxufVxcbnZvaWQgbWFpbigpXFxue1xcbklOSVQ7XFxuZmxvYXQgZ3JvdXBNaW5ab29tICAgID0gZ2V0TWluWm9vbSgpO1xcbmZsb2F0IGdseXBoTWluWm9vbSAgICA9IGFfZ2x5cGhEYXRhLng7XFxuZmxvYXQgZ2x5cGhNYXhab29tICAgID0gYV9nbHlwaERhdGEueTtcXG5mbG9hdCBnbHlwaEFuZ2xlICAgICAgPSBhX2dseXBoRGF0YS56O1xcbmZsb2F0IGFfaXNCYWNrZ3JvdW5kICA9IGFfZ2x5cGhEYXRhLnc7XFxuZmxvYXQgYV9taW5ab29tICAgICAgICAgID0gbWF4KGdyb3VwTWluWm9vbSwgZ2x5cGhNaW5ab29tKTtcXG5mbG9hdCBhX3BsYWNlbWVudFBhZGRpbmcgPSBhX3JlZlN5bWJvbEFuZFBsYWNlbWVudE9mZnNldC54ICogRVhUUlVERV9TQ0FMRV9QTEFDRU1FTlRfUEFERElORztcXG52ZWMyICBhX3BsYWNlbWVudERpciAgICAgPSB1bnBhY2tfdThfbmYzMihhX3JlZlN5bWJvbEFuZFBsYWNlbWVudE9mZnNldC56dyk7XFxuZmxvYXQgYV9yZWZTeW1ib2xTaXplICAgID0gYV9yZWZTeW1ib2xBbmRQbGFjZW1lbnRPZmZzZXQueTtcXG5mbG9hdCBmb250U2l6ZSAgICAgICAgICAgPSBhX3RleEFuZFNpemUuejtcXG5mbG9hdCBoYWxvU2l6ZSAgICAgICAgICAgPSBhX3RleEFuZFNpemUudyAqIE9VVExJTkVfU0NBTEU7XFxudmVjMiAgdmVydGV4T2Zmc2V0ID0gYV92ZXJ0ZXhPZmZzZXQgKiBPRkZTRVRfUFJFQ0lTSU9OO1xcbnZlYzMgIHBvcyAgICAgICAgICA9IHZlYzMoYV9wb3MgKiBQT1NJVElPTl9QUkVDSVNJT04sIDEuMCk7XFxuZmxvYXQgeiAgICAgICAgICAgID0gZ2V0WihhX21pblpvb20sIGdseXBoTWF4Wm9vbSwgZ2x5cGhBbmdsZSk7XFxuZmxvYXQgZm9udFNjYWxlICAgID0gZm9udFNpemUgLyBTREZfRk9OVF9TSVpFO1xcbmZsb2F0IGhhbGZTaXplICAgICA9IGdldFNpemUoYV9yZWZTeW1ib2xTaXplKSAvIDIuMDtcXG5mbG9hdCBhbmltYXRpb24gICAgPSBwb3coZ2V0QW5pbWF0aW9uU3RhdGUoKSwgdmVjNCgyLjApKS5yO1xcbmZsb2F0IGlzVGV4dCA9IDEuMCAtIGFfaXNCYWNrZ3JvdW5kO1xcbmZsb2F0IGlzQmFja2dyb3VuZCA9IHVfaXNCYWNrZ3JvdW5kUGFzcyAqIGFfaXNCYWNrZ3JvdW5kO1xcbnZlYzQgIG5vbkhhbG9Db2xvciA9IChpc0JhY2tncm91bmQgKyBpc1RleHQpICogYV9jb2xvcjtcXG52X2NvbG9yICAgICA9IGFuaW1hdGlvbiAqICgoMS4wIC0gdV9pc0hhbG9QYXNzKSAqIG5vbkhhbG9Db2xvciArICh1X2lzSGFsb1Bhc3MgKiBhX2hhbG9Db2xvcikpO1xcbnZfb3BhY2l0eSAgID0gMS4wO1xcbnZfdGV4ICAgICAgID0gYV90ZXhDb29yZHMgLyB1X21vc2FpY1NpemU7XFxudl9lZGdlRGlzdGFuY2VPZmZzZXQgPSB1X2lzSGFsb1Bhc3MgKiBoYWxvU2l6ZSAvIGZvbnRTY2FsZSAvIE1BWF9TREZfRElTVEFOQ0U7XFxudl9hbnRpYWxpYXNpbmdXaWR0aCAgPSAwLjEwNSAqIFNERl9GT05UX1NJWkUgLyBmb250U2l6ZSAvIHVfcGl4ZWxSYXRpbztcXG52ZWMyIHBsYWNlbWVudE9mZnNldCA9IGFfcGxhY2VtZW50RGlyICogKGhhbGZTaXplICsgYV9wbGFjZW1lbnRQYWRkaW5nKTtcXG52ZWMzIGdseXBoT2Zmc2V0ICAgICA9IHVfZGlzcGxheU1hdDMgKiB2ZWMzKHZlcnRleE9mZnNldCArIHBsYWNlbWVudE9mZnNldCwgMC4wKTtcXG52ZWMzIHZfcG9zICAgICAgICAgICA9IHZlYzMoKHVfZHZzTWF0MyAqIHBvcyArIGdseXBoT2Zmc2V0KS54eSwgeik7XFxuZmxvYXQgaXNIaWRkZW4gPSB1X2lzQmFja2dyb3VuZFBhc3MgKiBpc1RleHQgKyAoMS4wIC0gdV9pc0JhY2tncm91bmRQYXNzKSAqIGFfaXNCYWNrZ3JvdW5kO1xcbnZfcG9zLnogKz0gMi4wICogaXNIaWRkZW47XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KHZfcG9zLCAxLjApO1xcbiNpZmRlZiBERUJVR1xcbnZfY29sb3IgPSB2ZWM0KGFfY29sb3IucmdiLCB6ID09IDAuMCA/IDEuMCA6IDAuNjQ1KTtcXG4jZW5kaWZcXG59XCJ9LGxpbmU6e1wiY29tbW9uLmdsc2xcIjpcInZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBoaWdocCB2ZWMzIHZfaWQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfbGluZUhhbGZXaWR0aDtcXG52YXJ5aW5nIGxvd3AgZmxvYXQgdl9vcGFjaXR5O1xcbiNpZmRlZiBQQVRURVJOXFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl90bGJyO1xcbnZhcnlpbmcgbWVkaXVtcCB2ZWMyIHZfcGF0dGVyblNpemU7XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoUEFUVEVSTikgfHwgZGVmaW5lZChTREYpXFxudmFyeWluZyBoaWdocCBmbG9hdCB2X2FjY3VtdWxhdGVkRGlzdGFuY2U7XFxuI2VuZGlmXFxuI2lmZGVmIFNERlxcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2xpbmVXaWR0aFJhdGlvO1xcbiNlbmRpZlwiLFwiaGl0dGVzdC5nbHNsXCI6XCIjaW5jbHVkZSA8bWF0ZXJpYWxzL2hpdHRlc3QvY29tbW9uLmdsc2w+XFxuI2lmZGVmIEhJVFRFU1RcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvczE7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3MyO1xcbnZvaWQgaGl0dGVzdExpbmUob3V0IGxvd3AgdmVjNCBvdXRfY29sb3IsIG91dCBoaWdocCB2ZWMzIG91dF9wb3MsIGZsb2F0IGhhbGZXaWR0aCkge1xcbnZlYzMgcG9zICAgICAgICA9IHVfdmlld01hdDMgKiB1X3RpbGVNYXQzICogdmVjMyhhX3BvcyAgKiBQT1NJVElPTl9QUkVDSVNJT04sIDEuKTtcXG52ZWMzIHBvczEgICAgICAgPSB1X3ZpZXdNYXQzICogdV90aWxlTWF0MyAqIHZlYzMoYV9wb3MxICogUE9TSVRJT05fUFJFQ0lTSU9OLCAxLik7XFxudmVjMyBwb3MyICAgICAgID0gdV92aWV3TWF0MyAqIHVfdGlsZU1hdDMgKiB2ZWMzKGFfcG9zMiAqIFBPU0lUSU9OX1BSRUNJU0lPTiwgMS4pO1xcbnZlYzMgb3V0VGV4dHVyZUNvb3JkcyA9IHZlYzMoZ2V0QXR0cmlidXRlRGF0YVRleHR1cmVDb29yZHMoYV9pZCksIDAuMCk7XFxuZmxvYXQgZGlzdCA9IG1pbihkaXN0UG9pbnRTZWdtZW50KHVfaGl0dGVzdFBvcywgcG9zLnh5LCBwb3MxLnh5KSxcXG5kaXN0UG9pbnRTZWdtZW50KHVfaGl0dGVzdFBvcywgcG9zLnh5LCBwb3MyLnh5KSkgLSBoYWxmV2lkdGg7XFxub3V0X3BvcyA9IHZlYzMoZ2V0QXR0cmlidXRlRGF0YVRleHR1cmVDb29yZHMoYV9pZCksIDAuMCk7XFxuaWYgKGRpc3QgPj0gdV9oaXR0ZXN0RGlzdCkge1xcbm91dF9wb3MueiArPSAyLjA7XFxufVxcbm91dF9jb2xvciA9IHZlYzQoMS4gLyAyNTUuLCAwLCAwLCBkaXN0IDw9IDAuID8gKDEuIC8gMjU1LikgOiAwLik7XFxufVxcbiNlbmRpZlwiLFwibGluZS5mcmFnXCI6XCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXG4jaW5jbHVkZSA8dXRpbC9lbmNvZGluZy5nbHNsPlxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvY29uc3RhbnRzLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9zeW1ib2xvZ3lUeXBlVXRpbHMuZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL2xpbmUvY29tbW9uLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9zaGFyZWQvbGluZS9jb21tb24uZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL3NoYXJlZC9saW5lL2xpbmUuZnJhZz5cXG4jaWZkZWYgSElUVEVTVFxcbnZvaWQgbWFpbigpIHtcXG5nbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xcbn1cXG4jZWxzZVxcbnZvaWQgbWFpbigpIHtcXG5MaW5lRGF0YSBpbnB1dHMgPSBMaW5lRGF0YShcXG52X2NvbG9yLFxcbnZfbm9ybWFsLFxcbnZfbGluZUhhbGZXaWR0aCxcXG52X29wYWNpdHksXFxuI2lmbmRlZiBTWU1CT0xPR1lfVFlQRV9JU19PVVRMSU5FX0ZJTExfTElLRVxcbiNpZmRlZiBQQVRURVJOXFxudl90bGJyLFxcbnZfcGF0dGVyblNpemUsXFxuI2VuZGlmXFxuI2lmZGVmIFNERlxcbnZfbGluZVdpZHRoUmF0aW8sXFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoUEFUVEVSTikgfHwgZGVmaW5lZChTREYpXFxudl9hY2N1bXVsYXRlZERpc3RhbmNlLFxcbiNlbmRpZlxcbiNlbmRpZlxcbnZfaWRcXG4pO1xcbmdsX0ZyYWdDb2xvciA9IHNoYWRlTGluZShpbnB1dHMpO1xcbn1cXG4jZW5kaWZcIixcImxpbmUudmVydFwiOlwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuYXR0cmlidXRlIHZlYzQgYV9vZmZzZXRBbmROb3JtYWw7XFxuYXR0cmlidXRlIHZlYzIgYV9hY2N1bXVsYXRlZERpc3RhbmNlQW5kSGFsZldpZHRoO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfdGxicjtcXG5hdHRyaWJ1dGUgdmVjNCBhX3NlZ21lbnREaXJlY3Rpb247XFxuYXR0cmlidXRlIHZlYzIgYV9hdXg7XFxuYXR0cmlidXRlIHZlYzIgYV96b29tUmFuZ2U7XFxuI2luY2x1ZGUgPG1hdGVyaWFscy92Y29tbW9uLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9zeW1ib2xvZ3lUeXBlVXRpbHMuZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL2xpbmUvY29tbW9uLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9saW5lL2hpdHRlc3QuZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL3NoYXJlZC9saW5lL2NvbW1vbi5nbHNsPlxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvc2hhcmVkL2xpbmUvbGluZS52ZXJ0PlxcbiNpZmRlZiBISVRURVNUXFxudm9pZCBkcmF3KCkge1xcbmZsb2F0IGFhICAgICAgICA9IDAuNSAqIHVfYW50aWFsaWFzaW5nO1xcbmZsb2F0IGFfaGFsZldpZHRoID0gYV9hY2N1bXVsYXRlZERpc3RhbmNlQW5kSGFsZldpZHRoLnkgLyAxNi47XFxuZmxvYXQgYV9jaW1IYWxmV2lkdGggPSBhX2F1eC54IC8gMTYuIDtcXG52ZWMyICBhX29mZnNldCA9IGFfb2Zmc2V0QW5kTm9ybWFsLnh5IC8gMTYuO1xcbmZsb2F0IGJhc2VXaWR0aCA9IGdldEJhc2VMaW5lSGFsZldpZHRoKGFfaGFsZldpZHRoLCBhX2NpbUhhbGZXaWR0aCk7XFxuZmxvYXQgaGFsZldpZHRoID0gZ2V0TGluZUhhbGZXaWR0aChiYXNlV2lkdGgsIGFhKTtcXG5oaWdocCB2ZWMzIHBvcyAgPSB2ZWMzKDAuKTtcXG52X2NvbG9yID0gdmVjNCgwLik7XFxuaGl0dGVzdExpbmUodl9jb2xvciwgcG9zLCBoYWxmV2lkdGgpO1xcbmdsX1BvaW50U2l6ZSA9IDEuO1xcbmdsX1Bvc2l0aW9uID0gdmVjNChjbGlwKHZfY29sb3IsIHBvcywgZ2V0RmlsdGVyRmxhZ3MoKSwgYV96b29tUmFuZ2UpLCAxLjApO1xcbn1cXG4jZWxzZVxcbnZvaWQgZHJhdygpXFxue1xcbmhpZ2hwIHZlYzMgcG9zID0gdmVjMygwLik7XFxuTGluZURhdGEgb3V0cHV0cyA9IGJ1aWxkTGluZShcXG5wb3MsXFxuYV9pZCxcXG5hX3BvcyxcXG5hX2NvbG9yLFxcbmFfb2Zmc2V0QW5kTm9ybWFsLnh5IC8gMTYuLFxcbmFfb2Zmc2V0QW5kTm9ybWFsLnp3IC8gMTYuLFxcbmFfYWNjdW11bGF0ZWREaXN0YW5jZUFuZEhhbGZXaWR0aC54LFxcbmFfYWNjdW11bGF0ZWREaXN0YW5jZUFuZEhhbGZXaWR0aC55IC8gMTYuLFxcbmFfc2VnbWVudERpcmVjdGlvbi53LFxcbmFfdGxicixcXG5hX3NlZ21lbnREaXJlY3Rpb24ueHkgLyAxNi4sXFxuYV9hdXgueCAvIDE2Llxcbik7XFxudl9pZCAgICAgICAgICAgICAgPSBvdXRwdXRzLmlkO1xcbnZfY29sb3IgICAgICAgICAgID0gb3V0cHV0cy5jb2xvcjtcXG52X25vcm1hbCAgICAgICAgICA9IG91dHB1dHMubm9ybWFsO1xcbnZfbGluZUhhbGZXaWR0aCAgID0gb3V0cHV0cy5saW5lSGFsZldpZHRoO1xcbnZfb3BhY2l0eSAgICAgICAgID0gb3V0cHV0cy5vcGFjaXR5O1xcbiNpZm5kZWYgU1lNQk9MT0dZX1RZUEVfSVNfT1VUTElORV9GSUxMX0xJS0VcXG4jaWZkZWYgUEFUVEVSTlxcbnZfdGxiciAgICAgICAgICA9IG91dHB1dHMudGxicjtcXG52X3BhdHRlcm5TaXplICAgPSBvdXRwdXRzLnBhdHRlcm5TaXplO1xcbiNlbmRpZlxcbiNpZmRlZiBTREZcXG52X2xpbmVXaWR0aFJhdGlvID0gb3V0cHV0cy5saW5lV2lkdGhSYXRpbztcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZChQQVRURVJOKSB8fCBkZWZpbmVkKFNERilcXG52X2FjY3VtdWxhdGVkRGlzdGFuY2UgPSBvdXRwdXRzLmFjY3VtdWxhdGVkRGlzdGFuY2U7XFxuI2VuZGlmXFxuI2VuZGlmXFxuZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXAob3V0cHV0cy5jb2xvciwgcG9zLCBnZXRGaWx0ZXJGbGFncygpLCBhX3pvb21SYW5nZSksIDEuMCk7XFxufVxcbiNlbmRpZlxcbnZvaWQgbWFpbigpIHtcXG5JTklUO1xcbmRyYXcoKTtcXG59XCJ9LHBpZTp7XCJwaWUuY29tbW9uLmdsc2xcIjpcInVuaWZvcm0gZmxvYXQgb3V0bGluZVdpZHRoO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCBzZWN0b3JUaHJlc2hvbGQ7XFxudmFyeWluZyB2ZWMzICB2X2lkO1xcbnZhcnlpbmcgdmVjMyAgdl9wb3M7XFxudmFyeWluZyB2ZWMyICB2X29mZnNldDtcXG52YXJ5aW5nIHZlYzQgIHZfY29sb3I7XFxudmFyeWluZyBmbG9hdCB2X3NpemU7XFxudmFyeWluZyBmbG9hdCB2X251bU9mRW50cmllcztcXG52YXJ5aW5nIGZsb2F0IHZfbWF4U2VjdG9yQW5nbGU7XFxudmFyeWluZyB2ZWMyICB2X2ZpbHRlcmVkU2VjdG9yVG9Db2xvcklkW251bWJlck9mRmllbGRzXTtcXG52YXJ5aW5nIHZlYzIgIHZfdGV4Q29vcmRzO1xcbnZhcnlpbmcgZmxvYXQgdl9vdXRsaW5lV2lkdGg7XFxudmFyeWluZyBmbG9hdCB2X29wYWNpdHk7XFxuc3RydWN0IEZpbHRlcmVkQ2hhcnRJbmZvIHtcXG5mbG9hdCBlbmRTZWN0b3JBbmdsZTtcXG5pbnQgY29sb3JJZDtcXG59O1wiLFwicGllLmZyYWdcIjpcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jaW5jbHVkZSA8dXRpbC9hdGFuMi5nbHNsPlxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvY29uc3RhbnRzLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy91dGlscy5nbHNsPlxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvcGllL3BpZS5jb21tb24uZ2xzbD5cXG51bmlmb3JtIGxvd3AgdmVjNCBjb2xvcnNbbnVtYmVyT2ZGaWVsZHNdO1xcbnVuaWZvcm0gbG93cCB2ZWM0IGRlZmF1bHRDb2xvcjtcXG51bmlmb3JtIGxvd3AgdmVjNCBvdGhlcnNDb2xvcjtcXG51bmlmb3JtIGxvd3AgdmVjNCBvdXRsaW5lQ29sb3I7XFxudW5pZm9ybSBmbG9hdCBkb251dFJhdGlvO1xcbmxvd3AgdmVjNCBnZXRTZWN0b3JDb2xvcihpbiBpbnQgaW5kZXgsIGluIHZlYzIgZmlsdGVyZWRTZWN0b3JUb0NvbG9ySWRbbnVtYmVyT2ZGaWVsZHNdKSB7XFxubWVkaXVtcCBpbnQgY29sb3JJbmRleCA9IGludChmaWx0ZXJlZFNlY3RvclRvQ29sb3JJZFtpbmRleF0ueSk7XFxucmV0dXJuIGNvbG9yc1tjb2xvckluZGV4XTtcXG59XFxuY29uc3QgaW50IE9USEVSX1NFQ1RPUl9JRCA9IDI1NTtcXG4jaWZkZWYgSElUVEVTVFxcbnZlYzQgZ2V0Q29sb3IoKSB7XFxuZmxvYXQgZGlzdGFuY2VTaXplID0gbGVuZ3RoKHZfb2Zmc2V0KSAqIHZfc2l6ZTtcXG5mbG9hdCBkb251dFNpemUgPSBkb251dFJhdGlvICogdl9zaXplO1xcbmZsb2F0IGFscGhhID0gc3RlcChkb251dFNpemUsIGRpc3RhbmNlU2l6ZSkgKiAoMS4wIC0gc3RlcCh2X3NpemUsIGRpc3RhbmNlU2l6ZSkpO1xcbnJldHVybiB2X2NvbG9yO1xcbn1cXG4jZWxzZVxcbnZlYzQgZ2V0Q29sb3IoKSB7XFxuZmxvYXQgYW5nbGUgPSA5MC4wIC0gQ19SQURfVE9fREVHICogYXRhbjIodl9vZmZzZXQueSwgdl9vZmZzZXQueCk7XFxuaWYgKGFuZ2xlIDwgMC4wKSB7XFxuYW5nbGUgKz0gMzYwLjA7XFxufSBlbHNlIGlmIChhbmdsZSA+IDM2MC4wKSB7XFxuYW5nbGUgPSBtb2QoYW5nbGUsIDM2MC4wKTtcXG59XFxuaW50IG51bU9mRW50cmllcyA9IGludCh2X251bU9mRW50cmllcyk7XFxuZmxvYXQgbWF4U2VjdG9yQW5nbGUgPSB2X21heFNlY3RvckFuZ2xlO1xcbmxvd3AgdmVjNCBmaWxsQ29sb3IgPSAobWF4U2VjdG9yQW5nbGUgPiAwLjAgfHwgc2VjdG9yVGhyZXNob2xkID4gMC4wKSA/IG90aGVyc0NvbG9yIDogZGVmYXVsdENvbG9yO1xcbmxvd3AgdmVjNCBwcmV2Q29sb3IgPSB2ZWM0KDAuMCk7XFxubG93cCB2ZWM0IG5leHRDb2xvciA9IHZlYzQoMC4wKTtcXG5mbG9hdCBzdGFydFNlY3RvckFuZ2xlID0gMC4wO1xcbmZsb2F0IGVuZFNlY3RvckFuZ2xlID0gMC4wO1xcbmlmIChhbmdsZSA8IG1heFNlY3RvckFuZ2xlKSB7XFxuZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8IG51bWJlck9mRmllbGRzOyArK2luZGV4KSB7XFxuc3RhcnRTZWN0b3JBbmdsZSA9IGVuZFNlY3RvckFuZ2xlO1xcbmVuZFNlY3RvckFuZ2xlID0gdl9maWx0ZXJlZFNlY3RvclRvQ29sb3JJZFtpbmRleF0ueDtcXG5pZiAoZW5kU2VjdG9yQW5nbGUgPiBhbmdsZSkge1xcbmZpbGxDb2xvciA9IGdldFNlY3RvckNvbG9yKGluZGV4LCB2X2ZpbHRlcmVkU2VjdG9yVG9Db2xvcklkKTtcXG5wcmV2Q29sb3IgPSBzZWN0b3JUaHJlc2hvbGQgIT0gMC4wICYmIGluZGV4ID09IDAgJiYgYWJzKDM2MC4wIC0gbWF4U2VjdG9yQW5nbGUpIDwgRVBTSUxPTiA/IG90aGVyc0NvbG9yIDpcXG5nZXRTZWN0b3JDb2xvcihpbmRleCA+IDAgPyBpbmRleCAtIDEgOiBudW1PZkVudHJpZXMgLSAxLCB2X2ZpbHRlcmVkU2VjdG9yVG9Db2xvcklkKTtcXG5uZXh0Q29sb3IgPSBzZWN0b3JUaHJlc2hvbGQgIT0gMC4wICYmIGFicyhlbmRTZWN0b3JBbmdsZSAtIG1heFNlY3RvckFuZ2xlKSA8IEVQU0lMT04gPyBvdGhlcnNDb2xvciA6XFxuZ2V0U2VjdG9yQ29sb3IoaW5kZXggPCBudW1PZkVudHJpZXMgLSAxID8gaW5kZXggKyAxIDogMCwgdl9maWx0ZXJlZFNlY3RvclRvQ29sb3JJZCk7XFxuYnJlYWs7XFxufVxcbmlmIChpbmRleCA9PSBudW1PZkVudHJpZXMgLSAxKSB7XFxuYnJlYWs7XFxufVxcbn1cXG59IGVsc2Uge1xcbnByZXZDb2xvciA9IGdldFNlY3RvckNvbG9yKG51bU9mRW50cmllcyAtIDEsIHZfZmlsdGVyZWRTZWN0b3JUb0NvbG9ySWQpO1xcbm5leHRDb2xvciA9IGdldFNlY3RvckNvbG9yKDAsIHZfZmlsdGVyZWRTZWN0b3JUb0NvbG9ySWQpO1xcbnN0YXJ0U2VjdG9yQW5nbGUgPSBtYXhTZWN0b3JBbmdsZTtcXG5lbmRTZWN0b3JBbmdsZSA9IDM2MC4wO1xcbn1cXG5sb3dwIHZlYzQgb3V0bGluZUNvbG9yID0gb3V0bGluZUNvbG9yO1xcbmZsb2F0IG9mZnNldCA9IGxlbmd0aCh2X29mZnNldCk7XFxuZmxvYXQgZGlzdGFuY2VTaXplID0gb2Zmc2V0ICogdl9zaXplO1xcbmlmIChzdGFydFNlY3RvckFuZ2xlICE9IDAuMCB8fCBlbmRTZWN0b3JBbmdsZSAhPSAzNjAuMCkge1xcbmZsb2F0IGRpc3RhbmNlVG9TdGFydFNlY3RvciA9IChhbmdsZSAtIHN0YXJ0U2VjdG9yQW5nbGUpO1xcbmZsb2F0IGRpc3RhbmNlVG9FbmRTZWN0b3IgPSAoZW5kU2VjdG9yQW5nbGUgLSBhbmdsZSk7XFxuZmxvYXQgc2VjdG9yVGhyZXNob2xkID0gMC42O1xcbmZsb2F0IGJlZ2luU2VjdG9yQWxwaGEgPSBzbW9vdGhzdGVwKDAuMCwgc2VjdG9yVGhyZXNob2xkLCBkaXN0YW5jZVRvU3RhcnRTZWN0b3IgKiBvZmZzZXQpO1xcbmZsb2F0IGVuZFNlY3RvckFscGhhID0gc21vb3Roc3RlcCgwLjAsIHNlY3RvclRocmVzaG9sZCwgZGlzdGFuY2VUb0VuZFNlY3RvciAqIG9mZnNldCk7XFxuaWYgKGVuZFNlY3RvckFscGhhID4gMC4wKSB7XFxuZmlsbENvbG9yID0gbWl4KG5leHRDb2xvciwgZmlsbENvbG9yLCBlbmRTZWN0b3JBbHBoYSk7XFxufSBlbHNlIGlmIChiZWdpblNlY3RvckFscGhhID4gMC4wKSB7XFxuZmlsbENvbG9yID0gbWl4KHByZXZDb2xvciwgZmlsbENvbG9yLCBiZWdpblNlY3RvckFscGhhKTtcXG59XFxufVxcbmZsb2F0IGRvbnV0U2l6ZSA9IGRvbnV0UmF0aW8gKiAodl9zaXplIC0gdl9vdXRsaW5lV2lkdGgpO1xcbmZsb2F0IGVuZE9mRG9udXQgPSBkb251dFNpemUgLSB2X291dGxpbmVXaWR0aDtcXG5mbG9hdCBhYVRocmVzaG9sZCA9IDAuNzU7XFxuZmxvYXQgaW5uZXJDaXJjbGVBbHBoYSA9IGVuZE9mRG9udXQgLSBhYVRocmVzaG9sZCA+IDAuMCA/IHNtb290aHN0ZXAoZW5kT2ZEb251dCAtIGFhVGhyZXNob2xkLCBlbmRPZkRvbnV0ICsgYWFUaHJlc2hvbGQsIGRpc3RhbmNlU2l6ZSkgOiAxLjA7XFxuZmxvYXQgb3V0ZXJDaXJjbGVBbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAodl9zaXplIC0gYWFUaHJlc2hvbGQsIHZfc2l6ZSArIGFhVGhyZXNob2xkICwgZGlzdGFuY2VTaXplKTtcXG5mbG9hdCBjaXJjbGVBbHBoYSA9IGlubmVyQ2lyY2xlQWxwaGEgKiBvdXRlckNpcmNsZUFscGhhO1xcbmZsb2F0IHN0YXJ0T2ZPdXRsaW5lID0gdl9zaXplIC0gdl9vdXRsaW5lV2lkdGg7XFxuaWYgKHN0YXJ0T2ZPdXRsaW5lID4gMC4wICYmIHZfb3V0bGluZVdpZHRoID4gMC4yNSkge1xcbmZsb2F0IG91dGxpbmVGYWN0b3IgPSBzbW9vdGhzdGVwKHN0YXJ0T2ZPdXRsaW5lIC0gYWFUaHJlc2hvbGQsIHN0YXJ0T2ZPdXRsaW5lICsgYWFUaHJlc2hvbGQsIGRpc3RhbmNlU2l6ZSk7XFxuZmxvYXQgaW5uZXJMaW5lRmFjdG9yID0gZG9udXRTaXplIC0gYWFUaHJlc2hvbGQgPiAwLjAgPyAxLjAgLSBzbW9vdGhzdGVwKGRvbnV0U2l6ZSAtIGFhVGhyZXNob2xkLCBkb251dFNpemUgKyBhYVRocmVzaG9sZCAsIGRpc3RhbmNlU2l6ZSkgOiAwLjA7XFxuZmlsbENvbG9yID0gbWl4KGZpbGxDb2xvciwgb3V0bGluZUNvbG9yLCBpbm5lckxpbmVGYWN0b3IgKyBvdXRsaW5lRmFjdG9yKTtcXG59XFxucmV0dXJuIHZfb3BhY2l0eSAqIGNpcmNsZUFscGhhICogZmlsbENvbG9yO1xcbn1cXG4jZW5kaWZcXG52b2lkIG1haW4oKVxcbntcXG52ZWM0IGNvbG9yID0gZ2V0Q29sb3IoKTtcXG4jaWZkZWYgaGlnaGxpZ2h0XFxuY29sb3IuYSA9IHN0ZXAoMS4wIC8gMjU1LjAsIGNvbG9yLmEpO1xcbiNlbmRpZlxcbmdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cIixcInBpZS52ZXJ0XCI6XCIjaW5jbHVkZSA8bWF0ZXJpYWxzL2NvbnN0YW50cy5nbHNsPlxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvdXRpbHMuZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL2JhcnljZW50cmljLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy92Y29tbW9uLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy92di5nbHNsPlxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvYXR0cmlidXRlRGF0YS5nbHNsPlxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvcGllL3BpZS5jb21tb24uZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL2hpdHRlc3QvY29tbW9uLmdsc2w+XFxuYXR0cmlidXRlIGZsb2F0IGFfYml0U2V0O1xcbmF0dHJpYnV0ZSB2ZWMyICBhX29mZnNldDtcXG5hdHRyaWJ1dGUgdmVjMiAgYV90ZXhDb29yZHM7XFxuYXR0cmlidXRlIHZlYzIgIGFfc2l6ZTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9yZWZlcmVuY2VTaXplO1xcbmF0dHJpYnV0ZSB2ZWMyICBhX3pvb21SYW5nZTtcXG5pbnQgZmlsdGVyVmFsdWUoaW4gZmxvYXQgc2VjdG9yQW5nbGUsXFxuaW4gaW50IGN1cnJlbnRJbmRleCxcXG5pbm91dCBGaWx0ZXJlZENoYXJ0SW5mbyBmaWx0ZXJlZEluZm8sXFxuaW5vdXQgdmVjMiBmaWx0ZXJlZFNlY3RvclRvQ29sb3JJZFtudW1iZXJPZkZpZWxkc10pIHtcXG5pZiAoc2VjdG9yQW5nbGUgPiBzZWN0b3JUaHJlc2hvbGQgKiAzNjAuMCkge1xcbmZpbHRlcmVkSW5mby5lbmRTZWN0b3JBbmdsZSArPSBzZWN0b3JBbmdsZTtcXG5maWx0ZXJlZFNlY3RvclRvQ29sb3JJZFtmaWx0ZXJlZEluZm8uY29sb3JJZF0gPSB2ZWMyKGZpbHRlcmVkSW5mby5lbmRTZWN0b3JBbmdsZSwgY3VycmVudEluZGV4KTtcXG4rK2ZpbHRlcmVkSW5mby5jb2xvcklkO1xcbn1cXG5yZXR1cm4gMDtcXG59XFxuaW50IGZpbHRlclZhbHVlcyhpbm91dCB2ZWMyIGZpbHRlcmVkU2VjdG9yVG9Db2xvcklkW251bWJlck9mRmllbGRzXSxcXG5pbm91dCBGaWx0ZXJlZENoYXJ0SW5mbyBmaWx0ZXJlZEluZm8sXFxuaW4gZmxvYXQgc2VjdG9yQW5nbGVzW251bWJlck9mRmllbGRzXSkge1xcbmZvciAoaW50IGluZGV4ID0gMDsgaW5kZXggPCBudW1iZXJPZkZpZWxkczsgKytpbmRleCkge1xcbmZsb2F0IHNlY3RvclZhbHVlID0gc2VjdG9yQW5nbGVzW2luZGV4XTtcXG5maWx0ZXJWYWx1ZShzZWN0b3JWYWx1ZSwgaW5kZXgsIGZpbHRlcmVkSW5mbywgZmlsdGVyZWRTZWN0b3JUb0NvbG9ySWQpO1xcbn1cXG5yZXR1cm4gZmlsdGVyZWRJbmZvLmNvbG9ySWQ7XFxufVxcbnZlYzIgZ2V0TWFya2VyU2l6ZShpbm91dCB2ZWMyIG9mZnNldCwgaW5vdXQgdmVjMiBiYXNlU2l6ZSwgaW5vdXQgZmxvYXQgb3V0bGluZVNpemUsIGluIGZsb2F0IGFfcmVmZXJlbmNlU2l6ZSwgaW4gZmxvYXQgYml0U2V0KSB7XFxudmVjMiBvdXRTaXplID0gYmFzZVNpemU7XFxuI2lmZGVmIFZWX1NJWkVcXG5mbG9hdCByID0gZ2V0U2l6ZShhX3JlZmVyZW5jZVNpemUsIGN1cnJlbnRTY2FsZSkgLyBhX3JlZmVyZW5jZVNpemU7XFxub3V0U2l6ZS54eSAqPSByO1xcbm9mZnNldC54eSAqPSByO1xcbmZsb2F0IHNjYWxlU3ltYm9sUHJvcG9ydGlvbmFsbHkgPSBnZXRCaXQoYml0U2V0LCBCSVRTRVRfTUFSS0VSX1NDQUxFX1NZTUJPTFNfUFJPUE9SVElPTkFMTFkpO1xcbm91dGxpbmVTaXplICo9IHNjYWxlU3ltYm9sUHJvcG9ydGlvbmFsbHkgKiAociAtIDEuMCkgKyAxLjA7XFxuI2VuZGlmXFxucmV0dXJuIG91dFNpemU7XFxufVxcbnZlYzMgZ2V0T2Zmc2V0KGluIHZlYzIgaW5fb2Zmc2V0LCBmbG9hdCBhX2JpdFNldCkge1xcbmZsb2F0IGlzTWFwQWxpZ25lZCA9IGdldEJpdChhX2JpdFNldCwgQklUU0VUX01BUktFUl9BTElHTk1FTlRfTUFQKTtcXG52ZWMzICBvZmZzZXQgICAgICAgPSB2ZWMzKGluX29mZnNldCwgMC4wKTtcXG5yZXR1cm4gZ2V0TWF0cml4KGlzTWFwQWxpZ25lZCkgKiBvZmZzZXQ7XFxufVxcbmZsb2F0IGZpbHRlck5hTlZhbHVlcyhpbiBmbG9hdCB2YWx1ZSkge1xcbnJldHVybiB2YWx1ZSAhPSBOQU5fTUFHSUNfTlVNQkVSICYmIHZhbHVlID4gMC4wID8gdmFsdWUgOiAwLjA7XFxufVxcbnZvaWQgbWFpbigpXFxue1xcbklOSVQ7XFxudmVjMiAgYV9zaXplICAgPSBhX3NpemU7XFxudmVjMiAgYV9vZmZzZXQgPSBhX29mZnNldCAvIDE2LjA7XFxuZmxvYXQgb3V0bGluZVNpemUgPSBvdXRsaW5lV2lkdGg7XFxuZmxvYXQgYV9iaXRTZXQgPSBhX2JpdFNldDtcXG5mbG9hdCBhX3JlZmVyZW5jZVNpemUgPSBhX3JlZmVyZW5jZVNpemU7XFxudmVjMiBhX3RleENvb3JkcyA9IGFfdGV4Q29vcmRzIC8gNC4wO1xcbnZlYzIgbWFya2VyU2l6ZSA9IGdldE1hcmtlclNpemUoYV9vZmZzZXQsIGFfc2l6ZSwgb3V0bGluZVNpemUsIGFfcmVmZXJlbmNlU2l6ZSwgYV9iaXRTZXQpO1xcbmZsb2F0IGZpbHRlckZsYWdzID0gZ2V0RmlsdGVyRmxhZ3MoKTtcXG52ZWMzICBwb3MgICAgICAgICA9IHZlYzMoYV9wb3MgLyAxMC4wLCAxLjApO1xcbnZfb3BhY2l0eSAgICAgID0gZ2V0T3BhY2l0eSgpO1xcbnZfaWQgICAgICAgICAgID0gbm9ybShhX2lkKTtcXG52X3BvcyAgICAgICAgICA9IGRpc3BsYXlWaWV3U2NyZWVuTWF0MyAqIHBvcyArIGdldE9mZnNldChhX29mZnNldCwgYV9iaXRTZXQpO1xcbnZfb2Zmc2V0ICAgICAgID0gc2lnbihhX3RleENvb3JkcyAtIDAuNSk7XFxudl9zaXplICAgICAgICAgPSBtYXgobWFya2VyU2l6ZS54LCBtYXJrZXJTaXplLnkpO1xcbnZfb3V0bGluZVdpZHRoID0gb3V0bGluZVNpemU7XFxuZmxvYXQgYXR0cmlidXRlRGF0YVsxMF07XFxudmVjNCBhdHRyaWJ1dGVEYXRhMyA9IGdldERhdGFEcml2ZW4wKGFfaWQpO1xcbmF0dHJpYnV0ZURhdGFbMF0gPSBmaWx0ZXJOYU5WYWx1ZXMoYXR0cmlidXRlRGF0YTMueCk7XFxuYXR0cmlidXRlRGF0YVsxXSA9IGZpbHRlck5hTlZhbHVlcyhhdHRyaWJ1dGVEYXRhMy55KTtcXG5hdHRyaWJ1dGVEYXRhWzJdID0gZmlsdGVyTmFOVmFsdWVzKGF0dHJpYnV0ZURhdGEzLnopO1xcbmF0dHJpYnV0ZURhdGFbM10gPSBmaWx0ZXJOYU5WYWx1ZXMoYXR0cmlidXRlRGF0YTMudyk7XFxuI2lmIChudW1iZXJPZkZpZWxkcyA+IDQpXFxudmVjNCBhdHRyaWJ1dGVEYXRhNCA9IGdldERhdGFEcml2ZW4xKGFfaWQpO1xcbmF0dHJpYnV0ZURhdGFbNF0gPSBmaWx0ZXJOYU5WYWx1ZXMoYXR0cmlidXRlRGF0YTQueCk7XFxuYXR0cmlidXRlRGF0YVs1XSA9IGZpbHRlck5hTlZhbHVlcyhhdHRyaWJ1dGVEYXRhNC55KTtcXG5hdHRyaWJ1dGVEYXRhWzZdID0gZmlsdGVyTmFOVmFsdWVzKGF0dHJpYnV0ZURhdGE0LnopO1xcbmF0dHJpYnV0ZURhdGFbN10gPSBmaWx0ZXJOYU5WYWx1ZXMoYXR0cmlidXRlRGF0YTQudyk7XFxuI2VuZGlmXFxuI2lmIChudW1iZXJPZkZpZWxkcyA+IDgpXFxudmVjNCBhdHRyaWJ1dGVEYXRhNSA9IGdldERhdGFEcml2ZW4yKGFfaWQpO1xcbmF0dHJpYnV0ZURhdGFbOF0gPSBmaWx0ZXJOYU5WYWx1ZXMoYXR0cmlidXRlRGF0YTUueCk7XFxuYXR0cmlidXRlRGF0YVs5XSA9IGZpbHRlck5hTlZhbHVlcyhhdHRyaWJ1dGVEYXRhNS55KTtcXG4jZW5kaWZcXG5mbG9hdCBzdW0gPSAwLjA7XFxuZm9yIChpbnQgaSA9IDA7IGkgPCBudW1iZXJPZkZpZWxkczsgKytpKSB7XFxuc3VtICs9IGF0dHJpYnV0ZURhdGFbaV07XFxufVxcbmZsb2F0IHNlY3RvckFuZ2xlc1tudW1iZXJPZkZpZWxkc107XFxuZm9yIChpbnQgaSA9IDA7IGkgPCBudW1iZXJPZkZpZWxkczsgKytpKSB7XFxuc2VjdG9yQW5nbGVzW2ldID0gMzYwLjAgKiBhdHRyaWJ1dGVEYXRhW2ldIC8gc3VtO1xcbn1cXG52ZWMyIGZpbHRlcmVkU2VjdG9yVG9Db2xvcklkW251bWJlck9mRmllbGRzXTtcXG5GaWx0ZXJlZENoYXJ0SW5mbyBmaWx0ZXJlZEluZm8gPSBGaWx0ZXJlZENoYXJ0SW5mbygwLjAsIDApO1xcbmludCBudW1PZkVudHJpZXMgPSBmaWx0ZXJWYWx1ZXMoZmlsdGVyZWRTZWN0b3JUb0NvbG9ySWQsIGZpbHRlcmVkSW5mbywgc2VjdG9yQW5nbGVzKTtcXG52X251bU9mRW50cmllcyA9IGZsb2F0KG51bU9mRW50cmllcyk7XFxudl9tYXhTZWN0b3JBbmdsZSA9IGZpbHRlcmVkSW5mby5lbmRTZWN0b3JBbmdsZTtcXG52X2ZpbHRlcmVkU2VjdG9yVG9Db2xvcklkID0gZmlsdGVyZWRTZWN0b3JUb0NvbG9ySWQ7XFxuI2lmZGVmIEhJVFRFU1RcXG5oaWdocCB2ZWMzIG91dF9wb3MgPSB2ZWMzKDAuMCk7XFxudl9jb2xvciAgICAgICAgICAgID0gdmVjNCgwLjApO1xcbmhpdHRlc3RNYXJrZXIodl9jb2xvciwgb3V0X3Bvcywgdmlld01hdDMgKiB0aWxlTWF0MyAqICBwb3MsIHZfc2l6ZSk7XFxuZ2xfUG9pbnRTaXplID0gMS4wO1xcbmdsX1Bvc2l0aW9uID0gdmVjNChjbGlwKHZfY29sb3IsIG91dF9wb3MsIGZpbHRlckZsYWdzLCBhX3pvb21SYW5nZSksIDEuMCk7XFxuI2Vsc2VcXG5nbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcCh2X2NvbG9yLCB2X3BvcywgZmlsdGVyRmxhZ3MsIGFfem9vbVJhbmdlKSwgMS4wKTtcXG4jZW5kaWZcXG59XCJ9LHNoYXJlZDp7bGluZTp7XCJjb21tb24uZ2xzbFwiOlwiI2lmICFkZWZpbmVkKFNZTUJPTE9HWV9UWVBFX0lTX09VVExJTkVfRklMTF9MSUtFKSAmJiBkZWZpbmVkKFBBVFRFUk4pXFxudW5pZm9ybSBtZWRpdW1wIHZlYzIgdV9tb3NhaWNTaXplO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X3NhbXBsZUFscGhhT25seTtcXG4jZW5kaWZcXG5zdHJ1Y3QgTGluZURhdGEge1xcbmxvd3AgdmVjNCBjb2xvcjtcXG5tZWRpdW1wIHZlYzIgbm9ybWFsO1xcbm1lZGl1bXAgZmxvYXQgbGluZUhhbGZXaWR0aDtcXG5sb3dwIGZsb2F0IG9wYWNpdHk7XFxuI2lmbmRlZiBTWU1CT0xPR1lfVFlQRV9JU19PVVRMSU5FX0ZJTExfTElLRVxcbiNpZmRlZiBQQVRURVJOXFxubWVkaXVtcCB2ZWM0IHRsYnI7XFxubWVkaXVtcCB2ZWMyIHBhdHRlcm5TaXplO1xcbiNlbmRpZlxcbiNpZmRlZiBTREZcXG5tZWRpdW1wIGZsb2F0IGxpbmVXaWR0aFJhdGlvO1xcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKFBBVFRFUk4pIHx8IGRlZmluZWQoU0RGKVxcbmhpZ2hwIGZsb2F0IGFjY3VtdWxhdGVkRGlzdGFuY2U7XFxuI2VuZGlmXFxuI2VuZGlmXFxuaGlnaHAgdmVjMyBpZDtcXG59O1wiLFwibGluZS5mcmFnXCI6XCJ1bmlmb3JtIGxvd3AgZmxvYXQgdV9ibHVyO1xcbiNpZiAhZGVmaW5lZChTWU1CT0xPR1lfVFlQRV9JU19PVVRMSU5FX0ZJTExfTElLRSkgJiYgIWRlZmluZWQoSElHSExJR0hUKVxcbiNpZiBkZWZpbmVkKFBBVFRFUk4pIHx8IGRlZmluZWQoU0RGKVxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG51bmlmb3JtIGhpZ2hwIGZsb2F0IHVfcGl4ZWxSYXRpbztcXG4jZW5kaWZcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZChTREYpICYmICFkZWZpbmVkKEhJR0hMSUdIVCkgJiYgIWRlZmluZWQoU1lNQk9MT0dZX1RZUEVfSVNfT1VUTElORV9GSUxMX0xJS0UpXFxubG93cCB2ZWM0IGdldExpbmVDb2xvcihMaW5lRGF0YSBsaW5lKSB7XFxubWVkaXVtcCBmbG9hdCBhZGp1c3RlZFBhdHRlcm5XaWR0aCA9IGxpbmUucGF0dGVyblNpemUueCAqIDIuMCAqIGxpbmUubGluZVdpZHRoUmF0aW87XFxubWVkaXVtcCBmbG9hdCByZWxhdGl2ZVRleFggPSBmcmFjdChsaW5lLmFjY3VtdWxhdGVkRGlzdGFuY2UgLyBhZGp1c3RlZFBhdHRlcm5XaWR0aCk7XFxubWVkaXVtcCBmbG9hdCByZWxhdGl2ZVRleFkgPSAwLjUgKyAwLjI1ICogbGluZS5ub3JtYWwueTtcXG5tZWRpdW1wIHZlYzIgdGV4Q29vcmQgPSBtaXgobGluZS50bGJyLnh5LCBsaW5lLnRsYnIuencsIHZlYzIocmVsYXRpdmVUZXhYLCByZWxhdGl2ZVRleFkpKTtcXG5tZWRpdW1wIGZsb2F0IGQgPSByZ2JhMmZsb2F0KHRleHR1cmUyRCh1X3RleHR1cmUsIHRleENvb3JkKSkgLSAwLjU7XFxuZmxvYXQgZGlzdCA9IGQgKiBsaW5lLmxpbmVIYWxmV2lkdGg7XFxucmV0dXJuIGxpbmUub3BhY2l0eSAqIGNsYW1wKDAuNSAtIGRpc3QsIDAuMCwgMS4wKSAqIGxpbmUuY29sb3I7XFxufVxcbiNlbGlmIGRlZmluZWQoUEFUVEVSTikgJiYgIWRlZmluZWQoSElHSExJR0hUKSAmJiAhZGVmaW5lZChTWU1CT0xPR1lfVFlQRV9JU19PVVRMSU5FX0ZJTExfTElLRSlcXG5sb3dwIHZlYzQgZ2V0TGluZUNvbG9yKExpbmVEYXRhIGxpbmUpIHtcXG5tZWRpdW1wIGZsb2F0IGxpbmVIYWxmV2lkdGggPSBsaW5lLmxpbmVIYWxmV2lkdGg7XFxubWVkaXVtcCBmbG9hdCBhZGp1c3RlZFBhdHRlcm5IZWlnaHQgPSBsaW5lLnBhdHRlcm5TaXplLnkgKiAyLjAgKiBsaW5lSGFsZldpZHRoIC8gbGluZS5wYXR0ZXJuU2l6ZS54O1xcbm1lZGl1bXAgZmxvYXQgcmVsYXRpdmVUZXhZID0gZnJhY3QobGluZS5hY2N1bXVsYXRlZERpc3RhbmNlIC8gYWRqdXN0ZWRQYXR0ZXJuSGVpZ2h0KTtcXG5tZWRpdW1wIGZsb2F0IHJlbGF0aXZlVGV4WCA9IDAuNSArIDAuNSAqIGxpbmUubm9ybWFsLnk7XFxubWVkaXVtcCB2ZWMyIHRleENvb3JkID0gbWl4KGxpbmUudGxici54eSwgbGluZS50bGJyLnp3LCB2ZWMyKHJlbGF0aXZlVGV4WCwgcmVsYXRpdmVUZXhZKSk7XFxubG93cCB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdGV4Q29vcmQpO1xcbiNpZmRlZiBWVl9DT0xPUlxcbmlmICh2X3NhbXBsZUFscGhhT25seSA+IDAuNSkge1xcbmNvbG9yLnJnYiA9IHZlYzMoY29sb3IuYSk7XFxufVxcbiNlbmRpZlxcbnJldHVybiBsaW5lLm9wYWNpdHkgKiBsaW5lLmNvbG9yICogY29sb3I7XFxufVxcbiNlbHNlXFxubG93cCB2ZWM0IGdldExpbmVDb2xvcihMaW5lRGF0YSBsaW5lKSB7XFxucmV0dXJuIGxpbmUub3BhY2l0eSAqIGxpbmUuY29sb3I7XFxufVxcbiNlbmRpZlxcbnZlYzQgc2hhZGVMaW5lKExpbmVEYXRhIGxpbmUpXFxue1xcbm1lZGl1bXAgZmxvYXQgdGhpbkxpbmVGYWN0b3IgPSBtYXgoVEhJTl9MSU5FX1dJRFRIX0ZBQ1RPUiAqIHN0ZXAobGluZS5saW5lSGFsZldpZHRoLCBUSElOX0xJTkVfSEFMRl9XSURUSCksIDEuMCk7XFxubWVkaXVtcCBmbG9hdCBmcmFnRGlzdCA9IGxlbmd0aChsaW5lLm5vcm1hbCkgKiBsaW5lLmxpbmVIYWxmV2lkdGg7XFxubG93cCBmbG9hdCBhbHBoYSA9IGNsYW1wKHRoaW5MaW5lRmFjdG9yICogKGxpbmUubGluZUhhbGZXaWR0aCAtIGZyYWdEaXN0KSAvICh1X2JsdXIgKyB0aGluTGluZUZhY3RvciAtIDEuMCksIDAuMCwgMS4wKTtcXG5sb3dwIHZlYzQgb3V0X2NvbG9yID0gZ2V0TGluZUNvbG9yKGxpbmUpICogYWxwaGE7XFxuI2lmZGVmIEhJR0hMSUdIVFxcbm91dF9jb2xvci5hID0gc3RlcCgxLjAgLyAyNTUuMCwgb3V0X2NvbG9yLmEpO1xcbiNlbmRpZlxcbiNpZmRlZiBJRFxcbmlmIChvdXRfY29sb3IuYSA8IDEuMCAvIDI1NS4wKSB7XFxuZGlzY2FyZDtcXG59XFxub3V0X2NvbG9yID0gdmVjNChsaW5lLmlkLCAwLjApO1xcbiNlbmRpZlxcbnJldHVybiBvdXRfY29sb3I7XFxufVwiLFwibGluZS52ZXJ0XCI6XCJmbG9hdCBnZXRCYXNlTGluZUhhbGZXaWR0aChpbiBmbG9hdCBsaW5lSGFsZldpZHRoLCBpbiBmbG9hdCByZWZlcmVuY2VIYWxmV2lkdGgpIHtcXG4jaWZkZWYgVlZfU0laRVxcbmZsb2F0IHJlZkxpbmVXaWR0aCA9IDIuMCAqIHJlZmVyZW5jZUhhbGZXaWR0aDtcXG5yZXR1cm4gMC41ICogKGxpbmVIYWxmV2lkdGggLyBtYXgocmVmZXJlbmNlSGFsZldpZHRoLCBFUFNJTE9OKSkgKiBnZXRTaXplKHJlZkxpbmVXaWR0aCk7XFxuI2Vsc2VcXG5yZXR1cm4gbGluZUhhbGZXaWR0aDtcXG4jZW5kaWZcXG59XFxuZmxvYXQgZ2V0TGluZUhhbGZXaWR0aChpbiBmbG9hdCBiYXNlV2lkdGgsIGluIGZsb2F0IGFhKSB7XFxuZmxvYXQgaGFsZldpZHRoID0gbWF4KGJhc2VXaWR0aCArIGFhLCAwLjQ1KSArIDAuMSAqIGFhO1xcbiNpZmRlZiBISUdITElHSFRcXG5oYWxmV2lkdGggPSBtYXgoaGFsZldpZHRoLCAyLjApO1xcbiNlbmRpZlxcbnJldHVybiBoYWxmV2lkdGg7XFxufVxcbnZlYzIgZ2V0RGlzdChpbiB2ZWMyIG9mZnNldCwgaW4gZmxvYXQgaGFsZldpZHRoKSB7XFxuZmxvYXQgdGhpbkxpbmVGYWN0b3IgPSBtYXgoVEhJTl9MSU5FX1dJRFRIX0ZBQ1RPUiAqIHN0ZXAoaGFsZldpZHRoLCBUSElOX0xJTkVfSEFMRl9XSURUSCksIDEuMCk7XFxucmV0dXJuIHRoaW5MaW5lRmFjdG9yICogaGFsZldpZHRoICogb2Zmc2V0O1xcbn1cXG5MaW5lRGF0YSBidWlsZExpbmUoXFxub3V0IHZlYzMgb3V0X3BvcyxcXG5pbiB2ZWMzIGluX2lkLFxcbmluIHZlYzIgaW5fcG9zLFxcbmluIHZlYzQgaW5fY29sb3IsXFxuaW4gdmVjMiBpbl9vZmZzZXQsXFxuaW4gdmVjMiBpbl9ub3JtYWwsXFxuaW4gZmxvYXQgaW5fYWNjdW11bGF0ZWREaXN0LFxcbmluIGZsb2F0IGluX2xpbmVIYWxmV2lkdGgsXFxuaW4gZmxvYXQgaW5fYml0U2V0LFxcbmluIHZlYzQgaW5fdGxicixcXG5pbiB2ZWMyIGluX3NlZ21lbnREaXJlY3Rpb24sXFxuaW4gZmxvYXQgaW5fcmVmZXJlbmNlSGFsZldpZHRoXFxuKVxcbntcXG5mbG9hdCBhYSAgICAgICAgPSAwLjUgKiB1X2FudGlhbGlhc2luZztcXG5mbG9hdCBiYXNlV2lkdGggPSBnZXRCYXNlTGluZUhhbGZXaWR0aChpbl9saW5lSGFsZldpZHRoLCBpbl9yZWZlcmVuY2VIYWxmV2lkdGgpO1xcbmZsb2F0IGhhbGZXaWR0aCA9IGdldExpbmVIYWxmV2lkdGgoYmFzZVdpZHRoLCBhYSk7XFxuZmxvYXQgeiAgICAgICAgID0gMi4wICogc3RlcChiYXNlV2lkdGgsIDAuMCk7XFxudmVjMiAgZGlzdCAgICAgID0gZ2V0RGlzdChpbl9vZmZzZXQsIGhhbGZXaWR0aCk7XFxudmVjMyAgb2Zmc2V0ICAgID0gdV9kaXNwbGF5Vmlld01hdDMgKiB2ZWMzKGRpc3QsIDAuMCk7XFxudmVjMyAgcG9zICAgICAgID0gdV9kdnNNYXQzICogdmVjMyhpbl9wb3MgKiBQT1NJVElPTl9QUkVDSVNJT04sIDEuMCkgKyBvZmZzZXQ7XFxuI2lmZGVmIFNZTUJPTE9HWV9UWVBFX0lTX09VVExJTkVfRklMTF9MSUtFXFxudmVjNCAgY29sb3IgICAgID0gaW5fY29sb3I7XFxuZmxvYXQgb3BhY2l0eSAgID0gMS4wO1xcbiNlbHNlXFxudmVjNCAgY29sb3IgICAgID0gZ2V0Q29sb3IoaW5fY29sb3IsIGluX2JpdFNldCwgQklUU0VUX0dFTkVSSUNfTE9DS19DT0xPUik7XFxuZmxvYXQgb3BhY2l0eSAgID0gZ2V0T3BhY2l0eSgpO1xcbiNpZmRlZiBTREZcXG5jb25zdCBmbG9hdCBTREZfUEFUVEVSTl9IQUxGX1dJRFRIID0gMTUuNTtcXG5mbG9hdCBzY2FsZURhc2ggPSBnZXRCaXQoaW5fYml0U2V0LCBCSVRTRVRfTElORV9TQ0FMRV9EQVNIKTtcXG5mbG9hdCBsaW5lV2lkdGhSYXRpbyA9IChzY2FsZURhc2ggKiBtYXgoaGFsZldpZHRoIC0gMC41NSAqIHVfYW50aWFsaWFzaW5nLCAwLjI1KSArICgxLjAgLSBzY2FsZURhc2gpKSAvIFNERl9QQVRURVJOX0hBTEZfV0lEVEg7XFxuI2VuZGlmXFxuI2VuZGlmXFxuI2lmICFkZWZpbmVkKFNZTUJPTE9HWV9UWVBFX0lTX09VVExJTkVfRklMTF9MSUtFKSAmJiBkZWZpbmVkKFBBVFRFUk4pXFxudl9zYW1wbGVBbHBoYU9ubHkgPSBnZXRCaXQoaW5fYml0U2V0LCBCSVRTRVRfR0VORVJJQ19DT05TSURFUl9BTFBIQV9PTkxZKTtcXG4jZW5kaWZcXG5vdXRfcG9zID0gdmVjMyhwb3MueHksIHopO1xcbnJldHVybiBMaW5lRGF0YShcXG5jb2xvcixcXG5pbl9ub3JtYWwsXFxuaGFsZldpZHRoLFxcbm9wYWNpdHksXFxuI2lmbmRlZiBTWU1CT0xPR1lfVFlQRV9JU19PVVRMSU5FX0ZJTExfTElLRVxcbiNpZmRlZiBQQVRURVJOXFxuaW5fdGxiciAvIHVfbW9zYWljU2l6ZS54eXh5LFxcbnZlYzIoaW5fdGxici56IC0gaW5fdGxici54LCBpbl90bGJyLncgLSBpbl90bGJyLnkpLFxcbiNlbmRpZlxcbiNpZmRlZiBTREZcXG5saW5lV2lkdGhSYXRpbyxcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZChQQVRURVJOKSB8fCBkZWZpbmVkKFNERilcXG5pbl9hY2N1bXVsYXRlZERpc3QgKiB1X3pvb21GYWN0b3IgKyBkb3QoaW5fc2VnbWVudERpcmVjdGlvbiwgZGlzdCksXFxuI2VuZGlmXFxuI2VuZGlmXFxubm9ybShpbl9pZClcXG4pO1xcbn1cIn19LFwic3ltYm9sb2d5VHlwZVV0aWxzLmdsc2xcIjpcIiNpZiBTWU1CT0xPR1lfVFlQRSA9PSBTWU1CT0xPR1lfVFlQRV9PVVRMSU5FX0ZJTEwgfHwgU1lNQk9MT0dZX1RZUEUgPT0gU1lNQk9MT0dZX1RZUEVfT1VUTElORV9GSUxMX1NJTVBMRVxcbiNkZWZpbmUgU1lNQk9MT0dZX1RZUEVfSVNfT1VUTElORV9GSUxMX0xJS0VcXG4jZW5kaWZcXG4jaWYgU1lNQk9MT0dZX1RZUEUgPT0gU1lNQk9MT0dZX1RZUEVfU0lNUExFIHx8IFNZTUJPTE9HWV9UWVBFID09IFNZTUJPTE9HWV9UWVBFX09VVExJTkVfRklMTF9TSU1QTEVcXG4jZGVmaW5lIFNZTUJPTE9HWV9UWVBFX0lTX1NJTVBMRV9MSUtFXFxuI2VuZGlmXCIsdGV4dDp7XCJjb21tb24uZ2xzbFwiOlwidW5pZm9ybSBoaWdocCB2ZWMyIHVfbW9zYWljU2l6ZTtcXG52YXJ5aW5nIGhpZ2hwIHZlYzMgdl9pZDtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMyB2X3BvcztcXG52YXJ5aW5nIGxvd3AgZmxvYXQgdl9vcGFjaXR5O1xcbnZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBoaWdocCB2ZWMyIHZfdGV4O1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2FudGlhbGlhc2luZ1dpZHRoO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2VkZ2VEaXN0YW5jZU9mZnNldDtcXG52YXJ5aW5nIGxvd3AgZmxvYXQgdl90cmFuc3BhcmVuY3k7XCIsXCJoaXR0ZXN0Lmdsc2xcIjpcIiNpbmNsdWRlIDxtYXRlcmlhbHMvaGl0dGVzdC9jb21tb24uZ2xzbD5cIixcInRleHQuZnJhZ1wiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2luY2x1ZGUgPG1hdGVyaWFscy90ZXh0L2NvbW1vbi5nbHNsPlxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbiNpZmRlZiBISVRURVNUXFxudmVjNCBnZXRDb2xvcigpIHtcXG5yZXR1cm4gdl9jb2xvcjtcXG59XFxuI2Vsc2VcXG52ZWM0IGdldENvbG9yKClcXG57XFxuZmxvYXQgU0RGX0NVVE9GRiA9ICgyLjAgLyA4LjApO1xcbmZsb2F0IFNERl9CQVNFX0VER0VfRElTVCA9IDEuMCAtIFNERl9DVVRPRkY7XFxubG93cCBmbG9hdCBkaXN0ID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXgpLmE7XFxubWVkaXVtcCBmbG9hdCBlZGdlID0gU0RGX0JBU0VfRURHRV9ESVNUIC0gdl9lZGdlRGlzdGFuY2VPZmZzZXQ7XFxuI2lmZGVmIEhJR0hMSUdIVFxcbmVkZ2UgLz0gMi4wO1xcbiNlbmRpZlxcbmxvd3AgZmxvYXQgYWEgPSB2X2FudGlhbGlhc2luZ1dpZHRoO1xcbmxvd3AgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKGVkZ2UgLSBhYSwgZWRnZSArIGFhLCBkaXN0KTtcXG5yZXR1cm4gYWxwaGEgKiB2X2NvbG9yICogdl9vcGFjaXR5O1xcbn1cXG4jZW5kaWZcXG52b2lkIG1haW4oKVxcbntcXG5nbF9GcmFnQ29sb3IgPSBnZXRDb2xvcigpO1xcbn1cIixcInRleHQudmVydFwiOlwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNpbmNsdWRlIDxtYXRlcmlhbHMvdXRpbHMuZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL3Zjb21tb24uZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL3RleHQvY29tbW9uLmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy90ZXh0L2hpdHRlc3QuZ2xzbD5cXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfaGFsb0NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfdGV4Rm9udFNpemU7XFxuYXR0cmlidXRlIHZlYzQgYV9hdXg7XFxuYXR0cmlidXRlIHZlYzIgYV96b29tUmFuZ2U7XFxuYXR0cmlidXRlIHZlYzIgYV92ZXJ0ZXhPZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZHM7XFxudW5pZm9ybSBmbG9hdCB1X2lzSGFsb1Bhc3M7XFxudW5pZm9ybSBmbG9hdCB1X2lzQmFja2dyb3VuZFBhc3M7XFxuZmxvYXQgZ2V0VGV4dFNpemUoaW5vdXQgdmVjMiBvZmZzZXQsIGlub3V0IGZsb2F0IGJhc2VTaXplLCBpbiBmbG9hdCByZWZlcmVuY2VTaXplKSB7XFxuI2lmZGVmIFZWX1NJWkVcXG5mbG9hdCByID0gZ2V0U2l6ZShyZWZlcmVuY2VTaXplKSAvIHJlZmVyZW5jZVNpemU7XFxuYmFzZVNpemUgKj0gcjtcXG5vZmZzZXQueHkgKj0gcjtcXG5yZXR1cm4gYmFzZVNpemU7XFxuI2VuZGlmXFxucmV0dXJuIGJhc2VTaXplO1xcbn1cXG52b2lkIG1haW4oKVxcbntcXG5JTklUO1xcbmZsb2F0IGFfaXNCYWNrZ3JvdW5kICA9IGFfYXV4Lnk7XFxuZmxvYXQgYV9yZWZlcmVuY2VTaXplID0gYV9hdXgueiAqIGFfYXV4LnogLyAyNTYuMDtcXG5mbG9hdCBhX2JpdFNldCAgICAgICAgPSBhX2F1eC53O1xcbmZsb2F0IGFfZm9udFNpemUgICAgICA9IGFfdGV4Rm9udFNpemUuejtcXG52ZWMyICBhX29mZnNldCAgICAgICAgPSBhX3ZlcnRleE9mZnNldCAqIE9GRlNFVF9QUkVDSVNJT047XFxudmVjMyAgaW5fcG9zICAgICAgICA9IHZlYzMoYV9wb3MgKiBQT1NJVElPTl9QUkVDSVNJT04sIDEuMCk7XFxuZmxvYXQgZm9udFNpemUgICAgICA9IGdldFRleHRTaXplKGFfb2Zmc2V0LCBhX2ZvbnRTaXplLCBhX3JlZmVyZW5jZVNpemUpO1xcbmZsb2F0IGZvbnRTY2FsZSAgICAgPSBmb250U2l6ZSAvIFNERl9GT05UX1NJWkU7XFxudmVjMyAgb2Zmc2V0ICAgICAgICA9IGdldFJvdGF0aW9uKCkgKiB2ZWMzKGFfb2Zmc2V0LCAwLjApO1xcbm1hdDMgIGV4dHJ1ZGVNYXRyaXggPSBnZXRCaXQoYV9iaXRTZXQsIDApID09IDEuMCA/IHVfZGlzcGxheVZpZXdNYXQzIDogdV9kaXNwbGF5TWF0MztcXG5mbG9hdCBpc1RleHQgPSAxLjAgLSBhX2lzQmFja2dyb3VuZDtcXG5mbG9hdCBpc0JhY2tncm91bmQgPSB1X2lzQmFja2dyb3VuZFBhc3MgKiBhX2lzQmFja2dyb3VuZDtcXG52ZWM0ICBub25IYWxvQ29sb3IgID0gKGlzQmFja2dyb3VuZCAqIGFfY29sb3IpICsgKGlzVGV4dCAqIGdldENvbG9yKGFfY29sb3IsIGFfYml0U2V0LCAxKSk7XFxudl9jb2xvciAgID0gdV9pc0hhbG9QYXNzICogYV9oYWxvQ29sb3IgKyAoMS4wIC0gdV9pc0hhbG9QYXNzKSAqIG5vbkhhbG9Db2xvcjtcXG52X29wYWNpdHkgPSBnZXRPcGFjaXR5KCk7XFxudl9pZCAgICAgID0gbm9ybShhX2lkKTtcXG52X3RleCAgICAgPSBhX3RleENvb3JkcyAvIHVfbW9zYWljU2l6ZTtcXG52X3BvcyAgICAgPSB1X2R2c01hdDMgKiBpbl9wb3MgKyBleHRydWRlTWF0cml4ICogb2Zmc2V0O1xcbmZsb2F0IGlzSGlkZGVuID0gdV9pc0JhY2tncm91bmRQYXNzICogaXNUZXh0ICsgKDEuMCAtIHVfaXNCYWNrZ3JvdW5kUGFzcykgKiBhX2lzQmFja2dyb3VuZDtcXG52X3Bvcy56ICs9IDIuMCAqIGlzSGlkZGVuO1xcbnZfZWRnZURpc3RhbmNlT2Zmc2V0ID0gdV9pc0hhbG9QYXNzICogT1VUTElORV9TQ0FMRSAqIGFfdGV4Rm9udFNpemUudyAvIGZvbnRTY2FsZSAvIE1BWF9TREZfRElTVEFOQ0U7XFxudl9hbnRpYWxpYXNpbmdXaWR0aCAgPSAwLjEwNSAqIFNERl9GT05UX1NJWkUgLyBmb250U2l6ZSAvIHVfcGl4ZWxSYXRpbztcXG4jaWZkZWYgSElUVEVTVFxcbmhpZ2hwIHZlYzMgb3V0X3BvcyAgPSB2ZWMzKDAuKTtcXG52X2NvbG9yID0gdmVjNCgwLik7XFxuaGl0dGVzdE1hcmtlcih2X2NvbG9yLCBvdXRfcG9zLCB1X3ZpZXdNYXQzICogdV90aWxlTWF0MyAqICB2ZWMzKGFfcG9zICogUE9TSVRJT05fUFJFQ0lTSU9OLCAxLjApXFxuKyB1X3RpbGVNYXQzICogb2Zmc2V0LCBmb250U2l6ZSAvIDIuKTtcXG5nbF9Qb2ludFNpemUgPSAxLjtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcCh2X2NvbG9yLCBvdXRfcG9zLCBnZXRGaWx0ZXJGbGFncygpLCBhX3pvb21SYW5nZSksIDEuMCk7XFxuI2Vsc2VcXG5nbF9Qb3NpdGlvbiA9ICB2ZWM0KGNsaXAodl9jb2xvciwgdl9wb3MsIGdldEZpbHRlckZsYWdzKCksIGFfem9vbVJhbmdlKSwgMS4wKTtcXG4jZW5kaWZcXG59XCJ9LFwidXRpbHMuZ2xzbFwiOlwiZmxvYXQgcnNoaWZ0KGluIGZsb2F0IHUzMiwgaW4gaW50IGFtb3VudCkge1xcbnJldHVybiBmbG9vcih1MzIgLyBwb3coMi4wLCBmbG9hdChhbW91bnQpKSk7XFxufVxcbmZsb2F0IGdldEJpdChpbiBmbG9hdCBiaXRzZXQsIGluIGludCBiaXRJbmRleCkge1xcbmZsb2F0IG9mZnNldCA9IHBvdygyLjAsIGZsb2F0KGJpdEluZGV4KSk7XFxucmV0dXJuIG1vZChmbG9vcihiaXRzZXQgLyBvZmZzZXQpLCAyLjApO1xcbn1cXG5jb25zdCBpbnQgbWF4SGlnaGxpZ2h0UmVhc29ucyA9IDY7XFxuZmxvYXQgZ2V0RmlsdGVyQml0KGluIGZsb2F0IGJpdHNldCwgaW4gaW50IGJpdEluZGV4KSB7XFxucmV0dXJuIGdldEJpdChiaXRzZXQsIGJpdEluZGV4ICsgbWF4SGlnaGxpZ2h0UmVhc29ucyk7XFxufVxcbmZsb2F0IGdldEhpZ2hsaWdodEJpdChpbiBmbG9hdCBiaXRzZXQsIGluIGludCBiaXRJbmRleCkge1xcbnJldHVybiBnZXRCaXQoYml0c2V0LCBiaXRJbmRleCk7XFxufVxcbmhpZ2hwIHZlYzMgdW5wYWNrRGlzcGxheUlkVGV4ZWwoaW4gaGlnaHAgdmVjMyBiaXRzZXQpIHtcXG5mbG9hdCBpc0FnZ3JlZ2F0ZSA9IGdldEJpdChiaXRzZXQuYiwgNyk7XFxucmV0dXJuICgxLjAgLSBpc0FnZ3JlZ2F0ZSkgKiBiaXRzZXQgKyBpc0FnZ3JlZ2F0ZSAqICh2ZWMzKGJpdHNldC5yZ2IpIC0gdmVjMygwLjAsIDAuMCwgZmxvYXQoMHg4MCkpKTtcXG59XFxudmVjNCB1bnBhY2soaW4gZmxvYXQgdTMyKSB7XFxuZmxvYXQgciA9IG1vZChyc2hpZnQodTMyLCAwKSwgMjU1LjApO1xcbmZsb2F0IGcgPSBtb2QocnNoaWZ0KHUzMiwgOCksIDI1NS4wKTtcXG5mbG9hdCBiID0gbW9kKHJzaGlmdCh1MzIsIDE2KSwgMjU1LjApO1xcbmZsb2F0IGEgPSBtb2QocnNoaWZ0KHUzMiwgMjQpLCAyNTUuMCk7XFxucmV0dXJuIHZlYzQociwgZywgYiwgYSk7XFxufVxcbnZlYzMgbm9ybShpbiB2ZWMzIHYpIHtcXG5yZXR1cm4gdiAvPSAyNTUuMDtcXG59XFxudmVjNCBub3JtKGluIHZlYzQgdikge1xcbnJldHVybiB2IC89IDI1NS4wO1xcbn1cXG5mbG9hdCBtYXg0KHZlYzQgdGFyZ2V0KSB7XFxucmV0dXJuIG1heChtYXgobWF4KHRhcmdldC54LCB0YXJnZXQueSksIHRhcmdldC56KSwgdGFyZ2V0LncpO1xcbn1cXG52ZWMyIHVucGFja191OF9uZjMyKHZlYzIgYnl0ZXMpIHtcXG5yZXR1cm4gKGJ5dGVzIC0gMTI3LjApIC8gMTI3LjA7XFxufVxcbmhpZ2hwIGZsb2F0IHJhbmQoaW4gdmVjMiBjbykge1xcbmhpZ2hwIGZsb2F0IGEgPSAxMi45ODk4O1xcbmhpZ2hwIGZsb2F0IGIgPSA3OC4yMzM7XFxuaGlnaHAgZmxvYXQgYyA9IDQzNzU4LjU0NTM7XFxuaGlnaHAgZmxvYXQgZHQgPSBkb3QoY28sIHZlYzIoYSxiKSk7XFxuaGlnaHAgZmxvYXQgc24gPSBtb2QoZHQsIDMuMTQpO1xcbnJldHVybiBmcmFjdChzaW4oc24pICogYyk7XFxufVwiLFwidmNvbW1vbi5nbHNsXCI6XCIjaW5jbHVkZSA8bWF0ZXJpYWxzL2NvbnN0YW50cy5nbHNsPlxcbiNpbmNsdWRlIDxtYXRlcmlhbHMvdXRpbHMuZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL2F0dHJpYnV0ZURhdGEuZ2xzbD5cXG4jaW5jbHVkZSA8bWF0ZXJpYWxzL3Z2Lmdsc2w+XFxuI2luY2x1ZGUgPG1hdGVyaWFscy9iYXJ5Y2VudHJpYy5nbHNsPlxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSBoaWdocCB2ZWMzIGFfaWQ7XFxudW5pZm9ybSBoaWdocCBtYXQzIGRpc3BsYXlWaWV3U2NyZWVuTWF0MztcXG51bmlmb3JtIGhpZ2hwIG1hdDMgZGlzcGxheVZpZXdNYXQzO1xcbnVuaWZvcm0gaGlnaHAgbWF0MyBkaXNwbGF5TWF0MztcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdGlsZU1hdDM7XFxudW5pZm9ybSBoaWdocCBtYXQzIHZpZXdNYXQzO1xcbnVuaWZvcm0gaGlnaHAgZmxvYXQgcGl4ZWxSYXRpbztcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgem9vbUZhY3RvcjtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgYW50aWFsaWFzaW5nO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCBjdXJyZW50U2NhbGU7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IGN1cnJlbnRab29tO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCBtZXRlcnNQZXJTUlVuaXQ7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IGFjdGl2ZVJlYXNvbnM7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IGhpZ2hsaWdodEFsbDtcXG52ZWM0IFZWX0FEQVRBID0gdmVjNCgwLjApO1xcbnZvaWQgbG9hZFZpc3VhbFZhcmlhYmxlRGF0YShpbm91dCB2ZWM0IHRhcmdldCkge1xcbnRhcmdldC5yZ2JhID0gZ2V0VmlzdWFsVmFyaWFibGVEYXRhKGFfaWQpO1xcbn1cXG4jaWZkZWYgVlZcXG4jZGVmaW5lIElOSVQgbG9hZFZpc3VhbFZhcmlhYmxlRGF0YShWVl9BREFUQSlcXG4jZWxzZVxcbiNkZWZpbmUgSU5JVFxcbiNlbmRpZlxcbnZlYzQgZ2V0Q29sb3IoaW4gdmVjNCBhX2NvbG9yLCBpbiBmbG9hdCBhX2JpdFNldCwgaW50IGluZGV4KSB7XFxuI2lmZGVmIFZWX0NPTE9SXFxuZmxvYXQgaXNDb2xvckxvY2tlZCAgID0gZ2V0Qml0KGFfYml0U2V0LCBpbmRleCk7XFxucmV0dXJuIGdldFZWQ29sb3IoVlZfQURBVEFbQVRUUl9WVl9DT0xPUl0sIGFfY29sb3IsIGlzQ29sb3JMb2NrZWQpO1xcbiNlbHNlXFxucmV0dXJuIGFfY29sb3I7XFxuI2VuZGlmXFxufVxcbmZsb2F0IGdldE9wYWNpdHkoKSB7XFxuI2lmZGVmIFZWX09QQUNJVFlcXG5yZXR1cm4gZ2V0VlZPcGFjaXR5KFZWX0FEQVRBW0FUVFJfVlZfT1BBQ0lUWV0pO1xcbiNlbHNlXFxucmV0dXJuIDEuMDtcXG4jZW5kaWZcXG59XFxuZmxvYXQgZ2V0U2l6ZShpbiBmbG9hdCBpbl9zaXplLCBpbiBmbG9hdCBjdXJyZW50U2NhbGUpIHtcXG4jaWZkZWYgVlZfU0laRVxcbnJldHVybiBnZXRWVlNpemUoaW5fc2l6ZSwgVlZfQURBVEFbQVRUUl9WVl9TSVpFXSwgY3VycmVudFNjYWxlKTtcXG4jZWxzZVxcbnJldHVybiBpbl9zaXplO1xcbiNlbmRpZlxcbn1cXG5tYXQzIGdldFJvdGF0aW9uKCkge1xcbiNpZmRlZiBWVl9ST1RBVElPTlxcbnJldHVybiBnZXRWVlJvdGF0aW9uTWF0Myhtb2QoVlZfQURBVEFbQVRUUl9WVl9ST1RBVElPTl0sIDM2MC4wKSk7XFxuI2Vsc2VcXG5yZXR1cm4gbWF0MygxLjApO1xcbiNlbmRpZlxcbn1cXG5mbG9hdCBnZXRGaWx0ZXJGbGFncygpIHtcXG4jaWZkZWYgSUdOT1JFU19TQU1QTEVSX1BSRUNJU0lPTlxcbnJldHVybiBjZWlsKGdldEZpbHRlckRhdGEoYV9pZCkueCAqIDI1NS4wKTtcXG4jZWxzZVxcbnJldHVybiBnZXRGaWx0ZXJEYXRhKGFfaWQpLnggKiAyNTUuMDtcXG4jZW5kaWZcXG59XFxudmVjNCBnZXRBbmltYXRpb25TdGF0ZSgpIHtcXG5yZXR1cm4gZ2V0QW5pbWF0aW9uKGFfaWQpO1xcbn1cXG5mbG9hdCBnZXRNaW5ab29tKCkge1xcbnZlYzQgZGF0YTAgPSBnZXRGaWx0ZXJEYXRhKGFfaWQpICogMjU1LjA7XFxucmV0dXJuIGRhdGEwLmc7XFxufVxcbm1hdDMgZ2V0TWF0cml4Tm9EaXNwbGF5KGZsb2F0IGlzTWFwQWxpZ25lZCkge1xcbnJldHVybiBpc01hcEFsaWduZWQgKiB2aWV3TWF0MyAqIHRpbGVNYXQzICsgKDEuMCAtIGlzTWFwQWxpZ25lZCkgKiB0aWxlTWF0MztcXG59XFxubWF0MyBnZXRNYXRyaXgoZmxvYXQgaXNNYXBBbGlnbmVkKSB7XFxucmV0dXJuIGlzTWFwQWxpZ25lZCAqIGRpc3BsYXlWaWV3TWF0MyArICgxLjAgLSBpc01hcEFsaWduZWQpICogZGlzcGxheU1hdDM7XFxufVxcbmZsb2F0IGNoZWNrSGlnaGxpZ2h0Qml0KGZsb2F0IGZpbHRlckZsYWdzLCBpbnQgaW5kZXgpIHtcXG5yZXR1cm4gZ2V0SGlnaGxpZ2h0Qml0KGZpbHRlckZsYWdzLCBpbmRleCkgKiBnZXRCaXQoYWN0aXZlUmVhc29ucywgaW5kZXgpO1xcbn1cXG5mbG9hdCBjaGVja0hpZ2hsaWdodChmbG9hdCBmaWx0ZXJGbGFncykge1xcbmZsb2F0IHJlc3VsdCA9IGNoZWNrSGlnaGxpZ2h0Qml0KGZpbHRlckZsYWdzLCAwKTtcXG5mb3IgKGludCBpID0gMTsgaSA8IG1heEhpZ2hsaWdodFJlYXNvbnM7IGkrKykge1xcbnJlc3VsdCA9IHJlc3VsdCArIGNoZWNrSGlnaGxpZ2h0Qml0KGZpbHRlckZsYWdzLCBpKTtcXG59XFxucmV0dXJuIHN0ZXAoMC4xLCByZXN1bHQgKyBoaWdobGlnaHRBbGwpO1xcbn1cXG52ZWMzIGNsaXAoaW5vdXQgdmVjNCBjb2xvciwgaW5vdXQgdmVjMyBwb3MsIGluIGZsb2F0IGZpbHRlckZsYWdzLCBpbiB2ZWMyIG1pbk1heFpvb20pIHtcXG5wb3MueiArPSAyLjAgKiAoMS4wIC0gZ2V0RmlsdGVyQml0KGZpbHRlckZsYWdzLCAwKSk7XFxuI2lmZGVmIGluc2lkZVxcbnBvcy56ICs9IDIuMCAqICgxLjAgLSBnZXRGaWx0ZXJCaXQoZmlsdGVyRmxhZ3MsIDEpKTtcXG4jZWxpZiBkZWZpbmVkKG91dHNpZGUpXFxucG9zLnogKz0gMi4wICogZ2V0RmlsdGVyQml0KGZpbHRlckZsYWdzLCAxKTtcXG4jZWxpZiBkZWZpbmVkKGhpZ2hsaWdodClcXG5wb3MueiArPSAyLjAgKiAoMS4wIC0gY2hlY2tIaWdobGlnaHQoZmlsdGVyRmxhZ3MpKTtcXG4jZW5kaWZcXG5wb3MueiArPSAyLjAgKiAoc3RlcChtaW5NYXhab29tLnksIGN1cnJlbnRab29tKSArICgxLjAgLSBzdGVwKG1pbk1heFpvb20ueCwgY3VycmVudFpvb20pKSk7XFxucmV0dXJuIHBvcztcXG59XCIsXCJ2di5nbHNsXCI6XCIjaWYgZGVmaW5lZChWVl9TSVpFX01JTl9NQVhfVkFMVUUpIHx8IGRlZmluZWQoVlZfU0laRV9TQ0FMRV9TVE9QUykgfHwgZGVmaW5lZChWVl9TSVpFX0ZJRUxEX1NUT1BTKSB8fCBkZWZpbmVkKFZWX1NJWkVfVU5JVF9WQUxVRSlcXG4jZGVmaW5lIFZWX1NJWkVcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZChWVl9DT0xPUikgfHwgZGVmaW5lZChWVl9TSVpFKSB8fCBkZWZpbmVkKFZWX09QQUNJVFkpIHx8IGRlZmluZWQoVlZfUk9UQVRJT04pXFxuI2RlZmluZSBWVlxcbiNlbmRpZlxcbiNpZmRlZiBWVl9DT0xPUlxcbnVuaWZvcm0gaGlnaHAgZmxvYXQgY29sb3JWYWx1ZXNbOF07XFxudW5pZm9ybSB2ZWM0IGNvbG9yc1s4XTtcXG4jZW5kaWZcXG4jaWZkZWYgVlZfU0laRV9NSU5fTUFYX1ZBTFVFXFxudW5pZm9ybSBoaWdocCB2ZWM0IG1pbk1heFZhbHVlQW5kU2l6ZTtcXG4jZW5kaWZcXG4jaWZkZWYgVlZfU0laRV9TQ0FMRV9TVE9QU1xcbnVuaWZvcm0gaGlnaHAgZmxvYXQgdmFsdWVzWzhdO1xcbnVuaWZvcm0gZmxvYXQgc2l6ZXNbOF07XFxuI2VuZGlmXFxuI2lmZGVmIFZWX1NJWkVfRklFTERfU1RPUFNcXG51bmlmb3JtIGhpZ2hwIGZsb2F0IHZhbHVlc1s4XTtcXG51bmlmb3JtIGZsb2F0IHNpemVzWzhdO1xcbiNlbmRpZlxcbiNpZmRlZiBWVl9TSVpFX1VOSVRfVkFMVUVcXG51bmlmb3JtIGhpZ2hwIGZsb2F0IHVuaXRNZXRlclJhdGlvO1xcbiNlbmRpZlxcbiNpZmRlZiBWVl9PUEFDSVRZXFxudW5pZm9ybSBoaWdocCBmbG9hdCBvcGFjaXR5VmFsdWVzWzhdO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0aWVzWzhdO1xcbiNlbmRpZlxcbiNpZmRlZiBWVl9ST1RBVElPTlxcbnVuaWZvcm0gbG93cCBmbG9hdCByb3RhdGlvblR5cGU7XFxuI2VuZGlmXFxuYm9vbCBpc05hbihmbG9hdCB2YWwpIHtcXG5yZXR1cm4gKHZhbCA9PSBOQU5fTUFHSUNfTlVNQkVSKTtcXG59XFxuI2lmZGVmIFZWX1NJWkVfTUlOX01BWF9WQUxVRVxcbmZsb2F0IGdldFZWTWluTWF4U2l6ZShmbG9hdCBzaXplVmFsdWUsIGZsb2F0IGZhbGxiYWNrKSB7XFxuaWYgKGlzTmFuKHNpemVWYWx1ZSkpIHtcXG5yZXR1cm4gZmFsbGJhY2s7XFxufVxcbmZsb2F0IGludGVycG9sYXRpb25SYXRpbyA9IChzaXplVmFsdWUgIC0gbWluTWF4VmFsdWVBbmRTaXplLngpIC8gKG1pbk1heFZhbHVlQW5kU2l6ZS55IC0gbWluTWF4VmFsdWVBbmRTaXplLngpO1xcbmludGVycG9sYXRpb25SYXRpbyA9IGNsYW1wKGludGVycG9sYXRpb25SYXRpbywgMC4wLCAxLjApO1xcbnJldHVybiBtaW5NYXhWYWx1ZUFuZFNpemUueiArIGludGVycG9sYXRpb25SYXRpbyAqIChtaW5NYXhWYWx1ZUFuZFNpemUudyAtIG1pbk1heFZhbHVlQW5kU2l6ZS56KTtcXG59XFxuI2VuZGlmXFxuI2lmZGVmIFZWX1NJWkVfU0NBTEVfU1RPUFNcXG5mbG9hdCBnZXRWVlNjYWxlU3RvcHNTaXplKGZsb2F0IGN1cnJlbnRTY2FsZSkge1xcbmZsb2F0IG91dFNpemU7XFxuaWYgKGN1cnJlbnRTY2FsZSA8PSB2YWx1ZXNbMF0pIHtcXG5vdXRTaXplID0gc2l6ZXNbMF07XFxufSBlbHNlIHtcXG5pZiAoY3VycmVudFNjYWxlID49IHZhbHVlc1s3XSkge1xcbm91dFNpemUgPSBzaXplc1s3XTtcXG59IGVsc2Uge1xcbmludCBpbmRleDtcXG5pbmRleCA9IC0xO1xcbmZvciAoaW50IGkgPSAwOyBpIDwgODsgaSsrKSB7XFxuaWYgKHZhbHVlc1tpXSA+IGN1cnJlbnRTY2FsZSkge1xcbmluZGV4ID0gaTtcXG5icmVhaztcXG59XFxufVxcbmludCBwcmV2SW5kZXggPSBpbmRleCAtIDE7XFxuZmxvYXQgYSA9IGN1cnJlbnRTY2FsZSAtIHZhbHVlc1twcmV2SW5kZXhdO1xcbmZsb2F0IGIgPSB2YWx1ZXNbaW5kZXhdIC0gdmFsdWVzW3ByZXZJbmRleF07XFxub3V0U2l6ZSA9IG1peChzaXplc1twcmV2SW5kZXhdLCBzaXplc1tpbmRleF0sIGEgLyBiKTtcXG59XFxufVxcbnJldHVybiBvdXRTaXplO1xcbn1cXG4jZW5kaWZcXG4jaWZkZWYgVlZfU0laRV9GSUVMRF9TVE9QU1xcbmNvbnN0IGludCBWVl9TSVpFX04gPSA4O1xcbmZsb2F0IGdldFZWU3RvcHNTaXplKGZsb2F0IHNpemVWYWx1ZSwgZmxvYXQgZmFsbGJhY2spIHtcXG5pZiAoaXNOYW4oc2l6ZVZhbHVlKSkge1xcbnJldHVybiBmYWxsYmFjaztcXG59XFxuaWYgKHNpemVWYWx1ZSA8PSB2YWx1ZXNbMF0pIHtcXG5yZXR1cm4gc2l6ZXNbMF07XFxufVxcbmlmIChzaXplVmFsdWUgPj0gdmFsdWVzW1ZWX1NJWkVfTiAtIDFdKSB7XFxucmV0dXJuIHNpemVzW1ZWX1NJWkVfTiAtIDFdO1xcbn1cXG5mb3IgKGludCBpID0gMTsgaSA8IFZWX1NJWkVfTjsgKytpKSB7XFxuaWYgKHZhbHVlc1tpXSA+PSBzaXplVmFsdWUpIHtcXG5mbG9hdCBmID0gKHNpemVWYWx1ZSAtIHZhbHVlc1tpLTFdKSAvICh2YWx1ZXNbaV0gLSB2YWx1ZXNbaS0xXSk7XFxucmV0dXJuIG1peChzaXplc1tpLTFdLCBzaXplc1tpXSwgZik7XFxufVxcbn1cXG5yZXR1cm4gc2l6ZXNbVlZfU0laRV9OIC0gMV07XFxufVxcbiNlbmRpZlxcbiNpZmRlZiBWVl9TSVpFX1VOSVRfVkFMVUVcXG5mbG9hdCBnZXRWVlVuaXRWYWx1ZShmbG9hdCBzaXplVmFsdWUsIGZsb2F0IGZhbGxiYWNrKSB7XFxuaWYgKGlzTmFuKHNpemVWYWx1ZSkpIHtcXG5yZXR1cm4gZmFsbGJhY2s7XFxufVxcbnJldHVybiBzaXplVmFsdWUgKiAobWV0ZXJzUGVyU1JVbml0IC8gdW5pdE1ldGVyUmF0aW8pO1xcbn1cXG4jZW5kaWZcXG4jaWZkZWYgVlZfT1BBQ0lUWVxcbmNvbnN0IGludCBWVl9PUEFDSVRZX04gPSA4O1xcbmZsb2F0IGdldFZWT3BhY2l0eShmbG9hdCBvcGFjaXR5VmFsdWUpIHtcXG5pZiAoaXNOYW4ob3BhY2l0eVZhbHVlKSkge1xcbnJldHVybiAxLjA7XFxufVxcbmlmIChvcGFjaXR5VmFsdWUgPD0gb3BhY2l0eVZhbHVlc1swXSkge1xcbnJldHVybiBvcGFjaXRpZXNbMF07XFxufVxcbmZvciAoaW50IGkgPSAxOyBpIDwgVlZfT1BBQ0lUWV9OOyArK2kpIHtcXG5pZiAob3BhY2l0eVZhbHVlc1tpXSA+PSBvcGFjaXR5VmFsdWUpIHtcXG5mbG9hdCBmID0gKG9wYWNpdHlWYWx1ZSAtIG9wYWNpdHlWYWx1ZXNbaS0xXSkgLyAob3BhY2l0eVZhbHVlc1tpXSAtIG9wYWNpdHlWYWx1ZXNbaS0xXSk7XFxucmV0dXJuIG1peChvcGFjaXRpZXNbaS0xXSwgb3BhY2l0aWVzW2ldLCBmKTtcXG59XFxufVxcbnJldHVybiBvcGFjaXRpZXNbVlZfT1BBQ0lUWV9OIC0gMV07XFxufVxcbiNlbmRpZlxcbiNpZmRlZiBWVl9ST1RBVElPTlxcbm1hdDQgZ2V0VlZSb3RhdGlvbihmbG9hdCByb3RhdGlvblZhbHVlKSB7XFxuaWYgKGlzTmFuKHJvdGF0aW9uVmFsdWUpKSB7XFxucmV0dXJuIG1hdDQoMSwgMCwgMCwgMCxcXG4wLCAxLCAwLCAwLFxcbjAsIDAsIDEsIDAsXFxuMCwgMCwgMCwgMSk7XFxufVxcbmZsb2F0IHJvdGF0aW9uID0gcm90YXRpb25WYWx1ZTtcXG5pZiAocm90YXRpb25UeXBlID09IDEuMCkge1xcbnJvdGF0aW9uID0gOTAuMCAtIHJvdGF0aW9uO1xcbn1cXG5mbG9hdCBhbmdsZSA9IENfREVHX1RPX1JBRCAqIHJvdGF0aW9uO1xcbmZsb2F0IHNpbkEgPSBzaW4oYW5nbGUpO1xcbmZsb2F0IGNvc0EgPSBjb3MoYW5nbGUpO1xcbnJldHVybiBtYXQ0KGNvc0EsIHNpbkEsIDAsIDAsXFxuLXNpbkEsICBjb3NBLCAwLCAwLFxcbjAsICAgICAwLCAxLCAwLFxcbjAsICAgICAwLCAwLCAxKTtcXG59XFxubWF0MyBnZXRWVlJvdGF0aW9uTWF0MyhmbG9hdCByb3RhdGlvblZhbHVlKSB7XFxuaWYgKGlzTmFuKHJvdGF0aW9uVmFsdWUpKSB7XFxucmV0dXJuIG1hdDMoMSwgMCwgMCxcXG4wLCAxLCAwLFxcbjAsIDAsIDEpO1xcbn1cXG5mbG9hdCByb3RhdGlvbiA9IHJvdGF0aW9uVmFsdWU7XFxuaWYgKHJvdGF0aW9uVHlwZSA9PSAxLjApIHtcXG5yb3RhdGlvbiA9IDkwLjAgLSByb3RhdGlvbjtcXG59XFxuZmxvYXQgYW5nbGUgPSBDX0RFR19UT19SQUQgKiAtcm90YXRpb247XFxuZmxvYXQgc2luQSA9IHNpbihhbmdsZSk7XFxuZmxvYXQgY29zQSA9IGNvcyhhbmdsZSk7XFxucmV0dXJuIG1hdDMoY29zQSwgLXNpbkEsIDAsXFxuc2luQSwgY29zQSwgMCxcXG4wLCAgICAwLCAgICAxKTtcXG59XFxuI2VuZGlmXFxuI2lmZGVmIFZWX0NPTE9SXFxuY29uc3QgaW50IFZWX0NPTE9SX04gPSA4O1xcbnZlYzQgZ2V0VlZDb2xvcihmbG9hdCBjb2xvclZhbHVlLCB2ZWM0IGZhbGxiYWNrLCBmbG9hdCBpc0NvbG9yTG9ja2VkKSB7XFxuaWYgKGlzTmFuKGNvbG9yVmFsdWUpIHx8IGlzQ29sb3JMb2NrZWQgPT0gMS4wKSB7XFxucmV0dXJuIGZhbGxiYWNrO1xcbn1cXG5pZiAoY29sb3JWYWx1ZSA8PSBjb2xvclZhbHVlc1swXSkge1xcbnJldHVybiBjb2xvcnNbMF07XFxufVxcbmZvciAoaW50IGkgPSAxOyBpIDwgVlZfQ09MT1JfTjsgKytpKSB7XFxuaWYgKGNvbG9yVmFsdWVzW2ldID49IGNvbG9yVmFsdWUpIHtcXG5mbG9hdCBmID0gKGNvbG9yVmFsdWUgLSBjb2xvclZhbHVlc1tpLTFdKSAvIChjb2xvclZhbHVlc1tpXSAtIGNvbG9yVmFsdWVzW2ktMV0pO1xcbnJldHVybiBtaXgoY29sb3JzW2ktMV0sIGNvbG9yc1tpXSwgZik7XFxufVxcbn1cXG5yZXR1cm4gY29sb3JzW1ZWX0NPTE9SX04gLSAxXTtcXG59XFxuI2VuZGlmXFxuZmxvYXQgZ2V0VlZTaXplKGluIGZsb2F0IHNpemUsIGluIGZsb2F0IHZ2U2l6ZSwgaW4gZmxvYXQgY3VycmVudFNjYWxlKSAge1xcbiNpZmRlZiBWVl9TSVpFX01JTl9NQVhfVkFMVUVcXG5yZXR1cm4gZ2V0VlZNaW5NYXhTaXplKHZ2U2l6ZSwgc2l6ZSk7XFxuI2VsaWYgZGVmaW5lZChWVl9TSVpFX1NDQUxFX1NUT1BTKVxcbmZsb2F0IG91dFNpemUgPSBnZXRWVlNjYWxlU3RvcHNTaXplKGN1cnJlbnRTY2FsZSk7XFxucmV0dXJuIGlzTmFuKG91dFNpemUpID8gc2l6ZSA6IG91dFNpemU7XFxuI2VsaWYgZGVmaW5lZChWVl9TSVpFX0ZJRUxEX1NUT1BTKVxcbmZsb2F0IG91dFNpemUgPSBnZXRWVlN0b3BzU2l6ZSh2dlNpemUsIHNpemUpO1xcbnJldHVybiBpc05hbihvdXRTaXplKSA/IHNpemUgOiBvdXRTaXplO1xcbiNlbGlmIGRlZmluZWQoVlZfU0laRV9VTklUX1ZBTFVFKVxcbnJldHVybiBnZXRWVlVuaXRWYWx1ZSh2dlNpemUsIHNpemUpO1xcbiNlbHNlXFxucmV0dXJuIHNpemU7XFxuI2VuZGlmXFxufVwifSxcInBvc3QtcHJvY2Vzc2luZ1wiOntibGl0OntcImJsaXQuZnJhZ1wiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbnZvaWQgbWFpbigpIHtcXG5nbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3V2KTtcXG59XCJ9LGJsb29tOntjb21wb3NpdGU6e1wiY29tcG9zaXRlLmZyYWdcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfYmx1clRleHR1cmUxO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfYmx1clRleHR1cmUyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfYmx1clRleHR1cmUzO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfYmx1clRleHR1cmU0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfYmx1clRleHR1cmU1O1xcbnVuaWZvcm0gZmxvYXQgdV9ibG9vbVN0cmVuZ3RoO1xcbnVuaWZvcm0gZmxvYXQgdV9ibG9vbVJhZGl1cztcXG51bmlmb3JtIGZsb2F0IHVfYmxvb21GYWN0b3JzW05VTU1JUFNdO1xcbnVuaWZvcm0gdmVjMyB1X2Jsb29tVGludENvbG9yc1tOVU1NSVBTXTtcXG5mbG9hdCBsZXJwQmxvb21GYWN0b3IoY29uc3QgaW4gZmxvYXQgZmFjdG9yKSB7XFxuZmxvYXQgbWlycm9yRmFjdG9yID0gMS4yIC0gZmFjdG9yO1xcbnJldHVybiBtaXgoZmFjdG9yLCBtaXJyb3JGYWN0b3IsIHVfYmxvb21SYWRpdXMpO1xcbn1cXG52b2lkIG1haW4oKSB7XFxudmVjNCBjb2xvciA9IHVfYmxvb21TdHJlbmd0aCAqIChcXG5sZXJwQmxvb21GYWN0b3IodV9ibG9vbUZhY3RvcnNbMF0pICogdmVjNCh1X2Jsb29tVGludENvbG9yc1swXSwgMS4wKSAqIHRleHR1cmUyRCh1X2JsdXJUZXh0dXJlMSwgdl91dikgK1xcbmxlcnBCbG9vbUZhY3Rvcih1X2Jsb29tRmFjdG9yc1sxXSkgKiB2ZWM0KHVfYmxvb21UaW50Q29sb3JzWzFdLCAxLjApICogdGV4dHVyZTJEKHVfYmx1clRleHR1cmUyLCB2X3V2KSArXFxubGVycEJsb29tRmFjdG9yKHVfYmxvb21GYWN0b3JzWzJdKSAqIHZlYzQodV9ibG9vbVRpbnRDb2xvcnNbMl0sIDEuMCkgKiB0ZXh0dXJlMkQodV9ibHVyVGV4dHVyZTMsIHZfdXYpICtcXG5sZXJwQmxvb21GYWN0b3IodV9ibG9vbUZhY3RvcnNbM10pICogdmVjNCh1X2Jsb29tVGludENvbG9yc1szXSwgMS4wKSAqIHRleHR1cmUyRCh1X2JsdXJUZXh0dXJlNCwgdl91dikgK1xcbmxlcnBCbG9vbUZhY3Rvcih1X2Jsb29tRmFjdG9yc1s0XSkgKiB2ZWM0KHVfYmxvb21UaW50Q29sb3JzWzRdLCAxLjApICogdGV4dHVyZTJEKHVfYmx1clRleHR1cmU1LCB2X3V2KVxcbik7XFxuZ2xfRnJhZ0NvbG9yID0gY2xhbXAoY29sb3IsIDAuMCwgMS4wKTtcXG59XCJ9LGdhdXNzaWFuQmx1cjp7XCJnYXVzc2lhbkJsdXIuZnJhZ1wiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9jb2xvclRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVfdGV4U2l6ZTtcXG51bmlmb3JtIHZlYzIgdV9kaXJlY3Rpb247XFxudmFyeWluZyB2ZWMyIHZfdXY7XFxuI2RlZmluZSBLRVJORUxfUkFESVVTIFJBRElVU1xcbiNkZWZpbmUgU0lHTUEgUkFESVVTXFxuZmxvYXQgZ2F1c3NpYW5QZGYoaW4gZmxvYXQgeCwgaW4gZmxvYXQgc2lnbWEpIHtcXG5yZXR1cm4gMC4zOTg5NCAqIGV4cCgtMC41ICogeCAqIHggLyAoIHNpZ21hICogc2lnbWEpKSAvIHNpZ21hO1xcbn1cXG52b2lkIG1haW4oKSB7XFxudmVjMiBpbnZTaXplID0gMS4wIC8gdV90ZXhTaXplO1xcbmZsb2F0IGZTaWdtYSA9IGZsb2F0KFNJR01BKTtcXG5mbG9hdCB3ZWlnaHRTdW0gPSBnYXVzc2lhblBkZigwLjAsIGZTaWdtYSk7XFxudmVjNCBwaXhlbENvbG9yU3VtID0gdGV4dHVyZTJEKHVfY29sb3JUZXh0dXJlLCB2X3V2KSAqIHdlaWdodFN1bTtcXG5mb3IgKGludCBpID0gMTsgaSA8IEtFUk5FTF9SQURJVVM7IGkgKyspIHtcXG5mbG9hdCB4ID0gZmxvYXQoaSk7XFxuZmxvYXQgdyA9IGdhdXNzaWFuUGRmKHgsIGZTaWdtYSk7XFxudmVjMiB1dk9mZnNldCA9IHVfZGlyZWN0aW9uICogaW52U2l6ZSAqIHg7XFxudmVjNCBzYW1wbGUxID0gdGV4dHVyZTJEKHVfY29sb3JUZXh0dXJlLCB2X3V2ICsgdXZPZmZzZXQpO1xcbnZlYzQgc2FtcGxlMiA9IHRleHR1cmUyRCh1X2NvbG9yVGV4dHVyZSwgdl91diAtIHV2T2Zmc2V0KTtcXG5waXhlbENvbG9yU3VtICs9IChzYW1wbGUxICsgc2FtcGxlMikgKiB3O1xcbndlaWdodFN1bSArPSAyLjAgKiB3O1xcbn1cXG5nbF9GcmFnQ29sb3IgPSBwaXhlbENvbG9yU3VtIC93ZWlnaHRTdW07XFxufVwifSxsdW1pbm9zaXR5SGlnaFBhc3M6e1wibHVtaW5vc2l0eUhpZ2hQYXNzLmZyYWdcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG51bmlmb3JtIHZlYzMgdV9kZWZhdWx0Q29sb3I7XFxudW5pZm9ybSBmbG9hdCB1X2RlZmF1bHRPcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgdV9sdW1pbm9zaXR5VGhyZXNob2xkO1xcbnVuaWZvcm0gZmxvYXQgdV9zbW9vdGhXaWR0aDtcXG52YXJ5aW5nIHZlYzIgdl91djtcXG52b2lkIG1haW4oKSB7XFxudmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdXYpO1xcbnZlYzMgbHVtYSA9IHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCk7XFxuZmxvYXQgdiA9IGRvdCh0ZXhlbC54eXosIGx1bWEpO1xcbnZlYzQgb3V0cHV0Q29sb3IgPSB2ZWM0KHVfZGVmYXVsdENvbG9yLnJnYiwgdV9kZWZhdWx0T3BhY2l0eSk7XFxuZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKHVfbHVtaW5vc2l0eVRocmVzaG9sZCwgdV9sdW1pbm9zaXR5VGhyZXNob2xkICsgdV9zbW9vdGhXaWR0aCwgdik7XFxuZ2xfRnJhZ0NvbG9yID0gbWl4KG91dHB1dENvbG9yLCB0ZXhlbCwgYWxwaGEpO1xcbn1cIn19LGJsdXI6e2dhdXNzaWFuQmx1cjp7XCJnYXVzc2lhbkJsdXIuZnJhZ1wiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9jb2xvclRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVfdGV4U2l6ZTtcXG51bmlmb3JtIHZlYzIgdV9kaXJlY3Rpb247XFxudW5pZm9ybSBmbG9hdCB1X3NpZ21hO1xcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbiNkZWZpbmUgS0VSTkVMX1JBRElVUyBSQURJVVNcXG5mbG9hdCBnYXVzc2lhblBkZihpbiBmbG9hdCB4LCBpbiBmbG9hdCBzaWdtYSkge1xcbnJldHVybiAwLjM5ODk0ICogZXhwKC0wLjUgKiB4ICogeCAvICggc2lnbWEgKiBzaWdtYSkpIC8gc2lnbWE7XFxufVxcbnZvaWQgbWFpbigpIHtcXG52ZWMyIGludlNpemUgPSAxLjAgLyB1X3RleFNpemU7XFxuZmxvYXQgZlNpZ21hID0gdV9zaWdtYTtcXG5mbG9hdCB3ZWlnaHRTdW0gPSBnYXVzc2lhblBkZigwLjAsIGZTaWdtYSk7XFxudmVjNCBwaXhlbENvbG9yU3VtID0gdGV4dHVyZTJEKHVfY29sb3JUZXh0dXJlLCB2X3V2KSAqIHdlaWdodFN1bTtcXG5mb3IgKGludCBpID0gMTsgaSA8IEtFUk5FTF9SQURJVVM7IGkgKyspIHtcXG5mbG9hdCB4ID0gZmxvYXQoaSk7XFxuZmxvYXQgdyA9IGdhdXNzaWFuUGRmKHgsIGZTaWdtYSk7XFxudmVjMiB1dk9mZnNldCA9IHVfZGlyZWN0aW9uICogaW52U2l6ZSAqIHg7XFxudmVjNCBzYW1wbGUxID0gdGV4dHVyZTJEKHVfY29sb3JUZXh0dXJlLCB2X3V2ICsgdXZPZmZzZXQpO1xcbnZlYzQgc2FtcGxlMiA9IHRleHR1cmUyRCh1X2NvbG9yVGV4dHVyZSwgdl91diAtIHV2T2Zmc2V0KTtcXG5waXhlbENvbG9yU3VtICs9IChzYW1wbGUxICsgc2FtcGxlMikgKiB3O1xcbndlaWdodFN1bSArPSAyLjAgKiB3O1xcbn1cXG5nbF9GcmFnQ29sb3IgPSBwaXhlbENvbG9yU3VtIC93ZWlnaHRTdW07XFxufVwifSxcInJhZGlhbC1ibHVyXCI6e1wicmFkaWFsLWJsdXIuZnJhZ1wiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9jb2xvclRleHR1cmU7XFxudmFyeWluZyB2ZWMyIHZfdXY7XFxuY29uc3QgZmxvYXQgc2FtcGxlRGlzdCA9IDEuMDtcXG5jb25zdCBmbG9hdCBzYW1wbGVTdHJlbmd0aCA9IDIuMjtcXG52b2lkIG1haW4odm9pZCkge1xcbmZsb2F0IHNhbXBsZXNbMTBdO1xcbnNhbXBsZXNbMF0gPSAtMC4wODtcXG5zYW1wbGVzWzFdID0gLTAuMDU7XFxuc2FtcGxlc1syXSA9IC0wLjAzO1xcbnNhbXBsZXNbM10gPSAtMC4wMjtcXG5zYW1wbGVzWzRdID0gLTAuMDE7XFxuc2FtcGxlc1s1XSA9ICAwLjAxO1xcbnNhbXBsZXNbNl0gPSAgMC4wMjtcXG5zYW1wbGVzWzddID0gIDAuMDM7XFxuc2FtcGxlc1s4XSA9ICAwLjA1O1xcbnNhbXBsZXNbOV0gPSAgMC4wODtcXG52ZWMyIGRpciA9IDAuNSAtIHZfdXY7XFxuZmxvYXQgZGlzdCA9IHNxcnQoZGlyLnggKiBkaXIueCArIGRpci55ICogZGlyLnkpO1xcbmRpciA9IGRpciAvIGRpc3Q7XFxudmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X2NvbG9yVGV4dHVyZSx2X3V2KTtcXG52ZWM0IHN1bSA9IGNvbG9yO1xcbmZvciAoaW50IGkgPSAwOyBpIDwgMTA7IGkrKykge1xcbnN1bSArPSB0ZXh0dXJlMkQodV9jb2xvclRleHR1cmUsIHZfdXYgKyBkaXIgKiBzYW1wbGVzW2ldICogc2FtcGxlRGlzdCk7XFxufVxcbnN1bSAqPSAxLjAgLyAxMS4wO1xcbmZsb2F0IHQgPSBkaXN0ICogc2FtcGxlU3RyZW5ndGg7XFxudCA9IGNsYW1wKHQsIDAuMCwgMS4wKTtcXG5nbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IsIHN1bSwgdCk7XFxufVwifX0sZHJhOntcImRyYS5mcmFnXCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X21pbkNvbG9yO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfbWF4Q29sb3I7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbnZvaWQgbWFpbigpIHtcXG52ZWM0IG1pbkNvbG9yID0gdGV4dHVyZTJEKHVfbWluQ29sb3IsIHZlYzIoMC41KSk7XFxudmVjNCBtYXhDb2xvciA9IHRleHR1cmUyRCh1X21heENvbG9yLCB2ZWMyKDAuNSkpO1xcbnZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3V2KTtcXG52ZWMzIG1pbkNvbG9yVW5wcmVtdWx0aXBseSA9IG1pbkNvbG9yLnJnYiAvIG1pbkNvbG9yLmE7XFxudmVjMyBtYXhDb2xvclVucHJlbXVsdGlwbHkgPSBtYXhDb2xvci5yZ2IgLyBtYXhDb2xvci5hO1xcbnZlYzMgY29sb3JVbnByZW11bHRpcGx5ID0gY29sb3IucmdiIC8gY29sb3IuYTtcXG52ZWMzIHJhbmdlID0gbWF4Q29sb3JVbnByZW11bHRpcGx5IC0gbWluQ29sb3JVbnByZW11bHRpcGx5O1xcbmdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IuYSAqIChjb2xvclVucHJlbXVsdGlwbHkgLSBtaW5Db2xvclVucHJlbXVsdGlwbHkpIC8gcmFuZ2UsIGNvbG9yLmEpO1xcbn1cIixcIm1pbi1tYXhcIjp7XCJtaW4tbWF4LmZyYWdcIjpcIiNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmVcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIENFTExfU0laRSAyXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9taW5UZXh0dXJlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfbWF4VGV4dHVyZTtcXG51bmlmb3JtIHZlYzIgdV9zcmNSZXNvbHV0aW9uO1xcbnVuaWZvcm0gdmVjMiB1X2RzdFJlc29sdXRpb247XFxudmFyeWluZyB2ZWMyIHZfdXY7XFxudm9pZCBtYWluKCkge1xcbnZlYzIgc3JjUGl4ZWwgPSBmbG9vcihnbF9GcmFnQ29vcmQueHkpICogZmxvYXQoQ0VMTF9TSVpFKTtcXG52ZWMyIG9uZVBpeGVsID0gdmVjMigxLjApIC8gdV9zcmNSZXNvbHV0aW9uO1xcbnZlYzIgdXYgPSAoc3JjUGl4ZWwgKyAwLjUpIC8gdV9zcmNSZXNvbHV0aW9uO1xcbnZlYzQgbWluQ29sb3IgPSB2ZWM0KDEuMCk7XFxudmVjNCBtYXhDb2xvciA9IHZlYzQoMC4wKTtcXG5mb3IgKGludCB5ID0gMDsgeSA8IENFTExfU0laRTsgKyt5KSB7XFxuZm9yIChpbnQgeCA9IDA7IHggPCBDRUxMX1NJWkU7ICsreCkge1xcbnZlYzIgb2Zmc2V0ID0gdXYgKyB2ZWMyKHgsIHkpICogb25lUGl4ZWw7XFxubWluQ29sb3IgPSBtaW4obWluQ29sb3IsIHRleHR1cmUyRCh1X21pblRleHR1cmUsIG9mZnNldCkpO1xcbm1heENvbG9yID0gbWF4KG1heENvbG9yLCB0ZXh0dXJlMkQodV9tYXhUZXh0dXJlLCBvZmZzZXQpKTtcXG59XFxufVxcbmdsX0ZyYWdEYXRhWzBdID0gbWluQ29sb3I7XFxuZ2xfRnJhZ0RhdGFbMV0gPSBtYXhDb2xvcjtcXG59XCJ9fSxcImRyb3Atc2hhZG93XCI6e2NvbXBvc2l0ZTp7XCJjb21wb3NpdGUuZnJhZ1wiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9sYXllckZCT1RleHR1cmU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9ibHVyVGV4dHVyZTtcXG51bmlmb3JtIHZlYzQgdV9zaGFkb3dDb2xvcjtcXG51bmlmb3JtIHZlYzIgdV9zaGFkb3dPZmZzZXQ7XFxudW5pZm9ybSBoaWdocCBtYXQzIHVfZGlzcGxheVZpZXdNYXQzO1xcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbnZvaWQgbWFpbigpIHtcXG52ZWMzIG9mZnNldCA9IHVfZGlzcGxheVZpZXdNYXQzICogdmVjMyh1X3NoYWRvd09mZnNldCwgMC4wKTtcXG52ZWM0IGxheWVyQ29sb3IgPSB0ZXh0dXJlMkQodV9sYXllckZCT1RleHR1cmUsIHZfdXYpO1xcbnZlYzQgYmx1ckNvbG9yID0gdGV4dHVyZTJEKHVfYmx1clRleHR1cmUsIHZfdXYgLSBvZmZzZXQueHkgLyAyLjApO1xcbmdsX0ZyYWdDb2xvciA9ICgoMS4wIC0gbGF5ZXJDb2xvci5hKSAqIGJsdXJDb2xvci5hICogdV9zaGFkb3dDb2xvciArIGxheWVyQ29sb3IpO1xcbn1cIn19LFwiZWRnZS1kZXRlY3RcIjp7XCJmcmVpLWNoZW5cIjp7XCJmcmVpLWNoZW4uZnJhZ1wiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9jb2xvclRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVfdGV4U2l6ZTtcXG52YXJ5aW5nIHZlYzIgdl91djtcXG52ZWMyIHRleGVsID0gdmVjMigxLjAgLyB1X3RleFNpemUueCwgMS4wIC8gdV90ZXhTaXplLnkpO1xcbm1hdDMgR1s5XTtcXG5jb25zdCBtYXQzIGcwID0gbWF0MyggMC4zNTM1NTMzODQ1NDI0NjUyLCAwLCAtMC4zNTM1NTMzODQ1NDI0NjUyLCAwLjUsIDAsIC0wLjUsIDAuMzUzNTUzMzg0NTQyNDY1MiwgMCwgLTAuMzUzNTUzMzg0NTQyNDY1MiApO1xcbmNvbnN0IG1hdDMgZzEgPSBtYXQzKCAwLjM1MzU1MzM4NDU0MjQ2NTIsIDAuNSwgMC4zNTM1NTMzODQ1NDI0NjUyLCAwLCAwLCAwLCAtMC4zNTM1NTMzODQ1NDI0NjUyLCAtMC41LCAtMC4zNTM1NTMzODQ1NDI0NjUyICk7XFxuY29uc3QgbWF0MyBnMiA9IG1hdDMoIDAsIDAuMzUzNTUzMzg0NTQyNDY1MiwgLTAuNSwgLTAuMzUzNTUzMzg0NTQyNDY1MiwgMCwgMC4zNTM1NTMzODQ1NDI0NjUyLCAwLjUsIC0wLjM1MzU1MzM4NDU0MjQ2NTIsIDAgKTtcXG5jb25zdCBtYXQzIGczID0gbWF0MyggMC41LCAtMC4zNTM1NTMzODQ1NDI0NjUyLCAwLCAtMC4zNTM1NTMzODQ1NDI0NjUyLCAwLCAwLjM1MzU1MzM4NDU0MjQ2NTIsIDAsIDAuMzUzNTUzMzg0NTQyNDY1MiwgLTAuNSApO1xcbmNvbnN0IG1hdDMgZzQgPSBtYXQzKCAwLCAtMC41LCAwLCAwLjUsIDAsIDAuNSwgMCwgLTAuNSwgMCApO1xcbmNvbnN0IG1hdDMgZzUgPSBtYXQzKCAtMC41LCAwLCAwLjUsIDAsIDAsIDAsIDAuNSwgMCwgLTAuNSApO1xcbmNvbnN0IG1hdDMgZzYgPSBtYXQzKCAwLjE2NjY2NjY3MTYzMzcyMDQsIC0wLjMzMzMzMzM0MzI2NzQ0MDgsIDAuMTY2NjY2NjcxNjMzNzIwNCwgLTAuMzMzMzMzMzQzMjY3NDQwOCwgMC42NjY2NjY2ODY1MzQ4ODE2LCAtMC4zMzMzMzMzNDMyNjc0NDA4LCAwLjE2NjY2NjY3MTYzMzcyMDQsIC0wLjMzMzMzMzM0MzI2NzQ0MDgsIDAuMTY2NjY2NjcxNjMzNzIwNCApO1xcbmNvbnN0IG1hdDMgZzcgPSBtYXQzKCAtMC4zMzMzMzMzNDMyNjc0NDA4LCAwLjE2NjY2NjY3MTYzMzcyMDQsIC0wLjMzMzMzMzM0MzI2NzQ0MDgsIDAuMTY2NjY2NjcxNjMzNzIwNCwgMC42NjY2NjY2ODY1MzQ4ODE2LCAwLjE2NjY2NjY3MTYzMzcyMDQsIC0wLjMzMzMzMzM0MzI2NzQ0MDgsIDAuMTY2NjY2NjcxNjMzNzIwNCwgLTAuMzMzMzMzMzQzMjY3NDQwOCApO1xcbmNvbnN0IG1hdDMgZzggPSBtYXQzKCAwLjMzMzMzMzM0MzI2NzQ0MDgsIDAuMzMzMzMzMzQzMjY3NDQwOCwgMC4zMzMzMzMzNDMyNjc0NDA4LCAwLjMzMzMzMzM0MzI2NzQ0MDgsIDAuMzMzMzMzMzQzMjY3NDQwOCwgMC4zMzMzMzMzNDMyNjc0NDA4LCAwLjMzMzMzMzM0MzI2NzQ0MDgsIDAuMzMzMzMzMzQzMjY3NDQwOCwgMC4zMzMzMzMzNDMyNjc0NDA4ICk7XFxudm9pZCBtYWluKCkge1xcbkdbMF0gPSBnMCxcXG5HWzFdID0gZzEsXFxuR1syXSA9IGcyLFxcbkdbM10gPSBnMyxcXG5HWzRdID0gZzQsXFxuR1s1XSA9IGc1LFxcbkdbNl0gPSBnNixcXG5HWzddID0gZzcsXFxuR1s4XSA9IGc4O1xcbm1hdDMgSTtcXG5mbG9hdCBjbnZbOV07XFxudmVjMyBzYW1wbGU7XFxuZm9yIChmbG9hdCBpID0gMC4wOyBpIDwgMy4wOyBpKyspIHtcXG5mb3IgKGZsb2F0IGogPSAwLjA7IGogPCAzLjA7IGorKykge1xcbnNhbXBsZSA9IHRleHR1cmUyRCh1X2NvbG9yVGV4dHVyZSwgdl91diArIHRleGVsICogdmVjMihpIC0gMS4wLGogLSAxLjApKS5yZ2I7XFxuSVtpbnQoaSldW2ludChqKV0gPSBsZW5ndGgoc2FtcGxlKTtcXG59XFxufVxcbmZvciAoaW50IGkgPSAwOyBpIDwgOTsgaSsrKSB7XFxuZmxvYXQgZHAzID0gZG90KEdbaV1bMF0sIElbMF0pICsgZG90KEdbaV1bMV0sIElbMV0pICsgZG90KEdbaV1bMl0sIElbMl0pO1xcbmNudltpXSA9IGRwMyAqIGRwMztcXG59XFxuZmxvYXQgTSA9IChjbnZbMF0gKyBjbnZbMV0pICsgKGNudlsyXSArIGNudlszXSk7XFxuZmxvYXQgUyA9IChjbnZbNF0gKyBjbnZbNV0pICsgKGNudls2XSArIGNudls3XSkgKyAoY252WzhdICsgTSk7XFxuZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKHNxcnQoTSAvIFMpKSwgdGV4dHVyZTJEKHVfY29sb3JUZXh0dXJlLCB2X3V2KS5hKTtcXG59XCJ9LHNvYmVsOntcInNvYmVsLmZyYWdcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfY29sb3JUZXh0dXJlO1xcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbnVuaWZvcm0gdmVjMiB1X3RleFNpemU7XFxudmVjMiB0ZXhlbCA9IHZlYzIoMS4wIC8gdV90ZXhTaXplLngsIDEuMCAvIHVfdGV4U2l6ZS55KTtcXG5tYXQzIEdbMl07XFxuY29uc3QgbWF0MyBnMCA9IG1hdDMoIDEuMCwgMi4wLCAxLjAsIDAuMCwgMC4wLCAwLjAsIC0xLjAsIC0yLjAsIC0xLjAgKTtcXG5jb25zdCBtYXQzIGcxID0gbWF0MyggMS4wLCAwLjAsIC0xLjAsIDIuMCwgMC4wLCAtMi4wLCAxLjAsIDAuMCwgLTEuMCApO1xcbnZvaWQgbWFpbigpIHtcXG5tYXQzIEk7XFxuZmxvYXQgY252WzJdO1xcbnZlYzMgc2FtcGxlO1xcbkdbMF0gPSBnMDtcXG5HWzFdID0gZzE7XFxuZm9yIChmbG9hdCBpID0gMC4wOyBpIDwgMy4wOyBpKyspIHtcXG5mb3IgKGZsb2F0IGogPSAwLjA7IGogPCAzLjA7IGorKykge1xcbnNhbXBsZSA9IHRleHR1cmUyRCggdV9jb2xvclRleHR1cmUsIHZfdXYgKyB0ZXhlbCAqIHZlYzIoaS0xLjAsai0xLjApICkucmdiO1xcbklbaW50KGkpXVtpbnQoaildID0gbGVuZ3RoKHNhbXBsZSk7XFxufVxcbn1cXG5mb3IgKGludCBpID0gMDsgaSA8IDI7IGkrKykge1xcbmZsb2F0IGRwMyA9IGRvdChHW2ldWzBdLCBJWzBdKSArIGRvdChHW2ldWzFdLCBJWzFdKSArIGRvdChHW2ldWzJdLCBJWzJdKTtcXG5jbnZbaV0gPSBkcDMgKiBkcDM7XFxufVxcbmdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMygwLjUgKiBzcXJ0KGNudlswXSAqIGNudlswXSArIGNudlsxXSAqIGNudlsxXSkpLCB0ZXh0dXJlMkQodV9jb2xvclRleHR1cmUsIHZfdXYpLmEpO1xcbn1cIn19LFwiZWRnZS1lbmhhbmNlXCI6e1wiZWRnZS1lbmhhbmNlLmZyYWdcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfY29sb3JUZXh0dXJlO1xcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbnVuaWZvcm0gdmVjMiB1X3RleFNpemU7XFxudmVjMiB0ZXhlbCA9IHZlYzIoMS4wIC8gdV90ZXhTaXplLngsIDEuMCAvIHVfdGV4U2l6ZS55KTtcXG5tYXQzIEdbMl07XFxuY29uc3QgbWF0MyBnMCA9IG1hdDMoIDEuMCwgMC4wLCAtMS4wLCAxLjAsIDAuMCwgLTEuMCwgMS4wLCAwLjAsIC0xLjAgKTtcXG5jb25zdCBtYXQzIGcxID0gbWF0MyggMS4wLCAxLjAsIDEuMCwgMC4wLCAwLjAsIDAuMCwgLTEuMCwgLTEuMCwgLTEuMCApO1xcbnZvaWQgbWFpbigpIHtcXG5tYXQzIEk7XFxuZmxvYXQgY252WzJdO1xcbnZlYzMgc2FtcGxlO1xcbkdbMF0gPSBnMDtcXG5HWzFdID0gZzE7XFxuZm9yIChmbG9hdCBpID0gMC4wOyBpIDwgMy4wOyBpKyspIHtcXG5mb3IgKGZsb2F0IGogPSAwLjA7IGogPCAzLjA7IGorKykge1xcbnNhbXBsZSA9IHRleHR1cmUyRCggdV9jb2xvclRleHR1cmUsIHZfdXYgKyB0ZXhlbCAqIHZlYzIoaS0xLjAsai0xLjApICkucmdiO1xcbklbaW50KGkpXVtpbnQoaildID0gbGVuZ3RoKHNhbXBsZSk7XFxufVxcbn1cXG5mb3IgKGludCBpID0gMDsgaSA8IDI7IGkrKykge1xcbmZsb2F0IGRwMyA9IGRvdChHW2ldWzBdLCBJWzBdKSArIGRvdChHW2ldWzFdLCBJWzFdKSArIGRvdChHW2ldWzJdLCBJWzJdKTtcXG5jbnZbaV0gPSBkcDMgKiBkcDM7XFxufVxcbnZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV9jb2xvclRleHR1cmUsIHZfdXYpO1xcbmdsX0ZyYWdDb2xvciA9IHZlYzQoMC41ICogc3FydChjbnZbMF0gKiBjbnZbMF0gKyBjbnZbMV0gKiBjbnZbMV0pICogY29sb3IpO1xcbn1cIn0sZmlsdGVyRWZmZWN0OntcImZpbHRlckVmZmVjdC5mcmFnXCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2NvbG9yVGV4dHVyZTtcXG51bmlmb3JtIG1hdDQgdV9jb2VmZmljaWVudHM7XFxudmFyeWluZyB2ZWMyIHZfdXY7XFxudm9pZCBtYWluKCkge1xcbnZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV9jb2xvclRleHR1cmUsIHZfdXYpO1xcbnZlYzQgcmdidyA9IHVfY29lZmZpY2llbnRzICogdmVjNChjb2xvci5hID4gMC4wID8gY29sb3IucmdiIC8gY29sb3IuYSA6IHZlYzMoMC4wKSwgMS4wKTtcXG5mbG9hdCBhID0gY29sb3IuYTtcXG5nbF9GcmFnQ29sb3IgPSB2ZWM0KGEgKiByZ2J3LnJnYiwgYSk7XFxufVwifSxwcDp7XCJwcC52ZXJ0XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbnZvaWQgbWFpbigpIHtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMC4wLCAxLjApO1xcbnZfdXYgPSAoYV9wb3NpdGlvbiArIDEuMCkgLyAyLjA7XFxufVwifX0scmFzdGVyOntjb21tb246e1wiY29tbW9uLmdsc2xcIjpcInVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBpbnQgdV9iYW5kQ291bnQ7XFxudW5pZm9ybSBib29sIHVfZmxpcFk7XFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XFxudW5pZm9ybSBpbnQgdV9yZXNhbXBsaW5nO1xcbnVuaWZvcm0gdmVjMiB1X3NyY0ltYWdlU2l6ZTtcXG4jaWZkZWYgQVBQTFlfUFJPSkVDVElPTlxcbiNpbmNsdWRlIDxyYXN0ZXIvY29tbW9uL3Byb2plY3Rpb24uZ2xzbD5cXG4jZW5kaWZcXG4jaWZkZWYgQklDVUJJQ1xcbiNpbmNsdWRlIDxmaWx0ZXJpbmcvYmljdWJpYy5nbHNsPlxcbiNlbmRpZlxcbiNpZmRlZiBCSUxJTkVBUlxcbiNpbmNsdWRlIDxmaWx0ZXJpbmcvYmlsaW5lYXIuZ2xzbD5cXG4jZW5kaWZcXG52ZWMyIGdldFBpeGVsTG9jYXRpb24odmVjMiBjb29yZHMpIHtcXG52ZWMyIHRhcmdldExvY2F0aW9uID0gdV9mbGlwWSA/IHZlYzIoY29vcmRzLnMsIDEuMCAtIGNvb3Jkcy50KSA6IGNvb3JkcztcXG4jaWZkZWYgQVBQTFlfUFJPSkVDVElPTlxcbnRhcmdldExvY2F0aW9uID0gcHJvamVjdFBpeGVsTG9jYXRpb24odGFyZ2V0TG9jYXRpb24pO1xcbiNlbmRpZlxcbnJldHVybiB0YXJnZXRMb2NhdGlvbjtcXG59XFxuYm9vbCBpc091dHNpZGUodmVjMiBjb29yZHMpe1xcbmlmIChjb29yZHMudD4xLjAwMDAxIHx8Y29vcmRzLnQ8LTAuMDAwMDEgfHwgY29vcmRzLnM+MS4wMDAwMSB8fGNvb3Jkcy5zPC0wLjAwMDAxKSB7XFxucmV0dXJuIHRydWU7XFxufSBlbHNlIHtcXG5yZXR1cm4gZmFsc2U7XFxufVxcbn1cXG52ZWM0IGdldFBpeGVsKHZlYzIgcGl4ZWxMb2NhdGlvbikge1xcbiNpZmRlZiBCSUNVQklDXFxudmVjNCBjb2xvciA9IHNhbXBsZUJpY3ViaWNCU3BsaW5lKHVfaW1hZ2UsIHBpeGVsTG9jYXRpb24sIHVfc3JjSW1hZ2VTaXplKTtcXG4jZWxpZiBkZWZpbmVkKEJJTElORUFSKVxcbnZlYzQgY29sb3IgPSBzYW1wbGVCaWxpbmVhcih1X2ltYWdlLCBwaXhlbExvY2F0aW9uLCB1X3NyY0ltYWdlU2l6ZSk7XFxuI2Vsc2VcXG52ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHBpeGVsTG9jYXRpb24pO1xcbiNlbmRpZlxcbnJldHVybiBjb2xvcjtcXG59XCIsXCJwcm9qZWN0aW9uLmdsc2xcIjpcInVuaWZvcm0gc2FtcGxlcjJEIHVfdHJhbnNmb3JtR3JpZDtcXG51bmlmb3JtIHZlYzIgdV90cmFuc2Zvcm1TcGFjaW5nO1xcbnVuaWZvcm0gdmVjMiB1X3RyYW5zZm9ybUdyaWRTaXplO1xcbnVuaWZvcm0gdmVjMiB1X3RhcmdldEltYWdlU2l6ZTtcXG52ZWMyIHByb2plY3RQaXhlbExvY2F0aW9uKHZlYzIgY29vcmRzKSB7XFxuI2lmZGVmIExPT0tVUF9QUk9KRUNUSU9OXFxudmVjNCBwdiA9IHRleHR1cmUyRCh1X3RyYW5zZm9ybUdyaWQsIGNvb3Jkcyk7XFxucmV0dXJuIHZlYzIocHYuciwgcHYuZyk7XFxuI2VuZGlmXFxudmVjMiBpbmRleF9pbWFnZSA9IGZsb29yKGNvb3JkcyAqIHVfdGFyZ2V0SW1hZ2VTaXplKTtcXG52ZWMyIG9uZVRyYW5zZm9ybVBpeGVsID0gdmVjMigwLjI1IC8gdV90cmFuc2Zvcm1HcmlkU2l6ZS5zLCAxLjAgLyB1X3RyYW5zZm9ybUdyaWRTaXplLnQpO1xcbnZlYzIgaW5kZXhfdHJhbnNmb3JtID0gZmxvb3IoaW5kZXhfaW1hZ2UgLyB1X3RyYW5zZm9ybVNwYWNpbmcpIC8gdV90cmFuc2Zvcm1HcmlkU2l6ZTtcXG52ZWMyIHBvcyA9IGZyYWN0KChpbmRleF9pbWFnZSArIHZlYzIoMC41LCAwLjUpKSAvIHVfdHJhbnNmb3JtU3BhY2luZyk7XFxudmVjMiBzcmNMb2NhdGlvbjtcXG52ZWMyIHRyYW5zZm9ybV9sb2NhdGlvbiA9IGluZGV4X3RyYW5zZm9ybSArIG9uZVRyYW5zZm9ybVBpeGVsICogMC41O1xcbmlmIChwb3MucyA8PSBwb3MudCkge1xcbnZlYzQgbGxfYWJjID0gdGV4dHVyZTJEKHVfdHJhbnNmb3JtR3JpZCwgdmVjMih0cmFuc2Zvcm1fbG9jYXRpb24ucywgdHJhbnNmb3JtX2xvY2F0aW9uLnQpKTtcXG52ZWM0IGxsX2RlZiA9IHRleHR1cmUyRCh1X3RyYW5zZm9ybUdyaWQsIHZlYzIodHJhbnNmb3JtX2xvY2F0aW9uLnMgKyBvbmVUcmFuc2Zvcm1QaXhlbC5zLCB0cmFuc2Zvcm1fbG9jYXRpb24udCkpO1xcbnNyY0xvY2F0aW9uLnMgPSBkb3QobGxfYWJjLnJnYiwgdmVjMyhwb3MsIDEuMCkpO1xcbnNyY0xvY2F0aW9uLnQgPSBkb3QobGxfZGVmLnJnYiwgdmVjMyhwb3MsIDEuMCkpO1xcbn0gZWxzZSB7XFxudmVjNCB1cl9hYmMgPSB0ZXh0dXJlMkQodV90cmFuc2Zvcm1HcmlkLCB2ZWMyKHRyYW5zZm9ybV9sb2NhdGlvbi5zICsgMi4wICogb25lVHJhbnNmb3JtUGl4ZWwucywgdHJhbnNmb3JtX2xvY2F0aW9uLnQpKTtcXG52ZWM0IHVyX2RlZiA9IHRleHR1cmUyRCh1X3RyYW5zZm9ybUdyaWQsIHZlYzIodHJhbnNmb3JtX2xvY2F0aW9uLnMgKyAzLjAgKiBvbmVUcmFuc2Zvcm1QaXhlbC5zLCB0cmFuc2Zvcm1fbG9jYXRpb24udCkpO1xcbnNyY0xvY2F0aW9uLnMgPSBkb3QodXJfYWJjLnJnYiwgdmVjMyhwb3MsIDEuMCkpO1xcbnNyY0xvY2F0aW9uLnQgPSBkb3QodXJfZGVmLnJnYiwgdmVjMyhwb3MsIDEuMCkpO1xcbn1cXG5yZXR1cm4gc3JjTG9jYXRpb247XFxufVwifSxmbG93OntcImdldEZhZGVPcGFjaXR5Lmdsc2xcIjpcInVuaWZvcm0gZmxvYXQgdV9kZWNheVJhdGU7XFxudW5pZm9ybSBmbG9hdCB1X2ZhZGVUb1plcm87XFxuZmxvYXQgZ2V0RmFkZU9wYWNpdHkoZmxvYXQgeCkge1xcbmZsb2F0IGN1dE9mZiA9IG1peCgwLjAsIGV4cCgtdV9kZWNheVJhdGUpLCB1X2ZhZGVUb1plcm8pO1xcbnJldHVybiAoZXhwKC11X2RlY2F5UmF0ZSAqIHgpIC0gY3V0T2ZmKSAvICgxLjAgLSBjdXRPZmYpO1xcbn1cIixcImdldEZyYWdtZW50Q29sb3IuZ2xzbFwiOlwidmVjNCBnZXRGcmFnbWVudENvbG9yKHZlYzQgY29sb3IsIGZsb2F0IGRpc3QsIGZsb2F0IHNpemUsIGZsb2F0IGZlYXRoZXJpbmdTaXplKSB7XFxuZmxvYXQgZmVhdGhlcmluZ1N0YXJ0ID0gY2xhbXAoMC41IC0gZmVhdGhlcmluZ1NpemUgLyBzaXplLCAwLjAsIDAuNSk7XFxuaWYgKGRpc3QgPiBmZWF0aGVyaW5nU3RhcnQpIHtcXG5jb2xvciAqPSAxLjAgLSAoZGlzdCAtIGZlYXRoZXJpbmdTdGFydCkgLyAoMC41IC0gZmVhdGhlcmluZ1N0YXJ0KTtcXG59XFxucmV0dXJuIGNvbG9yO1xcbn1cIixpbWFnZXJ5OntcImltYWdlcnkuZnJhZ1wiOlwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG51bmlmb3JtIGZsb2F0IHVfTWluO1xcbnVuaWZvcm0gZmxvYXQgdV9NYXg7XFxudW5pZm9ybSBmbG9hdCB1X2ZlYXRoZXJpbmdTaXplO1xcbiNpbmNsdWRlIDxyYXN0ZXIvZmxvdy92di5nbHNsPlxcbmZsb2F0IGdldEludGVuc2l0eShmbG9hdCB2KSB7XFxucmV0dXJuIHVfTWluICsgdiAqICh1X01heCAtIHVfTWluKTtcXG59XFxudm9pZCBtYWluKHZvaWQpIHtcXG52ZWM0IHNhbXBsZWQgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3RleGNvb3JkKTtcXG5mbG9hdCBpbnRlbnNpdHkgPSBnZXRJbnRlbnNpdHkoc2FtcGxlZC5yKTtcXG5nbF9GcmFnQ29sb3IgPSBnZXRDb2xvcihpbnRlbnNpdHkpO1xcbmdsX0ZyYWdDb2xvci5hICo9IGdldE9wYWNpdHkoc2FtcGxlZC5yKTtcXG5nbF9GcmFnQ29sb3IuYSAqPSBzYW1wbGVkLmE7XFxuZ2xfRnJhZ0NvbG9yLnJnYiAqPSBnbF9GcmFnQ29sb3IuYTtcXG59XCIsXCJpbWFnZXJ5LnZlcnRcIjpcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhjb29yZDtcXG51bmlmb3JtIG1hdDMgdV9kdnNNYXQzO1xcbnZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xcbnZvaWQgbWFpbih2b2lkKSB7XFxudmVjMiB4eSA9ICh1X2R2c01hdDMgKiB2ZWMzKGFfcG9zaXRpb24sIDEuMCkpLnh5O1xcbmdsX1Bvc2l0aW9uID0gdmVjNCh4eSwgMC4wLCAxLjApO1xcbnZfdGV4Y29vcmQgPSBhX3RleGNvb3JkO1xcbn1cIn0scGFydGljbGVzOntcInBhcnRpY2xlcy5mcmFnXCI6XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxudmFyeWluZyBmbG9hdCB2X3NpemU7XFxudW5pZm9ybSBmbG9hdCB1X2ZlYXRoZXJpbmdTaXplO1xcbiNpbmNsdWRlIDxyYXN0ZXIvZmxvdy9nZXRGcmFnbWVudENvbG9yLmdsc2w+XFxudm9pZCBtYWluKHZvaWQpIHtcXG5nbF9GcmFnQ29sb3IgPSBnZXRGcmFnbWVudENvbG9yKHZfY29sb3IsIGxlbmd0aCh2X3RleGNvb3JkIC0gMC41KSwgdl9zaXplLCB1X2ZlYXRoZXJpbmdTaXplKTtcXG59XCIsXCJwYXJ0aWNsZXMudmVydFwiOlwiYXR0cmlidXRlIHZlYzQgYV94eXRzMDtcXG5hdHRyaWJ1dGUgdmVjNCBhX3h5dHMxO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfdHlwZUlkRHVyYXRpb25TZWVkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfZXh0cnVkZUluZm87XFxudW5pZm9ybSBtYXQzIHVfZHZzTWF0MztcXG51bmlmb3JtIG1hdDMgdV9kaXNwbGF5Vmlld01hdDM7XFxudW5pZm9ybSBmbG9hdCB1X3RpbWU7XFxudW5pZm9ybSBmbG9hdCB1X3RyYWlsTGVuZ3RoO1xcbnVuaWZvcm0gZmxvYXQgdV9mbG93U3BlZWQ7XFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxudmFyeWluZyBmbG9hdCB2X3NpemU7XFxudW5pZm9ybSBmbG9hdCB1X2ZlYXRoZXJpbmdTaXplO1xcbnVuaWZvcm0gZmxvYXQgdV9pbnRyb0ZhZGU7XFxuI2luY2x1ZGUgPHJhc3Rlci9mbG93L3Z2Lmdsc2w+XFxuI2luY2x1ZGUgPHJhc3Rlci9mbG93L2dldEZhZGVPcGFjaXR5Lmdsc2w+XFxudm9pZCBtYWluKHZvaWQpIHtcXG52ZWMyIHBvc2l0aW9uMCA9IGFfeHl0czAueHk7XFxuZmxvYXQgdDAgPSBhX3h5dHMwLno7XFxuZmxvYXQgc3BlZWQwID0gYV94eXRzMC53O1xcbnZlYzIgcG9zaXRpb24xID0gYV94eXRzMS54eTtcXG5mbG9hdCB0MSA9IGFfeHl0czEuejtcXG5mbG9hdCBzcGVlZDEgPSBhX3h5dHMxLnc7XFxuZmxvYXQgdHlwZSA9IGFfdHlwZUlkRHVyYXRpb25TZWVkLng7XFxuZmxvYXQgaWQgPSBhX3R5cGVJZER1cmF0aW9uU2VlZC55O1xcbmZsb2F0IGR1cmF0aW9uID0gYV90eXBlSWREdXJhdGlvblNlZWQuejtcXG5mbG9hdCBzZWVkID0gYV90eXBlSWREdXJhdGlvblNlZWQudztcXG52ZWMyIGUwID0gYV9leHRydWRlSW5mby54eTtcXG52ZWMyIGUxID0gYV9leHRydWRlSW5mby56dztcXG5mbG9hdCBhbmltYXRpb25QZXJpb2QgPSBkdXJhdGlvbiArIHVfdHJhaWxMZW5ndGg7XFxuZmxvYXQgc2NhbGVkVGltZSA9IHVfdGltZSAqIHVfZmxvd1NwZWVkO1xcbmZsb2F0IHJhbmRvbWl6ZWRUaW1lID0gc2NhbGVkVGltZSArIHNlZWQgKiBhbmltYXRpb25QZXJpb2Q7XFxuZmxvYXQgdCA9IG1vZChyYW5kb21pemVkVGltZSwgYW5pbWF0aW9uUGVyaW9kKTtcXG5mbG9hdCBmVW5jbGFtcGVkID0gKHQgLSB0MCkgLyAodDEgLSB0MCk7XFxuZmxvYXQgZiA9IGNsYW1wKGZVbmNsYW1wZWQsIDAuMCwgMS4wKTtcXG5mbG9hdCBjbGFtcGVkVGltZSA9IG1peCh0MCwgdDEsIGYpO1xcbmZsb2F0IHNwZWVkID0gbWl4KHNwZWVkMCwgc3BlZWQxLCBmKTtcXG52ZWMyIGV4dHJ1ZGU7XFxudmVjMiBwb3NpdGlvbjtcXG5mbG9hdCBmYWRlT3BhY2l0eTtcXG5mbG9hdCBpbnRyb09wYWNpdHk7XFxuaWYgKHR5cGUgPT0gMi4wKSB7XFxuaWYgKGZVbmNsYW1wZWQgPCAwLjAgfHwgKGZVbmNsYW1wZWQgPiAxLjAgJiYgdDEgIT0gZHVyYXRpb24pKSB7XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KDAuMCwgMC4wLCAtMi4wLCAxLjApO1xcbnJldHVybjtcXG59XFxudmVjMiBvcnRobyA9IG1peChlMCwgZTEsIGYpO1xcbnZlYzIgcGFyYWxsZWw7XFxucGFyYWxsZWwgPSBub3JtYWxpemUocG9zaXRpb24xIC0gcG9zaXRpb24wKSAqIDAuNTtcXG5pZiAoaWQgPT0gMS4wKSB7XFxuZXh0cnVkZSA9IG9ydGhvO1xcbnZfdGV4Y29vcmQgPSB2ZWMyKDAuNSwgMC4wKTtcXG59IGVsc2UgaWYgKGlkID09IDIuMCkge1xcbmV4dHJ1ZGUgPSAtb3J0aG87XFxudl90ZXhjb29yZCA9IHZlYzIoMC41LCAxLjApO1xcbn0gZWxzZSBpZiAoaWQgPT0gMy4wKSB7XFxuZXh0cnVkZSA9IG9ydGhvICsgcGFyYWxsZWw7XFxudl90ZXhjb29yZCA9IHZlYzIoMS4wLCAwLjApO1xcbn0gZWxzZSBpZiAoaWQgPT0gNC4wKSB7XFxuZXh0cnVkZSA9IC1vcnRobyArIHBhcmFsbGVsO1xcbnZfdGV4Y29vcmQgPSB2ZWMyKDEuMCwgMS4wKTtcXG59XFxuZmFkZU9wYWNpdHkgPSBnZXRGYWRlT3BhY2l0eSgodCAtIGNsYW1wZWRUaW1lKSAvIHVfdHJhaWxMZW5ndGgpO1xcbmludHJvT3BhY2l0eSA9IDEuMCAtIGV4cCgtY2xhbXBlZFRpbWUpO1xcbnZfc2l6ZSA9IGdldFNpemUoc3BlZWQpO1xcbnZfY29sb3IgPSBnZXRDb2xvcihzcGVlZCk7XFxudl9jb2xvci5hICo9IGdldE9wYWNpdHkoc3BlZWQpO1xcbnBvc2l0aW9uID0gbWl4KHBvc2l0aW9uMCwgcG9zaXRpb24xLCBmKTtcXG59IGVsc2Uge1xcbmlmIChmVW5jbGFtcGVkIDwgMC4wKSB7XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KDAuMCwgMC4wLCAtMi4wLCAxLjApO1xcbnJldHVybjtcXG59XFxuaWYgKGlkID09IDEuMCkge1xcbmV4dHJ1ZGUgPSBlMDtcXG52X3RleGNvb3JkID0gdmVjMigwLjUsIDAuMCk7XFxuZmFkZU9wYWNpdHkgPSBnZXRGYWRlT3BhY2l0eSgodCAtIHQwKSAvIHVfdHJhaWxMZW5ndGgpO1xcbmludHJvT3BhY2l0eSA9IDEuMCAtIGV4cCgtdDApO1xcbnZfc2l6ZSA9IGdldFNpemUoc3BlZWQwKTtcXG52X2NvbG9yID0gZ2V0Q29sb3Ioc3BlZWQwKTtcXG52X2NvbG9yLmEgKj0gZ2V0T3BhY2l0eShzcGVlZDApO1xcbnBvc2l0aW9uID0gcG9zaXRpb24wO1xcbn0gZWxzZSBpZiAoaWQgPT0gMi4wKSB7XFxuZXh0cnVkZSA9IC1lMDtcXG52X3RleGNvb3JkID0gdmVjMigwLjUsIDEuMCk7XFxuZmFkZU9wYWNpdHkgPSBnZXRGYWRlT3BhY2l0eSgodCAtIHQwKSAvIHVfdHJhaWxMZW5ndGgpO1xcbmludHJvT3BhY2l0eSA9IDEuMCAtIGV4cCgtdDApO1xcbnZfc2l6ZSA9IGdldFNpemUoc3BlZWQwKTtcXG52X2NvbG9yID0gZ2V0Q29sb3Ioc3BlZWQwKTtcXG52X2NvbG9yLmEgKj0gZ2V0T3BhY2l0eShzcGVlZDApO1xcbnBvc2l0aW9uID0gcG9zaXRpb24wO1xcbn0gZWxzZSBpZiAoaWQgPT0gMy4wKSB7XFxuZXh0cnVkZSA9IG1peChlMCwgZTEsIGYpO1xcbnZfdGV4Y29vcmQgPSB2ZWMyKDAuNSwgMC4wKTtcXG5mYWRlT3BhY2l0eSA9IGdldEZhZGVPcGFjaXR5KCh0IC0gY2xhbXBlZFRpbWUpIC8gdV90cmFpbExlbmd0aCk7XFxuaW50cm9PcGFjaXR5ID0gMS4wIC0gZXhwKC1jbGFtcGVkVGltZSk7XFxudl9zaXplID0gZ2V0U2l6ZShzcGVlZCk7XFxudl9jb2xvciA9IGdldENvbG9yKHNwZWVkKTtcXG52X2NvbG9yLmEgKj0gZ2V0T3BhY2l0eShzcGVlZCk7XFxucG9zaXRpb24gPSBtaXgocG9zaXRpb24wLCBwb3NpdGlvbjEsIGYpO1xcbn0gZWxzZSBpZiAoaWQgPT0gNC4wKSB7XFxuZXh0cnVkZSA9IC1taXgoZTAsIGUxLCBmKTtcXG52X3RleGNvb3JkID0gdmVjMigwLjUsIDEuMCk7XFxuZmFkZU9wYWNpdHkgPSBnZXRGYWRlT3BhY2l0eSgodCAtIGNsYW1wZWRUaW1lKSAvIHVfdHJhaWxMZW5ndGgpO1xcbmludHJvT3BhY2l0eSA9IDEuMCAtIGV4cCgtY2xhbXBlZFRpbWUpO1xcbnZfc2l6ZSA9IGdldFNpemUoc3BlZWQpO1xcbnZfY29sb3IgPSBnZXRDb2xvcihzcGVlZCk7XFxudl9jb2xvci5hICo9IGdldE9wYWNpdHkoc3BlZWQpO1xcbnBvc2l0aW9uID0gbWl4KHBvc2l0aW9uMCwgcG9zaXRpb24xLCBmKTtcXG59XFxufVxcbnZlYzIgeHkgPSAodV9kdnNNYXQzICogdmVjMyhwb3NpdGlvbiwgMS4wKSArIHVfZGlzcGxheVZpZXdNYXQzICogdmVjMyhleHRydWRlICogdl9zaXplLCAwLjApKS54eTtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQoeHksIDAuMCwgMS4wKTtcXG52X2NvbG9yLmEgKj0gZmFkZU9wYWNpdHk7XFxudl9jb2xvci5hICo9IG1peCgxLjAsIGludHJvT3BhY2l0eSwgdV9pbnRyb0ZhZGUpO1xcbnZfY29sb3IucmdiICo9IHZfY29sb3IuYTtcXG59XCJ9LHN0cmVhbWxpbmVzOntcInN0cmVhbWxpbmVzLmZyYWdcIjpcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG52YXJ5aW5nIGZsb2F0IHZfc2lkZTtcXG52YXJ5aW5nIGZsb2F0IHZfdGltZTtcXG52YXJ5aW5nIGZsb2F0IHZfdG90YWxUaW1lO1xcbnZhcnlpbmcgZmxvYXQgdl90aW1lU2VlZDtcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIGZsb2F0IHZfc2l6ZTtcXG51bmlmb3JtIGZsb2F0IHVfdGltZTtcXG51bmlmb3JtIGZsb2F0IHVfdHJhaWxMZW5ndGg7XFxudW5pZm9ybSBmbG9hdCB1X2Zsb3dTcGVlZDtcXG51bmlmb3JtIGZsb2F0IHVfZmVhdGhlcmluZ1NpemU7XFxudW5pZm9ybSBmbG9hdCB1X2ludHJvRmFkZTtcXG4jaW5jbHVkZSA8cmFzdGVyL2Zsb3cvZ2V0RnJhZ21lbnRDb2xvci5nbHNsPlxcbiNpbmNsdWRlIDxyYXN0ZXIvZmxvdy9nZXRGYWRlT3BhY2l0eS5nbHNsPlxcbnZvaWQgbWFpbih2b2lkKSB7XFxuZmxvYXQgdCA9IG1vZCh2X3RpbWVTZWVkICogKHZfdG90YWxUaW1lICsgdV90cmFpbExlbmd0aCkgKyB1X3RpbWUgKiB1X2Zsb3dTcGVlZCwgdl90b3RhbFRpbWUgKyB1X3RyYWlsTGVuZ3RoKSAtIHZfdGltZTtcXG52ZWM0IGNvbG9yID0gdl9jb2xvciAqIHN0ZXAoMC4wLCB0KSAqIGdldEZhZGVPcGFjaXR5KHQgLyB1X3RyYWlsTGVuZ3RoKTtcXG5jb2xvciAqPSBtaXgoMS4wLCAxLjAgLSBleHAoLXZfdGltZSksIHVfaW50cm9GYWRlKTtcXG5nbF9GcmFnQ29sb3IgPSBnZXRGcmFnbWVudENvbG9yKGNvbG9yLCBsZW5ndGgoKHZfc2lkZSArIDEuMCkgLyAyLjAgLSAwLjUpLCB2X3NpemUsIHVfZmVhdGhlcmluZ1NpemUpO1xcbn1cIixcInN0cmVhbWxpbmVzLnZlcnRcIjpcImF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb25BbmRTaWRlO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfdGltZUluZm87XFxuYXR0cmlidXRlIHZlYzIgYV9leHRydWRlO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3NwZWVkO1xcbnVuaWZvcm0gbWF0MyB1X2R2c01hdDM7XFxudW5pZm9ybSBtYXQzIHVfZGlzcGxheVZpZXdNYXQzO1xcbnZhcnlpbmcgZmxvYXQgdl90aW1lO1xcbnZhcnlpbmcgZmxvYXQgdl90b3RhbFRpbWU7XFxudmFyeWluZyBmbG9hdCB2X3RpbWVTZWVkO1xcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9zaWRlO1xcbnZhcnlpbmcgZmxvYXQgdl9zaXplO1xcbnVuaWZvcm0gZmxvYXQgdV9mZWF0aGVyaW5nU2l6ZTtcXG4jaW5jbHVkZSA8cmFzdGVyL2Zsb3cvdnYuZ2xzbD5cXG52b2lkIG1haW4odm9pZCkge1xcbnZlYzQgbGluZUNvbG9yID0gZ2V0Q29sb3IoYV9zcGVlZCk7XFxuZmxvYXQgbGluZU9wYWNpdHkgPSBnZXRPcGFjaXR5KGFfc3BlZWQpO1xcbmZsb2F0IGxpbmVTaXplID0gZ2V0U2l6ZShhX3NwZWVkKTtcXG52ZWMyIHBvc2l0aW9uID0gYV9wb3NpdGlvbkFuZFNpZGUueHk7XFxudl9zaWRlID0gYV9wb3NpdGlvbkFuZFNpZGUuejtcXG52ZWMyIHh5ID0gKHVfZHZzTWF0MyAqIHZlYzMocG9zaXRpb24sIDEuMCkgKyB1X2Rpc3BsYXlWaWV3TWF0MyAqIHZlYzMoYV9leHRydWRlICogbGluZVNpemUsIDAuMCkpLnh5O1xcbmdsX1Bvc2l0aW9uID0gdmVjNCh4eSwgMC4wLCAxLjApO1xcbnZfdGltZSA9IGFfdGltZUluZm8ueDtcXG52X3RvdGFsVGltZSA9IGFfdGltZUluZm8ueTtcXG52X3RpbWVTZWVkID0gYV90aW1lSW5mby56O1xcbnZfY29sb3IgPSBsaW5lQ29sb3I7XFxudl9jb2xvci5hICo9IGxpbmVPcGFjaXR5O1xcbnZfY29sb3IucmdiICo9IHZfY29sb3IuYTtcXG52X3NpemUgPSBsaW5lU2l6ZTtcXG59XCJ9LFwidnYuZ2xzbFwiOlwiI2RlZmluZSBNQVhfU1RPUFMgOFxcbiNpZmRlZiBWVl9DT0xPUlxcbnVuaWZvcm0gZmxvYXQgdV9jb2xvcl9zdG9wc1tNQVhfU1RPUFNdO1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yX3ZhbHVlc1tNQVhfU1RPUFNdO1xcbnVuaWZvcm0gaW50IHVfY29sb3JfY291bnQ7XFxuI2Vsc2VcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG4jZW5kaWZcXG4jaWZkZWYgVlZfT1BBQ0lUWVxcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5X3N0b3BzW01BWF9TVE9QU107XFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHlfdmFsdWVzW01BWF9TVE9QU107XFxudW5pZm9ybSBpbnQgdV9vcGFjaXR5X2NvdW50O1xcbiNlbHNlXFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XFxuI2VuZGlmXFxuI2lmZGVmIFZWX1NJWkVcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZV9zdG9wc1tNQVhfU1RPUFNdO1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplX3ZhbHVlc1tNQVhfU1RPUFNdO1xcbnVuaWZvcm0gaW50IHVfc2l6ZV9jb3VudDtcXG4jZWxzZVxcbnVuaWZvcm0gZmxvYXQgdV9zaXplO1xcbiNlbmRpZlxcbnVuaWZvcm0gZmxvYXQgdV9mZWF0aGVyaW5nT2Zmc2V0O1xcbnZlYzQgZ2V0Q29sb3IoZmxvYXQgeCkge1xcbiNpZmRlZiBWVl9DT0xPUlxcbnZlYzQgY29sb3IgPSB1X2NvbG9yX3ZhbHVlc1swXTtcXG57XFxuZm9yIChpbnQgaSA9IDE7IGkgPCBNQVhfU1RPUFM7IGkrKykge1xcbmlmIChpID49IHVfY29sb3JfY291bnQpIHtcXG5icmVhaztcXG59XFxuZmxvYXQgeDEgPSB1X2NvbG9yX3N0b3BzW2kgLSAxXTtcXG5pZiAoeCA8IHgxKSB7XFxuYnJlYWs7XFxufVxcbmZsb2F0IHgyID0gdV9jb2xvcl9zdG9wc1tpXTtcXG52ZWM0IHkyID0gdV9jb2xvcl92YWx1ZXNbaV07XFxuaWYgKHggPCB4Mikge1xcbnZlYzQgeTEgPSB1X2NvbG9yX3ZhbHVlc1tpIC0gMV07XFxuY29sb3IgPSB5MSArICh5MiAtIHkxKSAqICh4IC0geDEpIC8gKHgyIC0geDEpO1xcbn0gZWxzZSB7XFxuY29sb3IgPSB5MjtcXG59XFxufVxcbn1cXG4jZWxzZVxcbnZlYzQgY29sb3IgPSB1X2NvbG9yO1xcbiNlbmRpZlxcbnJldHVybiBjb2xvcjtcXG59XFxuZmxvYXQgZ2V0T3BhY2l0eShmbG9hdCB4KSB7XFxuI2lmZGVmIFZWX09QQUNJVFlcXG5mbG9hdCBvcGFjaXR5ID0gdV9vcGFjaXR5X3ZhbHVlc1swXTtcXG57XFxuZm9yIChpbnQgaSA9IDE7IGkgPCBNQVhfU1RPUFM7IGkrKykge1xcbmlmIChpID49IHVfb3BhY2l0eV9jb3VudCkge1xcbmJyZWFrO1xcbn1cXG5mbG9hdCB4MSA9IHVfb3BhY2l0eV9zdG9wc1tpIC0gMV07XFxuaWYgKHggPCB4MSkge1xcbmJyZWFrO1xcbn1cXG5mbG9hdCB4MiA9IHVfb3BhY2l0eV9zdG9wc1tpXTtcXG5mbG9hdCB5MiA9IHVfb3BhY2l0eV92YWx1ZXNbaV07XFxuaWYgKHggPCB4Mikge1xcbmZsb2F0IHkxID0gdV9vcGFjaXR5X3ZhbHVlc1tpIC0gMV07XFxub3BhY2l0eSA9IHkxICsgKHkyIC0geTEpICogKHggLSB4MSkgLyAoeDIgLSB4MSk7XFxufSBlbHNlIHtcXG5vcGFjaXR5ID0geTI7XFxufVxcbn1cXG59XFxuI2Vsc2VcXG5mbG9hdCBvcGFjaXR5ID0gdV9vcGFjaXR5O1xcbiNlbmRpZlxcbnJldHVybiBvcGFjaXR5O1xcbn1cXG5mbG9hdCBnZXRTaXplKGZsb2F0IHgpIHtcXG4jaWZkZWYgVlZfU0laRVxcbmZsb2F0IHNpemUgPSB1X3NpemVfdmFsdWVzWzBdO1xcbntcXG5mb3IgKGludCBpID0gMTsgaSA8IE1BWF9TVE9QUzsgaSsrKSB7XFxuaWYgKGkgPj0gdV9zaXplX2NvdW50KSB7XFxuYnJlYWs7XFxufVxcbmZsb2F0IHgxID0gdV9zaXplX3N0b3BzW2kgLSAxXTtcXG5pZiAoeCA8IHgxKSB7XFxuYnJlYWs7XFxufVxcbmZsb2F0IHgyID0gdV9zaXplX3N0b3BzW2ldO1xcbmZsb2F0IHkyID0gdV9zaXplX3ZhbHVlc1tpXTtcXG5pZiAoeCA8IHgyKSB7XFxuZmxvYXQgeTEgPSB1X3NpemVfdmFsdWVzW2kgLSAxXTtcXG5zaXplID0geTEgKyAoeTIgLSB5MSkgKiAoeCAtIHgxKSAvICh4MiAtIHgxKTtcXG59IGVsc2Uge1xcbnNpemUgPSB5MjtcXG59XFxufVxcbn1cXG4jZWxzZVxcbmZsb2F0IHNpemUgPSB1X3NpemU7XFxuI2VuZGlmXFxucmV0dXJuIHNpemUgKyAyLjAgKiB1X2ZlYXRoZXJpbmdTaXplICogdV9mZWF0aGVyaW5nT2Zmc2V0O1xcbn1cIn0sbWFnZGlyOntcIm1hZ2Rpci5mcmFnXCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9vcGFjaXR5O1xcbnZvaWQgbWFpbigpIHtcXG5nbF9GcmFnQ29sb3IgPSB2X2NvbG9yICogdV9vcGFjaXR5O1xcbn1cIixcIm1hZ2Rpci52ZXJ0XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX29mZnNldDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Z2O1xcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2R2c01hdDM7XFxudW5pZm9ybSBoaWdocCB2ZWMyIHVfY29vcmRTY2FsZTtcXG51bmlmb3JtIHZlYzIgdV9zeW1ib2xTaXplO1xcbnVuaWZvcm0gdmVjMiB1X3N5bWJvbFBlcmNlbnRSYW5nZTtcXG51bmlmb3JtIHZlYzIgdV9kYXRhUmFuZ2U7XFxudW5pZm9ybSBmbG9hdCB1X3JvdGF0aW9uO1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yc1sxMl07XFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudm9pZCBtYWluKClcXG57XFxuZmxvYXQgYW5nbGUgPSBhX29mZnNldC55ICsgdV9yb3RhdGlvbjtcXG4jaWZuZGVmIFJPVEFUSU9OX0dFT0dSQVBISUNcXG5hbmdsZSA9IDMuMTQxNTkyNjUzNTkgKiAyLjAgLSBhbmdsZSAtIDMuMTQxNTkyNjUzNTkgLyAyLjA7XFxuI2VuZGlmXFxudmVjMiBvZmZzZXQgPSB2ZWMyKGNvcyhhbmdsZSksIHNpbihhbmdsZSkpICogYV9vZmZzZXQueDtcXG4jaWZkZWYgREFUQV9SQU5HRVxcbmZsb2F0IHZhbHVlUGVyY2VudGFnZSA9IGNsYW1wKChhX3Z2LnkgLSB1X2RhdGFSYW5nZS54KSAvICh1X2RhdGFSYW5nZS55IC0gdV9kYXRhUmFuZ2UueCksIDAuMCwgMS4wKTtcXG5mbG9hdCBzaXplUmF0aW8gPSB1X3N5bWJvbFBlcmNlbnRSYW5nZS54ICsgdmFsdWVQZXJjZW50YWdlICogKHVfc3ltYm9sUGVyY2VudFJhbmdlLnkgLSB1X3N5bWJvbFBlcmNlbnRSYW5nZS54KTtcXG5mbG9hdCBzaXplUGVyY2VudGFnZSA9IGNsYW1wKHNpemVSYXRpbywgdV9zeW1ib2xQZXJjZW50UmFuZ2UueCwgdV9zeW1ib2xQZXJjZW50UmFuZ2UueSk7XFxuI2Vsc2VcXG5mbG9hdCBzaXplUGVyY2VudGFnZSA9ICh1X3N5bWJvbFBlcmNlbnRSYW5nZS54ICsgdV9zeW1ib2xQZXJjZW50UmFuZ2UueSkgLyAyLjA7XFxuI2VuZGlmXFxudmVjMiBwb3MgPSBhX3BvcyArIG9mZnNldCAqIHNpemVQZXJjZW50YWdlICogdV9zeW1ib2xTaXplO1xcbnZfY29sb3IgPSB1X2NvbG9yc1tpbnQoYV92di54KV07XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KHVfZHZzTWF0MyAqIHZlYzMocG9zICogdV9jb29yZFNjYWxlLCAxLjApLCAxLjApO1xcbn1cIn0scmVwcm9qZWN0OntcInJlcHJvamVjdC5mcmFnXCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcXG4jaW5jbHVkZSA8cmFzdGVyL2NvbW1vbi9jb21tb24uZ2xzbD5cXG52b2lkIG1haW4oKSB7XFxudmVjMiBwaXhlbExvY2F0aW9uID0gZ2V0UGl4ZWxMb2NhdGlvbih2X3RleGNvb3JkKTtcXG5pZiAoaXNPdXRzaWRlKHBpeGVsTG9jYXRpb24pKSB7XFxuZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbnJldHVybjtcXG59XFxudmVjNCBjdXJyZW50UGl4ZWwgPSBnZXRQaXhlbChwaXhlbExvY2F0aW9uKTtcXG5nbF9GcmFnQ29sb3IgPSB2ZWM0KGN1cnJlbnRQaXhlbC5yZ2IsIDEuMCkgKiBjdXJyZW50UGl4ZWwuYSAqIHVfb3BhY2l0eTtcXG59XCIsXCJyZXByb2plY3QudmVydFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG52YXJ5aW5nIGhpZ2hwIHZlYzIgdl90ZXhjb29yZDtcXG52b2lkIG1haW4oKVxcbntcXG52X3RleGNvb3JkID0gYV9wb3NpdGlvbjtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQoMi4wICogKGFfcG9zaXRpb24gLSAwLjUpLCAwLjAsIDEuMCk7XFxufVwifSxzY2FsYXI6e1wic2NhbGFyLmZyYWdcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X29wYWNpdHk7XFxudmFyeWluZyB2ZWMyIHZfcG9zO1xcbmNvbnN0IHZlYzQgb3V0bGluZUNvbG9yID0gdmVjNCgwLjIsIDAuMiwgMC4yLCAxLjApO1xcbmNvbnN0IGZsb2F0IG91dGxpbmVTaXplID0gMC4wMjtcXG5jb25zdCBmbG9hdCBpbm5lclJhZGl1cyA9IDAuMjU7XFxuY29uc3QgZmxvYXQgb3V0ZXJSYWRpdXMgPSAwLjQyO1xcbmNvbnN0IGZsb2F0IGlubmVyU3F1YXJlTGVuZ3RoID0gMC4xNTtcXG52b2lkIG1haW4oKSB7XFxubWVkaXVtcCBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZfcG9zKTtcXG5tZWRpdW1wIGZsb2F0IGZpbGxhbHBoYTEgPSBzbW9vdGhzdGVwKG91dGVyUmFkaXVzLCBvdXRlclJhZGl1cyArIG91dGxpbmVTaXplLCBkaXN0KTtcXG5maWxsYWxwaGExICo9ICgxLjAtc21vb3Roc3RlcChvdXRlclJhZGl1cyArIG91dGxpbmVTaXplLCBvdXRlclJhZGl1cyArIDAuMSArIG91dGxpbmVTaXplLCBkaXN0KSk7XFxuI2lmZGVmIElOTkVSX0NJUkNMRVxcbm1lZGl1bXAgZmxvYXQgZmlsbGFscGhhMiA9IHNtb290aHN0ZXAoaW5uZXJSYWRpdXMsIGlubmVyUmFkaXVzICsgb3V0bGluZVNpemUsIGRpc3QpO1xcbmZpbGxhbHBoYTIgKj0gKDEuMC1zbW9vdGhzdGVwKGlubmVyUmFkaXVzICsgb3V0bGluZVNpemUsIGlubmVyUmFkaXVzICsgMC4xICsgb3V0bGluZVNpemUsIGRpc3QpKTtcXG4jZWxzZVxcbm1lZGl1bXAgZmxvYXQgZmlsbGFscGhhMiA9IChhYnModl9wb3MueCkgPCBpbm5lclNxdWFyZUxlbmd0aCA/IDEuMCA6IDAuMCkgKiAoYWJzKHZfcG9zLnkpIDwgaW5uZXJTcXVhcmVMZW5ndGggPyAxLjAgOiAwLjApO1xcbiNlbmRpZlxcbmdsX0ZyYWdDb2xvciA9IChmaWxsYWxwaGEyICsgZmlsbGFscGhhMSkgKiBvdXRsaW5lQ29sb3IgKiB1X29wYWNpdHk7XFxufVwiLFwic2NhbGFyLnZlcnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfb2Zmc2V0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdnY7XFxudW5pZm9ybSBoaWdocCBtYXQzIHVfZHZzTWF0MztcXG51bmlmb3JtIGhpZ2hwIHZlYzIgdV9jb29yZFNjYWxlO1xcbnVuaWZvcm0gdmVjMiB1X3N5bWJvbFNpemU7XFxudW5pZm9ybSB2ZWMyIHVfc3ltYm9sUGVyY2VudFJhbmdlO1xcbnVuaWZvcm0gdmVjMiB1X2RhdGFSYW5nZTtcXG52YXJ5aW5nIHZlYzIgdl9wb3M7XFxudm9pZCBtYWluKClcXG57XFxuI2lmZGVmIERBVEFfUkFOR0VcXG5mbG9hdCB2YWx1ZVBlcmNlbnRhZ2UgPSBjbGFtcCgoYV92di55IC0gdV9kYXRhUmFuZ2UueCkgLyAodV9kYXRhUmFuZ2UueSAtIHVfZGF0YVJhbmdlLngpLCAwLjAsIDEuMCk7XFxuZmxvYXQgc2l6ZVJhdGlvID0gdV9zeW1ib2xQZXJjZW50UmFuZ2UueCArIHZhbHVlUGVyY2VudGFnZSAqICh1X3N5bWJvbFBlcmNlbnRSYW5nZS55IC0gdV9zeW1ib2xQZXJjZW50UmFuZ2UueCk7XFxuZmxvYXQgc2l6ZVBlcmNlbnRhZ2UgPSBjbGFtcChzaXplUmF0aW8sIHVfc3ltYm9sUGVyY2VudFJhbmdlLngsIHVfc3ltYm9sUGVyY2VudFJhbmdlLnkpO1xcbiNlbHNlXFxuZmxvYXQgc2l6ZVBlcmNlbnRhZ2UgPSAodV9zeW1ib2xQZXJjZW50UmFuZ2UueCArIHVfc3ltYm9sUGVyY2VudFJhbmdlLnkpIC8gMi4wO1xcbiNlbmRpZlxcbnZlYzIgc2l6ZSA9IHVfc3ltYm9sU2l6ZSAqIHNpemVQZXJjZW50YWdlO1xcbnZlYzIgcG9zID0gYV9wb3MgKyBhX29mZnNldCAqIHNpemU7XFxudl9wb3MgPSBhX29mZnNldDtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQodV9kdnNNYXQzICogdmVjMyhwb3MgKiB1X2Nvb3JkU2NhbGUsIDEuMCksIDEuMCk7XFxufVwifX0sc3RlbmNpbDp7XCJzdGVuY2lsLmZyYWdcIjpcInZvaWQgbWFpbigpIHtcXG5nbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XFxufVwiLFwic3RlbmNpbC52ZXJ0XCI6XCJhdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIG1hdDMgdV93b3JsZEV4dGVudDtcXG52b2lkIG1haW4oKSB7XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KHVfd29ybGRFeHRlbnQgKiB2ZWMzKGFfcG9zLCAxLjApLCAxLjApO1xcbn1cIn0sdGVzdDp7XCJUZXN0U2hhZGVyLmNvbW1vbi5nbHNsXCI6XCIjaWZuZGVmIFJFVFVSTl9SRURcXG52YXJ5aW5nICAgIHZlYzQgICAgICB2X2NvbG9yO1xcbiNlbmRpZlxcbnZhcnlpbmcgICAgdmVjMiAgICAgIHZfb2Zmc2V0O1wiLFwiVGVzdFNoYWRlci5mcmFnXCI6XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2luY2x1ZGUgPHRlc3QvVGVzdFNoYWRlci5jb21tb24uZ2xzbD5cXG52b2lkIG1haW4oKSB7XFxuaWYgKHZfb2Zmc2V0LnggPiAtLjUgJiYgdl9vZmZzZXQueSA+IC0uNSAmJiB2X29mZnNldC54IDwgLjUgJiYgdl9vZmZzZXQueSA8IC41KSB7XFxuZGlzY2FyZDtcXG59XFxuI2lmZGVmIFJFVFVSTl9SRURcXG5nbF9GcmFnQ29sb3IgPSB2ZWM0KDEuLCAwLiwgMC4sIDEuKTtcXG4jZWxzZVxcbmdsX0ZyYWdDb2xvciA9IHZfY29sb3I7XFxuI2VuZGlmXFxufVwiLFwiVGVzdFNoYWRlci52ZXJ0XCI6XCJjb25zdCBmbG9hdCBQT1NfUFJFQ0lTSU9OX0ZBQ1RPUiA9IDEwLjtcXG5jb25zdCBmbG9hdCBPRkZTRVRfUFJFQ0lTSU9OX0ZBQ1RPUiA9IDEwLjtcXG5jb25zdCBmbG9hdCBTSVpFX1BSRUNJU0lPTl9GQUNUT1IgPSAxMC47XFxuYXR0cmlidXRlICB2ZWMyICAgICAgYV9wb3NfcGFja2VkO1xcbmF0dHJpYnV0ZSAgdmVjMiAgICAgIGFfb2Zmc2V0X3BhY2tlZDtcXG5hdHRyaWJ1dGUgIGZsb2F0ICAgICBhX3NpemVfcGFja2VkO1xcbiNpZmRlZiBEQVRBX0RSSVZFTl9DT0xPUlxcbmNvbnN0IGZsb2F0IHVfZGF0YURyaXZlbkNvbG9yX3ZhbGlkVmFsdWVzWzRdID0gZmxvYXRbNF0oMC4sIDAuLCAxLiwgMC4pO1xcbnVuaWZvcm0gICAgdmVjNCAgICAgIHVfZGF0YURyaXZlbkNvbG9yX2NvbG9yRmFsbGJhY2s7XFxudW5pZm9ybSAgICB2ZWM0ICAgICAgdV9kYXRhRHJpdmVuQ29sb3JfY29sb3I7XFxuI2VuZGlmXFxudW5pZm9ybSAgICBmbG9hdCAgICAgdV92aWV3X3pvb21MZXZlbDtcXG4jaW5jbHVkZSA8dGVzdC9UZXN0U2hhZGVyLmNvbW1vbi5nbHNsPlxcbiNpZmRlZiBEQVRBX0RSSVZFTl9DT0xPUlxcbnZlYzQgZ2V0Q29sb3IoZmxvYXQgdmFsdWUpIHtcXG5pbnQgaW5kZXggPSAtMTtcXG5mb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKykge1xcbmlmICh1X2RhdGFEcml2ZW5Db2xvcl92YWxpZFZhbHVlc1tpXSA9PSB2YWx1ZSkge1xcbmluZGV4ID0gaTtcXG5icmVhaztcXG59XFxufVxcbmlmIChpbmRleCA9PSAtMSkge1xcbnJldHVybiB1X2RhdGFEcml2ZW5Db2xvcl9jb2xvckZhbGxiYWNrO1xcbn1cXG5yZXR1cm4gdV9kYXRhRHJpdmVuQ29sb3JfY29sb3I7XFxufVxcbiNlbmRpZlxcbnZvaWQgbWFpbigpIHtcXG52ZWMyICBhX3BvcyA9IGFfcG9zX3BhY2tlZCAvIFBPU19QUkVDSVNJT05fRkFDVE9SO1xcbnZlYzIgIGFfb2Zmc2V0ID0gYV9vZmZzZXRfcGFja2VkIC8gT0ZGU0VUX1BSRUNJU0lPTl9GQUNUT1I7XFxuZmxvYXQgYV9zaXplID0gYV9zaXplX3BhY2tlZCAvIFNJWkVfUFJFQ0lTSU9OX0ZBQ1RPUjtcXG52ZWM0IGNvbG9yID0gdmVjNCgxLiwgMC4sIDAuLCAxLik7XFxuI2lmZGVmIERBVEFfRFJJVkVOX0NPTE9SXFxuY29sb3IgPSBnZXRDb2xvcigxLik7XFxuI2VuZGlmXFxudmVjMiBvZmZzZXRTY2FsZWQgPSBhX29mZnNldCAqIGFfc2l6ZTtcXG52ZWM0IHBvcyA9IHZlYzQoYV9wb3MueHkgKyBvZmZzZXRTY2FsZWQsIDAuLCAxLik7XFxuZ2xfUG9zaXRpb24gPSBwb3M7XFxuI2lmbmRlZiBSRVRVUk5fUkVEXFxudl9jb2xvciA9IGNvbG9yO1xcbiNlbmRpZlxcbnZfb2Zmc2V0ID0gYV9vZmZzZXQ7XFxufVwifSx0aWxlSW5mbzp7XCJ0aWxlSW5mby5mcmFnXCI6XCJ1bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RleDtcXG52b2lkIG1haW4odm9pZCkge1xcbmxvd3AgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4KTtcXG5jb2xvci5yZ2IgKj0gY29sb3IuYTtcXG5nbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XCIsXCJ0aWxlSW5mby52ZXJ0XCI6XCJhdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kdnNNYXQzO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2RlcHRoO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVfY29vcmRfcmF0aW87XFxudW5pZm9ybSBtZWRpdW1wIHZlYzIgdV9kZWx0YTtcXG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1X2RpbWVuc2lvbnM7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl90ZXg7XFxudm9pZCBtYWluKCkge1xcbm1lZGl1bXAgdmVjMiBvZmZzZXQgPSB1X2Nvb3JkX3JhdGlvICogdmVjMih1X2RlbHRhICsgYV9wb3MgKiB1X2RpbWVuc2lvbnMpO1xcbnZlYzMgdl9wb3MgPSB1X2R2c01hdDMgKiB2ZWMzKG9mZnNldCwgMS4wKTtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQodl9wb3MueHksIDAuMCwgMS4wKTtcXG52X3RleCA9IGFfcG9zO1xcbn1cIn0sdXRpbDp7XCJhdGFuMi5nbHNsXCI6XCJmbG9hdCBhdGFuMihpbiBmbG9hdCB5LCBpbiBmbG9hdCB4KSB7XFxuZmxvYXQgdDAsIHQxLCB0MiwgdDMsIHQ0O1xcbnQzID0gYWJzKHgpO1xcbnQxID0gYWJzKHkpO1xcbnQwID0gbWF4KHQzLCB0MSk7XFxudDEgPSBtaW4odDMsIHQxKTtcXG50MyA9IDEuMCAvIHQwO1xcbnQzID0gdDEgKiB0MztcXG50NCA9IHQzICogdDM7XFxudDAgPSAgICAgICAgIC0gMC4wMTM0ODA0NzA7XFxudDAgPSB0MCAqIHQ0ICsgMC4wNTc0NzczMTQ7XFxudDAgPSB0MCAqIHQ0IC0gMC4xMjEyMzkwNzE7XFxudDAgPSB0MCAqIHQ0ICsgMC4xOTU2MzU5MjU7XFxudDAgPSB0MCAqIHQ0IC0gMC4zMzI5OTQ1OTc7XFxudDAgPSB0MCAqIHQ0ICsgMC45OTk5OTU2MzA7XFxudDMgPSB0MCAqIHQzO1xcbnQzID0gKGFicyh5KSA+IGFicyh4KSkgPyAxLjU3MDc5NjMyNyAtIHQzIDogdDM7XFxudDMgPSB4IDwgMC4wID8gIDMuMTQxNTkyNjU0IC0gdDMgOiB0MztcXG50MyA9IHkgPCAwLjAgPyAtdDMgOiB0MztcXG5yZXR1cm4gdDM7XFxufVwiLFwiZW5jb2RpbmcuZ2xzbFwiOlwiY29uc3QgdmVjNCByZ2JhMmZsb2F0X2ZhY3RvcnMgPSB2ZWM0KFxcbjI1NS4wIC8gKDI1Ni4wKSxcXG4yNTUuMCAvICgyNTYuMCAqIDI1Ni4wKSxcXG4yNTUuMCAvICgyNTYuMCAqIDI1Ni4wICogMjU2LjApLFxcbjI1NS4wIC8gKDI1Ni4wICogMjU2LjAgKiAyNTYuMCAqIDI1Ni4wKVxcbik7XFxuZmxvYXQgcmdiYTJmbG9hdCh2ZWM0IHJnYmEpIHtcXG5yZXR1cm4gZG90KHJnYmEsIHJnYmEyZmxvYXRfZmFjdG9ycyk7XFxufVwifX07ZXhwb3J0e2UgYXMgZGVmYXVsdH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuY2xhc3MgdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLl9wb3M9MCx0aGlzLl9idWZmZXI9dCx0aGlzLl9pMzJWaWV3PW5ldyBJbnQzMkFycmF5KHRoaXMuX2J1ZmZlciksdGhpcy5fZjMyVmlldz1uZXcgRmxvYXQzMkFycmF5KHRoaXMuX2J1ZmZlcil9cmVhZEludDMyKCl7cmV0dXJuIHRoaXMuX2kzMlZpZXdbdGhpcy5fcG9zKytdfXJlYWRGMzIoKXtyZXR1cm4gdGhpcy5fZjMyVmlld1t0aGlzLl9wb3MrK119fWV4cG9ydHt0IGFzIGRlZmF1bHR9O1xuIiwiLypcbkFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMzMvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuKi9cbmltcG9ydHtQcm9ncmFtIGFzIHJ9ZnJvbVwiLi9Qcm9ncmFtLmpzXCI7ZnVuY3Rpb24gZShlLHQsYT1cIlwiKXtyZXR1cm4gbmV3IHIoZSxhK3Quc2hhZGVycy52ZXJ0ZXhTaGFkZXIsYSt0LnNoYWRlcnMuZnJhZ21lbnRTaGFkZXIsdC5hdHRyaWJ1dGVzKX1leHBvcnR7ZSBhcyBjcmVhdGVQcm9ncmFtfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==