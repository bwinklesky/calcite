export const __webpack_id__ = "vendors-node_modules_esri_calcite-components_dist_chunks_InternalLabel_js-node_modules_esri_c-1bd181";
export const __webpack_ids__ = ["vendors-node_modules_esri_calcite-components_dist_chunks_InternalLabel_js-node_modules_esri_c-1bd181"];
export const __webpack_modules__ = {

/***/ "./node_modules/@esri/calcite-components/dist/chunks/InternalLabel.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/chunks/InternalLabel.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ InternalLabel)
/* harmony export */ });
/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var _arcgis_lumina__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @arcgis/lumina */ "./node_modules/@arcgis/lumina/dist/index.js");
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */


const CSS = {
  alignmentCenter: "internal-label-alignment--center",
  alignmentEnd: "internal-label-alignment--end",
  container: "internal-label--container",
  requiredIndicator: "internal-label-required--indicator",
  spacingBottom: "internal-label-spacing--bottom",
  spacingInlineEnd: "internal-label-spacing-inline--end",
  spacingInlineStart: "internal-label-spacing-inline--start",
  text: "internal-label--text"
};
const InternalLabel = ({ alignmentCenter, bottomSpacingDisabled, labelText, onClick, required, spacingInlineEnd, spacingInlineStart, tooltipText }) => (0,lit_html__WEBPACK_IMPORTED_MODULE_0__.html)`<div class=${(0,_arcgis_lumina__WEBPACK_IMPORTED_MODULE_1__.safeClassMap)({
  [CSS.alignmentCenter]: alignmentCenter,
  [CSS.alignmentEnd]: !alignmentCenter,
  [CSS.container]: true,
  [CSS.spacingBottom]: !bottomSpacingDisabled,
  [CSS.spacingInlineEnd]: spacingInlineEnd,
  [CSS.spacingInlineStart]: spacingInlineStart
})} @click=${onClick}><div class=${(0,_arcgis_lumina__WEBPACK_IMPORTED_MODULE_1__.safeClassMap)(CSS.text)}>${labelText}${required && (0,lit_html__WEBPACK_IMPORTED_MODULE_0__.html)`<span aria-hidden=true class=${(0,_arcgis_lumina__WEBPACK_IMPORTED_MODULE_1__.safeClassMap)(CSS.requiredIndicator)} title=${tooltipText ?? lit_html__WEBPACK_IMPORTED_MODULE_0__.nothing}>*</span>` || ""}</div><slot name=label-content></slot></div>`;



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/chunks/Validation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/chunks/Validation.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ Validation)
/* harmony export */ });
/* harmony import */ var lit_directives_ref_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit/directives/ref.js */ "./node_modules/lit/directives/ref.js");
/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit-html */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var _arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcgis/lumina */ "./node_modules/@arcgis/lumina/dist/index.js");
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */



const CSS = {
  validationContainer: "validation-container"
};
const validationReference = () => {
  return;
};
const Validation = ({ scale, status, id, icon, message, ref: ref$1 }) => (0,lit_html__WEBPACK_IMPORTED_MODULE_1__.html)`<div class=${(0,_arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.safeClassMap)(CSS.validationContainer)} ${(0,lit_directives_ref_js__WEBPACK_IMPORTED_MODULE_0__.ref)(ref$1 ? ref$1 : validationReference)}><calcite-input-message aria-live=polite .icon=${icon} id=${id ?? lit_html__WEBPACK_IMPORTED_MODULE_1__.nothing} .scale=${scale} .status=${status}>${message}</calcite-input-message></div>`;



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/chunks/input.js":
/*!********************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/chunks/input.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   s: () => (/* binding */ syncHiddenFormInput)
/* harmony export */ });
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */
const minMaxStepTypes = ["date", "datetime-local", "month", "number", "range", "time", "week"];
const patternTypes = ["email", "password", "search", "tel", "text", "url"];
const minMaxLengthTypes = ["email", "password", "search", "tel", "text", "textarea", "url"];
function updateConstraintValidation(inputComponent, input, propName, matchesType) {
  const attributeName = propName.toLowerCase();
  const value = inputComponent[propName];
  if (matchesType && value != null) {
    input.setAttribute(attributeName, `${value}`);
  } else {
    input.removeAttribute(attributeName);
  }
}
function syncHiddenFormInput(type, inputComponent, hiddenFormInput) {
  hiddenFormInput.type = type === "textarea" ? "text" : type;
  const isMinMaxStepType = minMaxStepTypes.includes(type);
  const numericInputComponent = inputComponent;
  updateConstraintValidation(numericInputComponent, hiddenFormInput, "min", isMinMaxStepType);
  updateConstraintValidation(numericInputComponent, hiddenFormInput, "max", isMinMaxStepType);
  updateConstraintValidation(numericInputComponent, hiddenFormInput, "step", isMinMaxStepType);
  const isMinMaxLengthType = minMaxLengthTypes.includes(type);
  const textualInputComponent = inputComponent;
  updateConstraintValidation(textualInputComponent, hiddenFormInput, "minLength", isMinMaxLengthType);
  updateConstraintValidation(textualInputComponent, hiddenFormInput, "maxLength", isMinMaxLengthType);
  const isPatternType = patternTypes.includes(type);
  updateConstraintValidation(textualInputComponent, hiddenFormInput, "pattern", isPatternType);
}



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/chunks/key.js":
/*!******************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/chunks/key.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ isActivationKey),
/* harmony export */   n: () => (/* binding */ numberKeys)
/* harmony export */ });
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */
function isActivationKey(key) {
  return key === "Enter" || key === " ";
}
const numberKeys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/chunks/label.js":
/*!********************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/chunks/label.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ associateExplicitLabelToUnlabeledComponent),
/* harmony export */   b: () => (/* binding */ labelDisconnectedEvent),
/* harmony export */   c: () => (/* binding */ connectLabel),
/* harmony export */   d: () => (/* binding */ disconnectLabel),
/* harmony export */   g: () => (/* binding */ getLabelText),
/* harmony export */   l: () => (/* binding */ labelConnectedEvent)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@esri/calcite-components/dist/chunks/dom.js");
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */

const labelClickEvent = "calciteInternalLabelClick";
const labelConnectedEvent = "calciteInternalLabelConnected";
const labelDisconnectedEvent = "calciteInternalLabelDisconnected";
const labelTagName = "calcite-label";
const labelToLabelables = /* @__PURE__ */ new WeakMap();
const onLabelClickMap = /* @__PURE__ */ new WeakMap();
const onLabelConnectedMap = /* @__PURE__ */ new WeakMap();
const onLabelDisconnectedMap = /* @__PURE__ */ new WeakMap();
const unlabeledComponents = /* @__PURE__ */ new Set();
const findLabelForComponent = (componentEl) => {
  const { id } = componentEl;
  const forLabel = id && (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.q)(componentEl, { selector: `${labelTagName}[for="${id}"]` });
  if (forLabel) {
    return forLabel;
  }
  const parentLabel = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.l)(componentEl, labelTagName);
  if (!parentLabel || // labelable components within other custom elements are not considered labelable
  hasAncestorCustomElements(parentLabel, componentEl)) {
    return null;
  }
  return parentLabel;
};
function hasAncestorCustomElements(label, componentEl) {
  let traversedElements;
  const customElementAncestorCheckEventType = "custom-element-ancestor-check";
  const listener = (event) => {
    event.stopImmediatePropagation();
    const composedPath = event.composedPath();
    traversedElements = composedPath.slice(composedPath.indexOf(componentEl), composedPath.indexOf(label));
  };
  label.addEventListener(customElementAncestorCheckEventType, listener, { once: true });
  componentEl.dispatchEvent(new CustomEvent(customElementAncestorCheckEventType, { composed: true, bubbles: true }));
  label.removeEventListener(customElementAncestorCheckEventType, listener);
  const ancestorCustomElements = traversedElements.filter((el) => el !== componentEl && el !== label).filter((el) => el.tagName?.includes("-"));
  return ancestorCustomElements.length > 0;
}
function connectLabel(component) {
  if (!component) {
    return;
  }
  const labelEl = findLabelForComponent(component.el);
  if (onLabelClickMap.has(labelEl) && labelEl === component.labelEl || !labelEl && unlabeledComponents.has(component)) {
    return;
  }
  const boundOnLabelDisconnected = onLabelDisconnected.bind(component);
  if (labelEl) {
    component.labelEl = labelEl;
    const labelables = labelToLabelables.get(labelEl) || [];
    labelables.push(component);
    labelToLabelables.set(labelEl, labelables.sort(sortByDOMOrder));
    if (!onLabelClickMap.has(component.labelEl)) {
      onLabelClickMap.set(component.labelEl, onLabelClick);
      component.labelEl.addEventListener(labelClickEvent, onLabelClick);
    }
    unlabeledComponents.delete(component);
    document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));
    onLabelDisconnectedMap.set(component, boundOnLabelDisconnected);
    document.addEventListener(labelDisconnectedEvent, boundOnLabelDisconnected);
  } else if (!unlabeledComponents.has(component)) {
    boundOnLabelDisconnected();
    document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));
  }
}
function disconnectLabel(component) {
  if (!component) {
    return;
  }
  unlabeledComponents.delete(component);
  document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));
  document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));
  onLabelConnectedMap.delete(component);
  onLabelDisconnectedMap.delete(component);
  if (!component.labelEl) {
    return;
  }
  const labelables = labelToLabelables.get(component.labelEl);
  if (labelables.length === 1) {
    component.labelEl.removeEventListener(labelClickEvent, onLabelClickMap.get(component.labelEl));
    onLabelClickMap.delete(component.labelEl);
  }
  labelToLabelables.set(
    component.labelEl,
    labelables.filter((labelable) => labelable !== component).sort(sortByDOMOrder)
  );
  component.labelEl = null;
}
function sortByDOMOrder(a, b) {
  return (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.m)(a.el, b.el) ? -1 : 1;
}
function getLabelText(component) {
  return component.label || component.labelEl?.textContent?.trim() || "";
}
function onLabelClick(event) {
  const labelClickTarget = event.detail.sourceEvent.target;
  const labelables = labelToLabelables.get(this);
  const clickedLabelable = labelables.find((labelable) => labelable.el === labelClickTarget);
  const labelableChildClicked = labelables.includes(clickedLabelable);
  if (labelableChildClicked) {
    return;
  }
  const firstLabelable = labelables[0];
  if (firstLabelable.disabled) {
    return;
  }
  firstLabelable.onLabelClick(event);
}
function onLabelConnected() {
  if (unlabeledComponents.has(this)) {
    connectLabel(this);
  }
}
function onLabelDisconnected() {
  unlabeledComponents.add(this);
  const boundOnLabelConnected = onLabelConnectedMap.get(this) || onLabelConnected.bind(this);
  onLabelConnectedMap.set(this, boundOnLabelConnected);
  document.addEventListener(labelConnectedEvent, boundOnLabelConnected);
}
async function associateExplicitLabelToUnlabeledComponent(label) {
  await label.componentOnReady();
  const alreadyLabeled = labelToLabelables.has(label);
  if (alreadyLabeled) {
    return;
  }
  const forComponentEl = label.ownerDocument?.getElementById(label.for);
  if (!forComponentEl) {
    return;
  }
  requestAnimationFrame(() => {
    for (const labelable of unlabeledComponents) {
      if (labelable.el === forComponentEl) {
        connectLabel(labelable);
        break;
      }
    }
  });
}



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/chunks/locale.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/chunks/locale.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ BigDecimal),
/* harmony export */   N: () => (/* binding */ NumberStringFormat),
/* harmony export */   a: () => (/* binding */ getSupportedNumberingSystem),
/* harmony export */   b: () => (/* binding */ getSupportedLocale),
/* harmony export */   c: () => (/* binding */ addLocalizedTrailingDecimalZeros),
/* harmony export */   d: () => (/* binding */ getDateFormatSupportedLocale),
/* harmony export */   g: () => (/* binding */ getDateTimeFormat),
/* harmony export */   i: () => (/* binding */ isValidNumber),
/* harmony export */   l: () => (/* binding */ localizedTwentyFourHourMeridiems),
/* harmony export */   n: () => (/* binding */ numberStringFormatter),
/* harmony export */   p: () => (/* binding */ parseNumberString),
/* harmony export */   s: () => (/* binding */ sanitizeNumberString)
/* harmony export */ });
/* harmony import */ var _key_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./key.js */ "./node_modules/@esri/calcite-components/dist/chunks/key.js");
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */

const unnecessaryDecimal = new RegExp(`\\${"."}(0+)?$`);
const trailingZeros = new RegExp("0+$");
class BigDecimal {
  static {
    this.DECIMALS = 100;
  }
  static {
    this.ROUNDED = true;
  }
  static {
    this.SHIFT = BigInt("1" + "0".repeat(this.DECIMALS));
  }
  // derived constant
  constructor(input) {
    if (input instanceof BigDecimal) {
      return input;
    }
    const [integers, decimals] = expandExponentialNumberString(input).split(".").concat("");
    this.value = BigInt(integers + decimals.padEnd(BigDecimal.DECIMALS, "0").slice(0, BigDecimal.DECIMALS)) + BigInt(BigDecimal.ROUNDED && decimals[BigDecimal.DECIMALS] >= "5");
    this.isNegative = input.charAt(0) === "-";
  }
  static {
    this._divRound = (dividend, divisor) => BigDecimal.fromBigInt(
      dividend / divisor + (BigDecimal.ROUNDED ? dividend * BigInt(2) / divisor % BigInt(2) : BigInt(0))
    );
  }
  static {
    this.fromBigInt = (bigint) => Object.assign(Object.create(BigDecimal.prototype), { value: bigint, isNegative: bigint < BigInt(0) });
  }
  getIntegersAndDecimals() {
    const s = this.value.toString().replace("-", "").padStart(BigDecimal.DECIMALS + 1, "0");
    const integers = s.slice(0, -BigDecimal.DECIMALS);
    const decimals = s.slice(-BigDecimal.DECIMALS).replace(trailingZeros, "");
    return { integers, decimals };
  }
  toString() {
    const { integers, decimals } = this.getIntegersAndDecimals();
    return `${this.isNegative ? "-" : ""}${integers}${decimals.length ? "." + decimals : ""}`;
  }
  formatToParts(formatter) {
    const { integers, decimals } = this.getIntegersAndDecimals();
    const parts = formatter.numberFormatter.formatToParts(BigInt(integers));
    if (this.isNegative) {
      parts.unshift({ type: "minusSign", value: formatter.minusSign });
    }
    if (decimals.length) {
      parts.push({ type: "decimal", value: formatter.decimal });
      decimals.split("").forEach((char) => parts.push({ type: "fraction", value: char }));
    }
    return parts;
  }
  format(formatter) {
    const { integers, decimals } = this.getIntegersAndDecimals();
    const integersFormatted = `${this.isNegative ? formatter.minusSign : ""}${formatter.numberFormatter.format(
      BigInt(integers)
    )}`;
    const decimalsFormatted = decimals.length ? `${formatter.decimal}${decimals.split("").map((char) => formatter.numberFormatter.format(Number(char))).join("")}` : "";
    return `${integersFormatted}${decimalsFormatted}`;
  }
  add(n) {
    return BigDecimal.fromBigInt(this.value + new BigDecimal(n).value);
  }
  subtract(n) {
    return BigDecimal.fromBigInt(this.value - new BigDecimal(n).value);
  }
  multiply(n) {
    return BigDecimal._divRound(this.value * new BigDecimal(n).value, BigDecimal.SHIFT);
  }
  divide(n) {
    return BigDecimal._divRound(this.value * BigDecimal.SHIFT, new BigDecimal(n).value);
  }
}
function isValidNumber(numberString) {
  return !(!numberString || isNaN(Number(numberString)));
}
function parseNumberString(numberString) {
  if (!numberString || !stringContainsNumbers(numberString)) {
    return "";
  }
  return sanitizeExponentialNumberString(numberString, (nonExpoNumString) => {
    let containsDecimal = false;
    const result = nonExpoNumString.split("").filter((value, i) => {
      if (value.match(/\./g) && !containsDecimal) {
        containsDecimal = true;
        return true;
      }
      if (value.match(/-/g) && i === 0) {
        return true;
      }
      return _key_js__WEBPACK_IMPORTED_MODULE_0__.n.includes(value);
    }).join("");
    return isValidNumber(result) ? new BigDecimal(result).toString() : "";
  });
}
const allLeadingZerosOptionallyNegative = /^([-0])0+(?=\d)/;
const decimalOnlyAtEndOfString = /(?!^\.)\.$/;
const allHyphensExceptTheStart = /(?!^-)-/g;
const isNegativeDecimalOnlyZeros = /^-\b0\b\.?0*$/;
const hasTrailingDecimalZeros = /0*$/;
const charAllowlist = /* @__PURE__ */ new Set(["e", "E", "-", ",", ".", ..._key_js__WEBPACK_IMPORTED_MODULE_0__.n]);
const sanitizeNumberString = (numberString) => {
  const strippedInvalidCharsValue = Array.from(numberString).filter((char) => charAllowlist.has(char)).join("");
  return sanitizeExponentialNumberString(strippedInvalidCharsValue, (nonExpoNumString) => {
    const sanitizedValue = nonExpoNumString.replace(allHyphensExceptTheStart, "").replace(decimalOnlyAtEndOfString, "").replace(allLeadingZerosOptionallyNegative, "$1");
    return isValidNumber(sanitizedValue) ? isNegativeDecimalOnlyZeros.test(sanitizedValue) ? sanitizedValue : getBigDecimalAsString(sanitizedValue) : nonExpoNumString;
  });
};
function getBigDecimalAsString(sanitizedValue) {
  const sanitizedValueDecimals = sanitizedValue.split(".")[1];
  const value = new BigDecimal(sanitizedValue).toString();
  const [bigDecimalValueInteger, bigDecimalValueDecimals] = value.split(".");
  return sanitizedValueDecimals && bigDecimalValueDecimals !== sanitizedValueDecimals ? `${bigDecimalValueInteger}.${sanitizedValueDecimals}` : value;
}
function sanitizeExponentialNumberString(numberString, func) {
  if (!numberString) {
    return numberString;
  }
  const firstE = numberString.toLowerCase().indexOf("e") + 1;
  if (!firstE) {
    return func(numberString);
  }
  return numberString.replace(/[eE]*$/g, "").substring(0, firstE).concat(numberString.slice(firstE).replace(/[eE]/g, "")).split(/[eE]/).map((section, i) => i === 1 ? func(section.replace(/\./g, "")) : func(section)).join("e").replace(/^e/, "1e");
}
function expandExponentialNumberString(numberString) {
  const exponentialParts = numberString.split(/[eE]/);
  if (exponentialParts.length === 1) {
    return numberString;
  }
  const number = +numberString;
  if (Number.isSafeInteger(number)) {
    return `${number}`;
  }
  const isNegative = numberString.charAt(0) === "-";
  const magnitude = +exponentialParts[1];
  const decimalParts = exponentialParts[0].split(".");
  const integers = (isNegative ? decimalParts[0].substring(1) : decimalParts[0]) || "";
  const decimals = decimalParts[1] || "";
  const shiftDecimalLeft = (integers2, magnitude2) => {
    const magnitudeDelta = Math.abs(magnitude2) - integers2.length;
    const leftPaddedZeros = magnitudeDelta > 0 ? `${"0".repeat(magnitudeDelta)}${integers2}` : integers2;
    const shiftedDecimal = `${leftPaddedZeros.slice(0, magnitude2)}${"."}${leftPaddedZeros.slice(magnitude2)}`;
    return shiftedDecimal;
  };
  const shiftDecimalRight = (decimals2, magnitude2) => {
    const rightPaddedZeros = magnitude2 > decimals2.length ? `${decimals2}${"0".repeat(magnitude2 - decimals2.length)}` : decimals2;
    const shiftedDecimal = `${rightPaddedZeros.slice(0, magnitude2)}${"."}${rightPaddedZeros.slice(magnitude2)}`;
    return shiftedDecimal;
  };
  const expandedNumberString = magnitude > 0 ? `${integers}${shiftDecimalRight(decimals, magnitude)}` : `${shiftDecimalLeft(integers, magnitude)}${decimals}`;
  return `${isNegative ? "-" : ""}${expandedNumberString.charAt(0) === "." ? "0" : ""}${expandedNumberString.replace(unnecessaryDecimal, "").replace(allLeadingZerosOptionallyNegative, "")}`;
}
function stringContainsNumbers(string) {
  return _key_js__WEBPACK_IMPORTED_MODULE_0__.n.some((number) => string.includes(number));
}
function addLocalizedTrailingDecimalZeros(localizedValue, value, formatter) {
  const decimals = value.split(".")[1];
  if (decimals) {
    const trailingDecimalZeros = decimals.match(hasTrailingDecimalZeros)[0];
    if (trailingDecimalZeros && formatter.delocalize(localizedValue).length !== value.length && decimals.indexOf("e") === -1) {
      const decimalSeparator = formatter.decimal;
      localizedValue = !localizedValue.includes(decimalSeparator) ? `${localizedValue}${decimalSeparator}` : localizedValue;
      return localizedValue.padEnd(localizedValue.length + trailingDecimalZeros.length, formatter.localize("0"));
    }
  }
  return localizedValue;
}
const defaultLocale = "en";
const locales = [
  "ar",
  "bg",
  "bs",
  "ca",
  "cs",
  "da",
  "de",
  "de-AT",
  "de-CH",
  "el",
  defaultLocale,
  "en-AU",
  "en-CA",
  "en-GB",
  "es",
  "es-MX",
  "et",
  "fi",
  "fr",
  "fr-CH",
  "he",
  "hi",
  "hr",
  "hu",
  "id",
  "it",
  "it-CH",
  "ja",
  "ko",
  "lt",
  "lv",
  "mk",
  "no",
  "nl",
  "pl",
  "pt",
  "pt-PT",
  "ro",
  "ru",
  "sk",
  "sl",
  "sr",
  "sv",
  "th",
  "tr",
  "uk",
  "vi",
  "zh-CN",
  "zh-HK",
  "zh-TW"
];
const localizedTwentyFourHourMeridiems = new Map(
  Object.entries({
    bg: { am: "пр.об.", pm: "сл.об." },
    bs: { am: "prijepodne", pm: "popodne" },
    ca: { am: "a. m.", pm: "p. m." },
    cs: { am: "dop.", pm: "odp." },
    es: { am: "a. m.", pm: "p. m." },
    "es-mx": { am: "a.m.", pm: "p.m." },
    "es-MX": { am: "a.m.", pm: "p.m." },
    fi: { am: "ap.", pm: "ip." },
    he: { am: "לפנה״צ", pm: "אחה״צ" },
    hu: { am: "de. ", pm: "du." },
    lt: { am: "priešpiet", pm: "popiet" },
    lv: { am: "priekšpusdienā", pm: "pēcpusdienā" },
    mk: { am: "претпл.", pm: "попл." },
    no: { am: "a.m.", pm: "p.m." },
    nl: { am: "a.m.", pm: "p.m." },
    "pt-pt": { am: "da manhã", pm: "da tarde" },
    "pt-PT": { am: "da manhã", pm: "da tarde" },
    ro: { am: "a.m.", pm: "p.m." },
    sl: { am: "dop.", pm: "pop." },
    sv: { am: "fm", pm: "em" },
    th: { am: "ก่อนเที่ยง", pm: "หลังเที่ยง" },
    tr: { am: "ÖÖ", pm: "ÖS" },
    uk: { am: "дп", pm: "пп" },
    vi: { am: "SA", pm: "CH" }
  })
);
const numberingSystems = ["arab", "arabext", "latn"];
const supportedLocales = [...locales];
const isNumberingSystemSupported = (numberingSystem) => numberingSystems.includes(numberingSystem);
const browserNumberingSystem = new Intl.NumberFormat().resolvedOptions().numberingSystem;
const defaultNumberingSystem = browserNumberingSystem === "arab" || !isNumberingSystemSupported(browserNumberingSystem) ? "latn" : browserNumberingSystem;
const getSupportedNumberingSystem = (numberingSystem) => isNumberingSystemSupported(numberingSystem) ? numberingSystem : defaultNumberingSystem;
function getSupportedLocale(locale) {
  if (!locale) {
    return defaultLocale;
  }
  if (supportedLocales.includes(locale)) {
    return locale;
  }
  locale = locale.toLowerCase();
  if (locale.includes("-")) {
    locale = locale.replace(/(\w+)-(\w+)/, (_match, language, region) => `${language}-${region.toUpperCase()}`);
    if (!supportedLocales.includes(locale)) {
      locale = locale.split("-")[0];
    }
  }
  if (locale === "nb" || locale === "nn") {
    return "no";
  }
  if (locale === "zh") {
    return "zh-CN";
  }
  if (!supportedLocales.includes(locale)) {
    console.warn(
      `Translations for the "${locale}" locale are not available and will fall back to the default, English (en).`
    );
    return defaultLocale;
  }
  return locale;
}
function getDateFormatSupportedLocale(locale) {
  switch (locale) {
    case "it-CH":
      return "de-CH";
    case "bs":
      return "sr-Latn-CS";
    default:
      return locale;
  }
}
class NumberStringFormat {
  constructor() {
    this.delocalize = (numberString) => (
      // For performance, (de)localization is skipped if the formatter isn't initialized.
      // In order to localize/delocalize, e.g. when lang/numberingSystem props are not default values,
      // `numberFormatOptions` must be set in a component to create and cache the formatter.
      this._numberFormatOptions ? sanitizeExponentialNumberString(
        numberString,
        (nonExpoNumString) => nonExpoNumString.replace(new RegExp(`[${this._minusSign}]`, "g"), "-").replace(new RegExp(`[${this._group}]`, "g"), "").replace(new RegExp(`[${this._decimal}]`, "g"), ".").replace(new RegExp(`[${this._digits.join("")}]`, "g"), this._getDigitIndex)
      ) : numberString
    );
    this.localize = (numberString) => this._numberFormatOptions ? sanitizeExponentialNumberString(
      numberString,
      (nonExpoNumString) => isValidNumber(nonExpoNumString.trim()) ? new BigDecimal(nonExpoNumString.trim()).format(this).replace(new RegExp(`[${this._actualGroup}]`, "g"), this._group) : nonExpoNumString
    ) : numberString;
  }
  get group() {
    return this._group;
  }
  get decimal() {
    return this._decimal;
  }
  get minusSign() {
    return this._minusSign;
  }
  get digits() {
    return this._digits;
  }
  get numberFormatter() {
    return this._numberFormatter;
  }
  get numberFormatOptions() {
    return this._numberFormatOptions;
  }
  /** numberFormatOptions needs to be set before localize/delocalize is called to ensure the options are up to date */
  set numberFormatOptions(options) {
    options.locale = getSupportedLocale(options?.locale);
    options.numberingSystem = getSupportedNumberingSystem(options?.numberingSystem);
    if (
      // No need to create the formatter if `locale` and `numberingSystem`
      // are the default values and `numberFormatOptions` has not been set
      !this._numberFormatOptions && options.locale === defaultLocale && options.numberingSystem === defaultNumberingSystem && // don't skip initialization if any options besides locale/numberingSystem are set
      Object.keys(options).length === 2 || // cache formatter by only recreating when options change
      JSON.stringify(this._numberFormatOptions) === JSON.stringify(options)
    ) {
      return;
    }
    this._numberFormatOptions = options;
    this._numberFormatter = new Intl.NumberFormat(
      this._numberFormatOptions.locale,
      this._numberFormatOptions
    );
    this._digits = [
      ...new Intl.NumberFormat(this._numberFormatOptions.locale, {
        useGrouping: false,
        numberingSystem: this._numberFormatOptions.numberingSystem
      }).format(9876543210)
    ].reverse();
    const index = new Map(this._digits.map((d, i) => [d, i]));
    const parts = new Intl.NumberFormat(this._numberFormatOptions.locale, {
      numberingSystem: this._numberFormatOptions.numberingSystem
    }).formatToParts(-123456789e-1);
    this._actualGroup = parts.find((d) => d.type === "group").value;
    this._group = this._actualGroup.trim().length === 0 || this._actualGroup == " " ? " " : this._actualGroup;
    this._decimal = options.locale === "bs" || options.locale === "mk" ? "," : parts.find((d) => d.type === "decimal").value;
    this._minusSign = parts.find((d) => d.type === "minusSign").value;
    this._getDigitIndex = (d) => index.get(d);
  }
}
const numberStringFormatter = new NumberStringFormat();
let dateTimeFormatCache;
let previousLocaleUsedForCaching;
function buildDateTimeFormatCacheKey(options = {}) {
  return Object.entries(options).sort(([key1], [key2]) => key1.localeCompare(key2)).map((keyValue) => `${keyValue[0]}-${keyValue[1]}`).flat().join(":");
}
function getDateTimeFormat(locale, options) {
  locale = getSupportedLocale(locale);
  if (!dateTimeFormatCache) {
    dateTimeFormatCache = /* @__PURE__ */ new Map();
  }
  if (previousLocaleUsedForCaching !== locale) {
    dateTimeFormatCache.clear();
    previousLocaleUsedForCaching = locale;
  }
  const key = buildDateTimeFormatCacheKey(options);
  const cached = dateTimeFormatCache.get(key);
  if (cached) {
    return cached;
  }
  const format = new Intl.DateTimeFormat(locale, options);
  dateTimeFormatCache.set(key, format);
  return format;
}



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/components/calcite-input-message/customElement.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/components/calcite-input-message/customElement.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InputMessage: () => (/* binding */ InputMessage)
/* harmony export */ });
/* harmony import */ var _chunks_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../chunks/runtime.js */ "./node_modules/@esri/calcite-components/dist/chunks/runtime.js");
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcgis/lumina */ "./node_modules/@arcgis/lumina/dist/index.js");
/* harmony import */ var _chunks_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../chunks/dom.js */ "./node_modules/@esri/calcite-components/dist/chunks/dom.js");
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */




const StatusIconDefaults = {
  valid: "check-circle",
  invalid: "exclamation-mark-triangle",
  idle: "information"
};
const styles = (0,lit__WEBPACK_IMPORTED_MODULE_1__.css)`:host{--calcite-internal-color-focus: var( --calcite-color-focus, var(--calcite-ui-focus-color, var(--calcite-color-brand)) )}:host{box-sizing:border-box;display:flex;block-size:auto;inline-size:100%;align-items:center;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-color-text-1);opacity:1;transition-property:background-color,block-size,border-color,box-shadow,color,inset-block-end,inset-block-start,inset-inline-end,inset-inline-start,inset-size,opacity,outline-color,transform;transition-duration:var(--calcite-animation-timing);transition-timing-function:ease-in-out;margin-block-start:var(--calcite-input-message-spacing, var(--calcite-input-message-spacing-value, var(--calcite-spacing-xxs)))}.calcite-input-message-icon{pointer-events:none;display:inline-flex;flex-shrink:0;transition-property:background-color,block-size,border-color,box-shadow,color,inset-block-end,inset-block-start,inset-inline-end,inset-inline-start,inset-size,opacity,outline-color,transform;transition-duration:var(--calcite-animation-timing);transition-timing-function:ease-in-out;margin-inline-end:var(--calcite-spacing-sm)}:host([status=invalid]) .calcite-input-message-icon{color:var(--calcite-input-message-icon-color, var(--calcite-icon-color, var(--calcite-color-status-danger)))}:host([status=valid]) .calcite-input-message-icon{color:var(--calcite-input-message-icon-color, var(--calcite-icon-color, var(--calcite-color-status-success)))}:host([status=idle]) .calcite-input-message-icon{color:var(--calcite-input-message-icon-color, var(--calcite-icon-color, var(--calcite-color-brand)))}:host([scale=s]){font-size:var(--calcite-font-size--3);line-height:.75rem}:host([scale=m]){font-size:var(--calcite-font-size--2);line-height:1rem}:host([scale=l]){font-size:var(--calcite-font-size--1);line-height:1rem}:host([hidden]){display:none}[hidden]{display:none}`;
const CSS = {
  inputMessageIcon: "calcite-input-message-icon"
};
class InputMessage extends _arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.LitElement {
  constructor() {
    super(...arguments);
    this.iconFlipRtl = false;
    this.scale = "m";
    this.status = "idle";
  }
  static {
    this.properties = { icon: [3, { converter: _arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.stringOrBoolean }, { reflect: true }], iconFlipRtl: [7, {}, { reflect: true, type: Boolean }], scale: [3, {}, { reflect: true }], status: [3, {}, { reflect: true }] };
  }
  static {
    this.styles = styles;
  }
  connectedCallback() {
    super.connectedCallback();
    this.requestedIcon = (0,_chunks_dom_js__WEBPACK_IMPORTED_MODULE_3__.v)(StatusIconDefaults, this.icon, this.status);
  }
  willUpdate(changes) {
    if (changes.has("status") && (this.hasUpdated || this.status !== "idle") || changes.has("icon")) {
      this.requestedIcon = (0,_chunks_dom_js__WEBPACK_IMPORTED_MODULE_3__.v)(StatusIconDefaults, this.icon, this.status);
    }
  }
  render() {
    const hidden = this.el.hidden;
    (0,_arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.setAttribute)(this.el, "calcite-hydrated-hidden", hidden);
    return (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)`${this.renderIcon(this.requestedIcon)}<slot></slot>`;
  }
  renderIcon(iconName) {
    if (iconName) {
      return (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)`<calcite-icon class=${(0,_arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.safeClassMap)(CSS.inputMessageIcon)} .flipRtl=${this.iconFlipRtl} .icon=${iconName} scale=s></calcite-icon>`;
    }
  }
}
(0,_chunks_runtime_js__WEBPACK_IMPORTED_MODULE_0__.c)("calcite-input-message", InputMessage);



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/components/calcite-input-message/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/components/calcite-input-message/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InputMessage: () => (/* reexport safe */ _customElement_js__WEBPACK_IMPORTED_MODULE_1__.InputMessage)
/* harmony export */ });
/* harmony import */ var _calcite_icon_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../calcite-icon/index.js */ "./node_modules/@esri/calcite-components/dist/components/calcite-icon/index.js");
/* harmony import */ var _customElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./customElement.js */ "./node_modules/@esri/calcite-components/dist/components/calcite-input-message/customElement.js");



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/components/calcite-progress/customElement.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/components/calcite-progress/customElement.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Progress: () => (/* binding */ Progress)
/* harmony export */ });
/* harmony import */ var _chunks_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../chunks/runtime.js */ "./node_modules/@esri/calcite-components/dist/chunks/runtime.js");
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcgis/lumina */ "./node_modules/@arcgis/lumina/dist/index.js");
/* harmony import */ var _chunks_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../chunks/dom.js */ "./node_modules/@esri/calcite-components/dist/chunks/dom.js");
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */




const styles = (0,lit__WEBPACK_IMPORTED_MODULE_1__.css)`:host{--calcite-internal-color-focus: var( --calcite-color-focus, var(--calcite-ui-focus-color, var(--calcite-color-brand)) )}:host{position:relative;display:block;inline-size:100%}.track,.bar{position:absolute;inset-block-start:0px;block-size:2px}.track{z-index:var(--calcite-z-index);inline-size:100%;overflow:hidden;background-color:var(--calcite-progress-background-color, var(--calcite-color-border-3))}.bar{z-index:var(--calcite-z-index);background-color:var(--calcite-progress-fill-color, var(--calcite-color-brand))}@media (forced-colors: active){.track{background-color:highlightText}.bar{background-color:linkText}}.indeterminate{inline-size:20%;animation:looping-progress-bar-ani calc(var(--calcite-internal-animation-timing-medium) / var(--calcite-internal-duration-factor) * 11 / var(--calcite-internal-duration-factor)) linear infinite}.indeterminate.calcite--rtl{animation-name:looping-progress-bar-ani-rtl}.reversed{animation-direction:reverse}.text{padding-inline:0px;padding-block:1rem 0px;text-align:center;font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-progress-text-color, var(--calcite-color-text-2))}@keyframes looping-progress-bar-ani{0%{transform:translate3d(-100%,0,0)}50%{inline-size:40%}to{transform:translate3d(600%,0,0)}}@keyframes looping-progress-bar-ani-rtl{0%{transform:translate3d(100%,0,0)}50%{inline-size:40%}to{transform:translate3d(-600%,0,0)}}:host([hidden]){display:none}[hidden]{display:none}`;
const CSS = {
  track: "track",
  bar: "bar",
  text: "text"
};
class Progress extends _arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.LitElement {
  constructor() {
    super(...arguments);
    this.reversed = false;
    this.type = "determinate";
    this.value = 0;
  }
  static {
    this.properties = { label: 1, reversed: [7, {}, { reflect: true, type: Boolean }], text: 1, type: [3, {}, { reflect: true }], value: [9, {}, { type: Number }] };
  }
  static {
    this.styles = styles;
  }
  render() {
    const isDeterminate = this.type === "determinate";
    const barStyles = isDeterminate ? { width: `${this.value}%` } : {};
    const dir = (0,_chunks_dom_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.el);
    return (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)`<div .ariaLabel=${this.label || this.text} .ariaValueMax=${isDeterminate ? "100" : void 0} .ariaValueMin=${isDeterminate ? "0" : void 0} .ariaValueNow=${isDeterminate ? this.value : void 0} role=progressbar><div class=${(0,_arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.safeClassMap)(CSS.track)}><div class=${(0,_arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.safeClassMap)({
      [CSS.bar]: true,
      indeterminate: this.type === "indeterminate",
      [_chunks_runtime_js__WEBPACK_IMPORTED_MODULE_0__.C.rtl]: dir === "rtl",
      reversed: this.reversed
    })} style=${(0,_arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.safeStyleMap)(barStyles)}></div></div>${this.text ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)`<div class=${(0,_arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.safeClassMap)(CSS.text)}>${this.text}</div>` : null}</div>`;
  }
}
(0,_chunks_runtime_js__WEBPACK_IMPORTED_MODULE_0__.c)("calcite-progress", Progress);



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/components/calcite-progress/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/components/calcite-progress/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Progress: () => (/* reexport safe */ _customElement_js__WEBPACK_IMPORTED_MODULE_0__.Progress)
/* harmony export */ });
/* harmony import */ var _customElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./customElement.js */ "./node_modules/@esri/calcite-components/dist/components/calcite-progress/customElement.js");


/***/ }),

/***/ "./node_modules/lit-html/development/directives/keyed.js":
/*!***************************************************************!*\
  !*** ./node_modules/lit-html/development/directives/keyed.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   keyed: () => (/* binding */ keyed)
/* harmony export */ });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-html.js */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var _directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../directive.js */ "./node_modules/lit-html/development/directive.js");
/* harmony import */ var _directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../directive-helpers.js */ "./node_modules/lit-html/development/directive-helpers.js");
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */



class Keyed extends _directive_js__WEBPACK_IMPORTED_MODULE_1__.Directive {
    constructor() {
        super(...arguments);
        this.key = _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.nothing;
    }
    render(k, v) {
        this.key = k;
        return v;
    }
    update(part, [k, v]) {
        if (k !== this.key) {
            // Clear the part before returning a value. The one-arg form of
            // setCommittedValue sets the value to a sentinel which forces a
            // commit the next render.
            (0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.setCommittedValue)(part);
            this.key = k;
        }
        return v;
    }
}
/**
 * Associates a renderable value with a unique key. When the key changes, the
 * previous DOM is removed and disposed before rendering the next value, even
 * if the value - such as a template - is the same.
 *
 * This is useful for forcing re-renders of stateful components, or working
 * with code that expects new data to generate new HTML elements, such as some
 * animation techniques.
 */
const keyed = (0,_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(Keyed);
//# sourceMappingURL=keyed.js.map

/***/ }),

/***/ "./node_modules/lit/directives/keyed.js":
/*!**********************************************!*\
  !*** ./node_modules/lit/directives/keyed.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   keyed: () => (/* reexport safe */ lit_html_directives_keyed_js__WEBPACK_IMPORTED_MODULE_0__.keyed)
/* harmony export */ });
/* harmony import */ var lit_html_directives_keyed_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directives/keyed.js */ "./node_modules/lit-html/development/directives/keyed.js");

//# sourceMappingURL=keyed.js.map


/***/ })

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZXNyaV9jYWxjaXRlLWNvbXBvbmVudHNfZGlzdF9jaHVua3NfSW50ZXJuYWxMYWJlbF9qcy1ub2RlX21vZHVsZXNfZXNyaV9jLTFiZDE4MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ3lDO0FBQ0s7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUhBQXlILEtBQUssOENBQUksY0FBYyw0REFBWTtBQUNyTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsU0FBUyxRQUFRLGNBQWMsNERBQVksV0FBVyxHQUFHLFVBQVUsRUFBRSxZQUFZLDhDQUFJLGdDQUFnQyw0REFBWSx5QkFBeUIsUUFBUSxlQUFlLDZDQUFPLENBQUMsaUJBQWlCO0FBRzVNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QkY7QUFDQTtBQUNBO0FBQzRDO0FBQ0g7QUFDSztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOENBQThDLEtBQUssOENBQUksY0FBYyw0REFBWSwyQkFBMkIsRUFBRSwwREFBRyxzQ0FBc0MsaURBQWlELE1BQU0sS0FBSyxNQUFNLDZDQUFPLEVBQUUsU0FBUyxPQUFPLFVBQVUsT0FBTyxHQUFHLFFBQVE7QUFHbFM7Ozs7Ozs7Ozs7Ozs7OztBQ2ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0MsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTs7Ozs7Ozs7Ozs7Ozs7OztBQy9CRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNW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QUFPLGlEQUFXO0FBQ2xCO0FBQ0EsS0FBSyxHQUFHLFFBQVEsNERBQVksWUFBWSxlQUFlLFlBQVkseUNBQUksY0FBYyw0REFBWSxXQUFXLEdBQUcsVUFBVSxlQUFlO0FBQ3hJO0FBQ0E7QUFDQSxxREFBYTtBQUdYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6Q0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5QztBQUNlO0FBQ0k7QUFDNUQsb0JBQW9CLG9EQUFTO0FBQzdCO0FBQ0E7QUFDQSxtQkFBbUIsaURBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdFQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sY0FBYyx3REFBUztBQUM5QixpQzs7Ozs7Ozs7Ozs7Ozs7O0FDdEMwQztBQUMxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2NodW5rcy9JbnRlcm5hbExhYmVsLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2NodW5rcy9WYWxpZGF0aW9uLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2NodW5rcy9pbnB1dC5qcyIsIndlYnBhY2s6Ly9wcmVjaXNpb25mYXJtcy8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jaHVua3Mva2V5LmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2NodW5rcy9sYWJlbC5qcyIsIndlYnBhY2s6Ly9wcmVjaXNpb25mYXJtcy8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jaHVua3MvbG9jYWxlLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2NvbXBvbmVudHMvY2FsY2l0ZS1pbnB1dC1tZXNzYWdlL2N1c3RvbUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Rpc3QvY29tcG9uZW50cy9jYWxjaXRlLWlucHV0LW1lc3NhZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Rpc3QvY29tcG9uZW50cy9jYWxjaXRlLXByb2dyZXNzL2N1c3RvbUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvZGV2ZWxvcG1lbnQvZGlyZWN0aXZlcy9rZXllZC5qcyIsIndlYnBhY2s6Ly9wcmVjaXNpb25mYXJtcy8uL25vZGVfbW9kdWxlcy9saXQvZGlyZWN0aXZlcy9rZXllZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vYmxvYi9kZXYvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbnYzLjMuMyAqL1xuaW1wb3J0IHsgbm90aGluZywgaHRtbCB9IGZyb20gXCJsaXQtaHRtbFwiO1xuaW1wb3J0IHsgc2FmZUNsYXNzTWFwIH0gZnJvbSBcIkBhcmNnaXMvbHVtaW5hXCI7XG5jb25zdCBDU1MgPSB7XG4gIGFsaWdubWVudENlbnRlcjogXCJpbnRlcm5hbC1sYWJlbC1hbGlnbm1lbnQtLWNlbnRlclwiLFxuICBhbGlnbm1lbnRFbmQ6IFwiaW50ZXJuYWwtbGFiZWwtYWxpZ25tZW50LS1lbmRcIixcbiAgY29udGFpbmVyOiBcImludGVybmFsLWxhYmVsLS1jb250YWluZXJcIixcbiAgcmVxdWlyZWRJbmRpY2F0b3I6IFwiaW50ZXJuYWwtbGFiZWwtcmVxdWlyZWQtLWluZGljYXRvclwiLFxuICBzcGFjaW5nQm90dG9tOiBcImludGVybmFsLWxhYmVsLXNwYWNpbmctLWJvdHRvbVwiLFxuICBzcGFjaW5nSW5saW5lRW5kOiBcImludGVybmFsLWxhYmVsLXNwYWNpbmctaW5saW5lLS1lbmRcIixcbiAgc3BhY2luZ0lubGluZVN0YXJ0OiBcImludGVybmFsLWxhYmVsLXNwYWNpbmctaW5saW5lLS1zdGFydFwiLFxuICB0ZXh0OiBcImludGVybmFsLWxhYmVsLS10ZXh0XCJcbn07XG5jb25zdCBJbnRlcm5hbExhYmVsID0gKHsgYWxpZ25tZW50Q2VudGVyLCBib3R0b21TcGFjaW5nRGlzYWJsZWQsIGxhYmVsVGV4dCwgb25DbGljaywgcmVxdWlyZWQsIHNwYWNpbmdJbmxpbmVFbmQsIHNwYWNpbmdJbmxpbmVTdGFydCwgdG9vbHRpcFRleHQgfSkgPT4gaHRtbGA8ZGl2IGNsYXNzPSR7c2FmZUNsYXNzTWFwKHtcbiAgW0NTUy5hbGlnbm1lbnRDZW50ZXJdOiBhbGlnbm1lbnRDZW50ZXIsXG4gIFtDU1MuYWxpZ25tZW50RW5kXTogIWFsaWdubWVudENlbnRlcixcbiAgW0NTUy5jb250YWluZXJdOiB0cnVlLFxuICBbQ1NTLnNwYWNpbmdCb3R0b21dOiAhYm90dG9tU3BhY2luZ0Rpc2FibGVkLFxuICBbQ1NTLnNwYWNpbmdJbmxpbmVFbmRdOiBzcGFjaW5nSW5saW5lRW5kLFxuICBbQ1NTLnNwYWNpbmdJbmxpbmVTdGFydF06IHNwYWNpbmdJbmxpbmVTdGFydFxufSl9IEBjbGljaz0ke29uQ2xpY2t9PjxkaXYgY2xhc3M9JHtzYWZlQ2xhc3NNYXAoQ1NTLnRleHQpfT4ke2xhYmVsVGV4dH0ke3JlcXVpcmVkICYmIGh0bWxgPHNwYW4gYXJpYS1oaWRkZW49dHJ1ZSBjbGFzcz0ke3NhZmVDbGFzc01hcChDU1MucmVxdWlyZWRJbmRpY2F0b3IpfSB0aXRsZT0ke3Rvb2x0aXBUZXh0ID8/IG5vdGhpbmd9Pio8L3NwYW4+YCB8fCBcIlwifTwvZGl2PjxzbG90IG5hbWU9bGFiZWwtY29udGVudD48L3Nsb3Q+PC9kaXY+YDtcbmV4cG9ydCB7XG4gIEludGVybmFsTGFiZWwgYXMgSVxufTtcbiIsIi8qISBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL2Rldi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxudjMuMy4zICovXG5pbXBvcnQgeyByZWYgfSBmcm9tIFwibGl0L2RpcmVjdGl2ZXMvcmVmLmpzXCI7XG5pbXBvcnQgeyBub3RoaW5nLCBodG1sIH0gZnJvbSBcImxpdC1odG1sXCI7XG5pbXBvcnQgeyBzYWZlQ2xhc3NNYXAgfSBmcm9tIFwiQGFyY2dpcy9sdW1pbmFcIjtcbmNvbnN0IENTUyA9IHtcbiAgdmFsaWRhdGlvbkNvbnRhaW5lcjogXCJ2YWxpZGF0aW9uLWNvbnRhaW5lclwiXG59O1xuY29uc3QgdmFsaWRhdGlvblJlZmVyZW5jZSA9ICgpID0+IHtcbiAgcmV0dXJuO1xufTtcbmNvbnN0IFZhbGlkYXRpb24gPSAoeyBzY2FsZSwgc3RhdHVzLCBpZCwgaWNvbiwgbWVzc2FnZSwgcmVmOiByZWYkMSB9KSA9PiBodG1sYDxkaXYgY2xhc3M9JHtzYWZlQ2xhc3NNYXAoQ1NTLnZhbGlkYXRpb25Db250YWluZXIpfSAke3JlZihyZWYkMSA/IHJlZiQxIDogdmFsaWRhdGlvblJlZmVyZW5jZSl9PjxjYWxjaXRlLWlucHV0LW1lc3NhZ2UgYXJpYS1saXZlPXBvbGl0ZSAuaWNvbj0ke2ljb259IGlkPSR7aWQgPz8gbm90aGluZ30gLnNjYWxlPSR7c2NhbGV9IC5zdGF0dXM9JHtzdGF0dXN9PiR7bWVzc2FnZX08L2NhbGNpdGUtaW5wdXQtbWVzc2FnZT48L2Rpdj5gO1xuZXhwb3J0IHtcbiAgVmFsaWRhdGlvbiBhcyBWXG59O1xuIiwiLyohIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2Jsb2IvZGV2L0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG52My4zLjMgKi9cbmNvbnN0IG1pbk1heFN0ZXBUeXBlcyA9IFtcImRhdGVcIiwgXCJkYXRldGltZS1sb2NhbFwiLCBcIm1vbnRoXCIsIFwibnVtYmVyXCIsIFwicmFuZ2VcIiwgXCJ0aW1lXCIsIFwid2Vla1wiXTtcbmNvbnN0IHBhdHRlcm5UeXBlcyA9IFtcImVtYWlsXCIsIFwicGFzc3dvcmRcIiwgXCJzZWFyY2hcIiwgXCJ0ZWxcIiwgXCJ0ZXh0XCIsIFwidXJsXCJdO1xuY29uc3QgbWluTWF4TGVuZ3RoVHlwZXMgPSBbXCJlbWFpbFwiLCBcInBhc3N3b3JkXCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidGV4dFwiLCBcInRleHRhcmVhXCIsIFwidXJsXCJdO1xuZnVuY3Rpb24gdXBkYXRlQ29uc3RyYWludFZhbGlkYXRpb24oaW5wdXRDb21wb25lbnQsIGlucHV0LCBwcm9wTmFtZSwgbWF0Y2hlc1R5cGUpIHtcbiAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHZhbHVlID0gaW5wdXRDb21wb25lbnRbcHJvcE5hbWVdO1xuICBpZiAobWF0Y2hlc1R5cGUgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBgJHt2YWx1ZX1gKTtcbiAgfSBlbHNlIHtcbiAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN5bmNIaWRkZW5Gb3JtSW5wdXQodHlwZSwgaW5wdXRDb21wb25lbnQsIGhpZGRlbkZvcm1JbnB1dCkge1xuICBoaWRkZW5Gb3JtSW5wdXQudHlwZSA9IHR5cGUgPT09IFwidGV4dGFyZWFcIiA/IFwidGV4dFwiIDogdHlwZTtcbiAgY29uc3QgaXNNaW5NYXhTdGVwVHlwZSA9IG1pbk1heFN0ZXBUeXBlcy5pbmNsdWRlcyh0eXBlKTtcbiAgY29uc3QgbnVtZXJpY0lucHV0Q29tcG9uZW50ID0gaW5wdXRDb21wb25lbnQ7XG4gIHVwZGF0ZUNvbnN0cmFpbnRWYWxpZGF0aW9uKG51bWVyaWNJbnB1dENvbXBvbmVudCwgaGlkZGVuRm9ybUlucHV0LCBcIm1pblwiLCBpc01pbk1heFN0ZXBUeXBlKTtcbiAgdXBkYXRlQ29uc3RyYWludFZhbGlkYXRpb24obnVtZXJpY0lucHV0Q29tcG9uZW50LCBoaWRkZW5Gb3JtSW5wdXQsIFwibWF4XCIsIGlzTWluTWF4U3RlcFR5cGUpO1xuICB1cGRhdGVDb25zdHJhaW50VmFsaWRhdGlvbihudW1lcmljSW5wdXRDb21wb25lbnQsIGhpZGRlbkZvcm1JbnB1dCwgXCJzdGVwXCIsIGlzTWluTWF4U3RlcFR5cGUpO1xuICBjb25zdCBpc01pbk1heExlbmd0aFR5cGUgPSBtaW5NYXhMZW5ndGhUeXBlcy5pbmNsdWRlcyh0eXBlKTtcbiAgY29uc3QgdGV4dHVhbElucHV0Q29tcG9uZW50ID0gaW5wdXRDb21wb25lbnQ7XG4gIHVwZGF0ZUNvbnN0cmFpbnRWYWxpZGF0aW9uKHRleHR1YWxJbnB1dENvbXBvbmVudCwgaGlkZGVuRm9ybUlucHV0LCBcIm1pbkxlbmd0aFwiLCBpc01pbk1heExlbmd0aFR5cGUpO1xuICB1cGRhdGVDb25zdHJhaW50VmFsaWRhdGlvbih0ZXh0dWFsSW5wdXRDb21wb25lbnQsIGhpZGRlbkZvcm1JbnB1dCwgXCJtYXhMZW5ndGhcIiwgaXNNaW5NYXhMZW5ndGhUeXBlKTtcbiAgY29uc3QgaXNQYXR0ZXJuVHlwZSA9IHBhdHRlcm5UeXBlcy5pbmNsdWRlcyh0eXBlKTtcbiAgdXBkYXRlQ29uc3RyYWludFZhbGlkYXRpb24odGV4dHVhbElucHV0Q29tcG9uZW50LCBoaWRkZW5Gb3JtSW5wdXQsIFwicGF0dGVyblwiLCBpc1BhdHRlcm5UeXBlKTtcbn1cbmV4cG9ydCB7XG4gIHN5bmNIaWRkZW5Gb3JtSW5wdXQgYXMgc1xufTtcbiIsIi8qISBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL2Rldi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxudjMuMy4zICovXG5mdW5jdGlvbiBpc0FjdGl2YXRpb25LZXkoa2V5KSB7XG4gIHJldHVybiBrZXkgPT09IFwiRW50ZXJcIiB8fCBrZXkgPT09IFwiIFwiO1xufVxuY29uc3QgbnVtYmVyS2V5cyA9IFtcIjBcIiwgXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIl07XG5leHBvcnQge1xuICBpc0FjdGl2YXRpb25LZXkgYXMgaSxcbiAgbnVtYmVyS2V5cyBhcyBuXG59O1xuIiwiLyohIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2Jsb2IvZGV2L0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG52My4zLjMgKi9cbmltcG9ydCB7IHEgYXMgcXVlcnlFbGVtZW50Um9vdHMsIGwgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5LCBtIGFzIGlzQmVmb3JlIH0gZnJvbSBcIi4vZG9tLmpzXCI7XG5jb25zdCBsYWJlbENsaWNrRXZlbnQgPSBcImNhbGNpdGVJbnRlcm5hbExhYmVsQ2xpY2tcIjtcbmNvbnN0IGxhYmVsQ29ubmVjdGVkRXZlbnQgPSBcImNhbGNpdGVJbnRlcm5hbExhYmVsQ29ubmVjdGVkXCI7XG5jb25zdCBsYWJlbERpc2Nvbm5lY3RlZEV2ZW50ID0gXCJjYWxjaXRlSW50ZXJuYWxMYWJlbERpc2Nvbm5lY3RlZFwiO1xuY29uc3QgbGFiZWxUYWdOYW1lID0gXCJjYWxjaXRlLWxhYmVsXCI7XG5jb25zdCBsYWJlbFRvTGFiZWxhYmxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgb25MYWJlbENsaWNrTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBvbkxhYmVsQ29ubmVjdGVkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBvbkxhYmVsRGlzY29ubmVjdGVkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCB1bmxhYmVsZWRDb21wb25lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmNvbnN0IGZpbmRMYWJlbEZvckNvbXBvbmVudCA9IChjb21wb25lbnRFbCkgPT4ge1xuICBjb25zdCB7IGlkIH0gPSBjb21wb25lbnRFbDtcbiAgY29uc3QgZm9yTGFiZWwgPSBpZCAmJiBxdWVyeUVsZW1lbnRSb290cyhjb21wb25lbnRFbCwgeyBzZWxlY3RvcjogYCR7bGFiZWxUYWdOYW1lfVtmb3I9XCIke2lkfVwiXWAgfSk7XG4gIGlmIChmb3JMYWJlbCkge1xuICAgIHJldHVybiBmb3JMYWJlbDtcbiAgfVxuICBjb25zdCBwYXJlbnRMYWJlbCA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShjb21wb25lbnRFbCwgbGFiZWxUYWdOYW1lKTtcbiAgaWYgKCFwYXJlbnRMYWJlbCB8fCAvLyBsYWJlbGFibGUgY29tcG9uZW50cyB3aXRoaW4gb3RoZXIgY3VzdG9tIGVsZW1lbnRzIGFyZSBub3QgY29uc2lkZXJlZCBsYWJlbGFibGVcbiAgaGFzQW5jZXN0b3JDdXN0b21FbGVtZW50cyhwYXJlbnRMYWJlbCwgY29tcG9uZW50RWwpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhcmVudExhYmVsO1xufTtcbmZ1bmN0aW9uIGhhc0FuY2VzdG9yQ3VzdG9tRWxlbWVudHMobGFiZWwsIGNvbXBvbmVudEVsKSB7XG4gIGxldCB0cmF2ZXJzZWRFbGVtZW50cztcbiAgY29uc3QgY3VzdG9tRWxlbWVudEFuY2VzdG9yQ2hlY2tFdmVudFR5cGUgPSBcImN1c3RvbS1lbGVtZW50LWFuY2VzdG9yLWNoZWNrXCI7XG4gIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgY29uc3QgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgdHJhdmVyc2VkRWxlbWVudHMgPSBjb21wb3NlZFBhdGguc2xpY2UoY29tcG9zZWRQYXRoLmluZGV4T2YoY29tcG9uZW50RWwpLCBjb21wb3NlZFBhdGguaW5kZXhPZihsYWJlbCkpO1xuICB9O1xuICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKGN1c3RvbUVsZW1lbnRBbmNlc3RvckNoZWNrRXZlbnRUeXBlLCBsaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICBjb21wb25lbnRFbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChjdXN0b21FbGVtZW50QW5jZXN0b3JDaGVja0V2ZW50VHlwZSwgeyBjb21wb3NlZDogdHJ1ZSwgYnViYmxlczogdHJ1ZSB9KSk7XG4gIGxhYmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoY3VzdG9tRWxlbWVudEFuY2VzdG9yQ2hlY2tFdmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgY29uc3QgYW5jZXN0b3JDdXN0b21FbGVtZW50cyA9IHRyYXZlcnNlZEVsZW1lbnRzLmZpbHRlcigoZWwpID0+IGVsICE9PSBjb21wb25lbnRFbCAmJiBlbCAhPT0gbGFiZWwpLmZpbHRlcigoZWwpID0+IGVsLnRhZ05hbWU/LmluY2x1ZGVzKFwiLVwiKSk7XG4gIHJldHVybiBhbmNlc3RvckN1c3RvbUVsZW1lbnRzLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiBjb25uZWN0TGFiZWwoY29tcG9uZW50KSB7XG4gIGlmICghY29tcG9uZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxhYmVsRWwgPSBmaW5kTGFiZWxGb3JDb21wb25lbnQoY29tcG9uZW50LmVsKTtcbiAgaWYgKG9uTGFiZWxDbGlja01hcC5oYXMobGFiZWxFbCkgJiYgbGFiZWxFbCA9PT0gY29tcG9uZW50LmxhYmVsRWwgfHwgIWxhYmVsRWwgJiYgdW5sYWJlbGVkQ29tcG9uZW50cy5oYXMoY29tcG9uZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBib3VuZE9uTGFiZWxEaXNjb25uZWN0ZWQgPSBvbkxhYmVsRGlzY29ubmVjdGVkLmJpbmQoY29tcG9uZW50KTtcbiAgaWYgKGxhYmVsRWwpIHtcbiAgICBjb21wb25lbnQubGFiZWxFbCA9IGxhYmVsRWw7XG4gICAgY29uc3QgbGFiZWxhYmxlcyA9IGxhYmVsVG9MYWJlbGFibGVzLmdldChsYWJlbEVsKSB8fCBbXTtcbiAgICBsYWJlbGFibGVzLnB1c2goY29tcG9uZW50KTtcbiAgICBsYWJlbFRvTGFiZWxhYmxlcy5zZXQobGFiZWxFbCwgbGFiZWxhYmxlcy5zb3J0KHNvcnRCeURPTU9yZGVyKSk7XG4gICAgaWYgKCFvbkxhYmVsQ2xpY2tNYXAuaGFzKGNvbXBvbmVudC5sYWJlbEVsKSkge1xuICAgICAgb25MYWJlbENsaWNrTWFwLnNldChjb21wb25lbnQubGFiZWxFbCwgb25MYWJlbENsaWNrKTtcbiAgICAgIGNvbXBvbmVudC5sYWJlbEVsLmFkZEV2ZW50TGlzdGVuZXIobGFiZWxDbGlja0V2ZW50LCBvbkxhYmVsQ2xpY2spO1xuICAgIH1cbiAgICB1bmxhYmVsZWRDb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIobGFiZWxDb25uZWN0ZWRFdmVudCwgb25MYWJlbENvbm5lY3RlZE1hcC5nZXQoY29tcG9uZW50KSk7XG4gICAgb25MYWJlbERpc2Nvbm5lY3RlZE1hcC5zZXQoY29tcG9uZW50LCBib3VuZE9uTGFiZWxEaXNjb25uZWN0ZWQpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobGFiZWxEaXNjb25uZWN0ZWRFdmVudCwgYm91bmRPbkxhYmVsRGlzY29ubmVjdGVkKTtcbiAgfSBlbHNlIGlmICghdW5sYWJlbGVkQ29tcG9uZW50cy5oYXMoY29tcG9uZW50KSkge1xuICAgIGJvdW5kT25MYWJlbERpc2Nvbm5lY3RlZCgpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIobGFiZWxEaXNjb25uZWN0ZWRFdmVudCwgb25MYWJlbERpc2Nvbm5lY3RlZE1hcC5nZXQoY29tcG9uZW50KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc2Nvbm5lY3RMYWJlbChjb21wb25lbnQpIHtcbiAgaWYgKCFjb21wb25lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdW5sYWJlbGVkQ29tcG9uZW50cy5kZWxldGUoY29tcG9uZW50KTtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihsYWJlbENvbm5lY3RlZEV2ZW50LCBvbkxhYmVsQ29ubmVjdGVkTWFwLmdldChjb21wb25lbnQpKTtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihsYWJlbERpc2Nvbm5lY3RlZEV2ZW50LCBvbkxhYmVsRGlzY29ubmVjdGVkTWFwLmdldChjb21wb25lbnQpKTtcbiAgb25MYWJlbENvbm5lY3RlZE1hcC5kZWxldGUoY29tcG9uZW50KTtcbiAgb25MYWJlbERpc2Nvbm5lY3RlZE1hcC5kZWxldGUoY29tcG9uZW50KTtcbiAgaWYgKCFjb21wb25lbnQubGFiZWxFbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsYWJlbGFibGVzID0gbGFiZWxUb0xhYmVsYWJsZXMuZ2V0KGNvbXBvbmVudC5sYWJlbEVsKTtcbiAgaWYgKGxhYmVsYWJsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgY29tcG9uZW50LmxhYmVsRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihsYWJlbENsaWNrRXZlbnQsIG9uTGFiZWxDbGlja01hcC5nZXQoY29tcG9uZW50LmxhYmVsRWwpKTtcbiAgICBvbkxhYmVsQ2xpY2tNYXAuZGVsZXRlKGNvbXBvbmVudC5sYWJlbEVsKTtcbiAgfVxuICBsYWJlbFRvTGFiZWxhYmxlcy5zZXQoXG4gICAgY29tcG9uZW50LmxhYmVsRWwsXG4gICAgbGFiZWxhYmxlcy5maWx0ZXIoKGxhYmVsYWJsZSkgPT4gbGFiZWxhYmxlICE9PSBjb21wb25lbnQpLnNvcnQoc29ydEJ5RE9NT3JkZXIpXG4gICk7XG4gIGNvbXBvbmVudC5sYWJlbEVsID0gbnVsbDtcbn1cbmZ1bmN0aW9uIHNvcnRCeURPTU9yZGVyKGEsIGIpIHtcbiAgcmV0dXJuIGlzQmVmb3JlKGEuZWwsIGIuZWwpID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gZ2V0TGFiZWxUZXh0KGNvbXBvbmVudCkge1xuICByZXR1cm4gY29tcG9uZW50LmxhYmVsIHx8IGNvbXBvbmVudC5sYWJlbEVsPy50ZXh0Q29udGVudD8udHJpbSgpIHx8IFwiXCI7XG59XG5mdW5jdGlvbiBvbkxhYmVsQ2xpY2soZXZlbnQpIHtcbiAgY29uc3QgbGFiZWxDbGlja1RhcmdldCA9IGV2ZW50LmRldGFpbC5zb3VyY2VFdmVudC50YXJnZXQ7XG4gIGNvbnN0IGxhYmVsYWJsZXMgPSBsYWJlbFRvTGFiZWxhYmxlcy5nZXQodGhpcyk7XG4gIGNvbnN0IGNsaWNrZWRMYWJlbGFibGUgPSBsYWJlbGFibGVzLmZpbmQoKGxhYmVsYWJsZSkgPT4gbGFiZWxhYmxlLmVsID09PSBsYWJlbENsaWNrVGFyZ2V0KTtcbiAgY29uc3QgbGFiZWxhYmxlQ2hpbGRDbGlja2VkID0gbGFiZWxhYmxlcy5pbmNsdWRlcyhjbGlja2VkTGFiZWxhYmxlKTtcbiAgaWYgKGxhYmVsYWJsZUNoaWxkQ2xpY2tlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmaXJzdExhYmVsYWJsZSA9IGxhYmVsYWJsZXNbMF07XG4gIGlmIChmaXJzdExhYmVsYWJsZS5kaXNhYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmaXJzdExhYmVsYWJsZS5vbkxhYmVsQ2xpY2soZXZlbnQpO1xufVxuZnVuY3Rpb24gb25MYWJlbENvbm5lY3RlZCgpIHtcbiAgaWYgKHVubGFiZWxlZENvbXBvbmVudHMuaGFzKHRoaXMpKSB7XG4gICAgY29ubmVjdExhYmVsKHRoaXMpO1xuICB9XG59XG5mdW5jdGlvbiBvbkxhYmVsRGlzY29ubmVjdGVkKCkge1xuICB1bmxhYmVsZWRDb21wb25lbnRzLmFkZCh0aGlzKTtcbiAgY29uc3QgYm91bmRPbkxhYmVsQ29ubmVjdGVkID0gb25MYWJlbENvbm5lY3RlZE1hcC5nZXQodGhpcykgfHwgb25MYWJlbENvbm5lY3RlZC5iaW5kKHRoaXMpO1xuICBvbkxhYmVsQ29ubmVjdGVkTWFwLnNldCh0aGlzLCBib3VuZE9uTGFiZWxDb25uZWN0ZWQpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGxhYmVsQ29ubmVjdGVkRXZlbnQsIGJvdW5kT25MYWJlbENvbm5lY3RlZCk7XG59XG5hc3luYyBmdW5jdGlvbiBhc3NvY2lhdGVFeHBsaWNpdExhYmVsVG9VbmxhYmVsZWRDb21wb25lbnQobGFiZWwpIHtcbiAgYXdhaXQgbGFiZWwuY29tcG9uZW50T25SZWFkeSgpO1xuICBjb25zdCBhbHJlYWR5TGFiZWxlZCA9IGxhYmVsVG9MYWJlbGFibGVzLmhhcyhsYWJlbCk7XG4gIGlmIChhbHJlYWR5TGFiZWxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmb3JDb21wb25lbnRFbCA9IGxhYmVsLm93bmVyRG9jdW1lbnQ/LmdldEVsZW1lbnRCeUlkKGxhYmVsLmZvcik7XG4gIGlmICghZm9yQ29tcG9uZW50RWwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGxhYmVsYWJsZSBvZiB1bmxhYmVsZWRDb21wb25lbnRzKSB7XG4gICAgICBpZiAobGFiZWxhYmxlLmVsID09PSBmb3JDb21wb25lbnRFbCkge1xuICAgICAgICBjb25uZWN0TGFiZWwobGFiZWxhYmxlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydCB7XG4gIGFzc29jaWF0ZUV4cGxpY2l0TGFiZWxUb1VubGFiZWxlZENvbXBvbmVudCBhcyBhLFxuICBsYWJlbERpc2Nvbm5lY3RlZEV2ZW50IGFzIGIsXG4gIGNvbm5lY3RMYWJlbCBhcyBjLFxuICBkaXNjb25uZWN0TGFiZWwgYXMgZCxcbiAgZ2V0TGFiZWxUZXh0IGFzIGcsXG4gIGxhYmVsQ29ubmVjdGVkRXZlbnQgYXMgbFxufTtcbiIsIi8qISBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL2Rldi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxudjMuMy4zICovXG5pbXBvcnQgeyBuIGFzIG51bWJlcktleXMgfSBmcm9tIFwiLi9rZXkuanNcIjtcbmNvbnN0IHVubmVjZXNzYXJ5RGVjaW1hbCA9IG5ldyBSZWdFeHAoYFxcXFwke1wiLlwifSgwKyk/JGApO1xuY29uc3QgdHJhaWxpbmdaZXJvcyA9IG5ldyBSZWdFeHAoXCIwKyRcIik7XG5jbGFzcyBCaWdEZWNpbWFsIHtcbiAgc3RhdGljIHtcbiAgICB0aGlzLkRFQ0lNQUxTID0gMTAwO1xuICB9XG4gIHN0YXRpYyB7XG4gICAgdGhpcy5ST1VOREVEID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMuU0hJRlQgPSBCaWdJbnQoXCIxXCIgKyBcIjBcIi5yZXBlYXQodGhpcy5ERUNJTUFMUykpO1xuICB9XG4gIC8vIGRlcml2ZWQgY29uc3RhbnRcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBCaWdEZWNpbWFsKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGNvbnN0IFtpbnRlZ2VycywgZGVjaW1hbHNdID0gZXhwYW5kRXhwb25lbnRpYWxOdW1iZXJTdHJpbmcoaW5wdXQpLnNwbGl0KFwiLlwiKS5jb25jYXQoXCJcIik7XG4gICAgdGhpcy52YWx1ZSA9IEJpZ0ludChpbnRlZ2VycyArIGRlY2ltYWxzLnBhZEVuZChCaWdEZWNpbWFsLkRFQ0lNQUxTLCBcIjBcIikuc2xpY2UoMCwgQmlnRGVjaW1hbC5ERUNJTUFMUykpICsgQmlnSW50KEJpZ0RlY2ltYWwuUk9VTkRFRCAmJiBkZWNpbWFsc1tCaWdEZWNpbWFsLkRFQ0lNQUxTXSA+PSBcIjVcIik7XG4gICAgdGhpcy5pc05lZ2F0aXZlID0gaW5wdXQuY2hhckF0KDApID09PSBcIi1cIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMuX2RpdlJvdW5kID0gKGRpdmlkZW5kLCBkaXZpc29yKSA9PiBCaWdEZWNpbWFsLmZyb21CaWdJbnQoXG4gICAgICBkaXZpZGVuZCAvIGRpdmlzb3IgKyAoQmlnRGVjaW1hbC5ST1VOREVEID8gZGl2aWRlbmQgKiBCaWdJbnQoMikgLyBkaXZpc29yICUgQmlnSW50KDIpIDogQmlnSW50KDApKVxuICAgICk7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLmZyb21CaWdJbnQgPSAoYmlnaW50KSA9PiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoQmlnRGVjaW1hbC5wcm90b3R5cGUpLCB7IHZhbHVlOiBiaWdpbnQsIGlzTmVnYXRpdmU6IGJpZ2ludCA8IEJpZ0ludCgwKSB9KTtcbiAgfVxuICBnZXRJbnRlZ2Vyc0FuZERlY2ltYWxzKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZShcIi1cIiwgXCJcIikucGFkU3RhcnQoQmlnRGVjaW1hbC5ERUNJTUFMUyArIDEsIFwiMFwiKTtcbiAgICBjb25zdCBpbnRlZ2VycyA9IHMuc2xpY2UoMCwgLUJpZ0RlY2ltYWwuREVDSU1BTFMpO1xuICAgIGNvbnN0IGRlY2ltYWxzID0gcy5zbGljZSgtQmlnRGVjaW1hbC5ERUNJTUFMUykucmVwbGFjZSh0cmFpbGluZ1plcm9zLCBcIlwiKTtcbiAgICByZXR1cm4geyBpbnRlZ2VycywgZGVjaW1hbHMgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCB7IGludGVnZXJzLCBkZWNpbWFscyB9ID0gdGhpcy5nZXRJbnRlZ2Vyc0FuZERlY2ltYWxzKCk7XG4gICAgcmV0dXJuIGAke3RoaXMuaXNOZWdhdGl2ZSA/IFwiLVwiIDogXCJcIn0ke2ludGVnZXJzfSR7ZGVjaW1hbHMubGVuZ3RoID8gXCIuXCIgKyBkZWNpbWFscyA6IFwiXCJ9YDtcbiAgfVxuICBmb3JtYXRUb1BhcnRzKGZvcm1hdHRlcikge1xuICAgIGNvbnN0IHsgaW50ZWdlcnMsIGRlY2ltYWxzIH0gPSB0aGlzLmdldEludGVnZXJzQW5kRGVjaW1hbHMoKTtcbiAgICBjb25zdCBwYXJ0cyA9IGZvcm1hdHRlci5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhCaWdJbnQoaW50ZWdlcnMpKTtcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KHsgdHlwZTogXCJtaW51c1NpZ25cIiwgdmFsdWU6IGZvcm1hdHRlci5taW51c1NpZ24gfSk7XG4gICAgfVxuICAgIGlmIChkZWNpbWFscy5sZW5ndGgpIHtcbiAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiBcImRlY2ltYWxcIiwgdmFsdWU6IGZvcm1hdHRlci5kZWNpbWFsIH0pO1xuICAgICAgZGVjaW1hbHMuc3BsaXQoXCJcIikuZm9yRWFjaCgoY2hhcikgPT4gcGFydHMucHVzaCh7IHR5cGU6IFwiZnJhY3Rpb25cIiwgdmFsdWU6IGNoYXIgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cbiAgZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIGNvbnN0IHsgaW50ZWdlcnMsIGRlY2ltYWxzIH0gPSB0aGlzLmdldEludGVnZXJzQW5kRGVjaW1hbHMoKTtcbiAgICBjb25zdCBpbnRlZ2Vyc0Zvcm1hdHRlZCA9IGAke3RoaXMuaXNOZWdhdGl2ZSA/IGZvcm1hdHRlci5taW51c1NpZ24gOiBcIlwifSR7Zm9ybWF0dGVyLm51bWJlckZvcm1hdHRlci5mb3JtYXQoXG4gICAgICBCaWdJbnQoaW50ZWdlcnMpXG4gICAgKX1gO1xuICAgIGNvbnN0IGRlY2ltYWxzRm9ybWF0dGVkID0gZGVjaW1hbHMubGVuZ3RoID8gYCR7Zm9ybWF0dGVyLmRlY2ltYWx9JHtkZWNpbWFscy5zcGxpdChcIlwiKS5tYXAoKGNoYXIpID0+IGZvcm1hdHRlci5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0KE51bWJlcihjaGFyKSkpLmpvaW4oXCJcIil9YCA6IFwiXCI7XG4gICAgcmV0dXJuIGAke2ludGVnZXJzRm9ybWF0dGVkfSR7ZGVjaW1hbHNGb3JtYXR0ZWR9YDtcbiAgfVxuICBhZGQobikge1xuICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21CaWdJbnQodGhpcy52YWx1ZSArIG5ldyBCaWdEZWNpbWFsKG4pLnZhbHVlKTtcbiAgfVxuICBzdWJ0cmFjdChuKSB7XG4gICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbUJpZ0ludCh0aGlzLnZhbHVlIC0gbmV3IEJpZ0RlY2ltYWwobikudmFsdWUpO1xuICB9XG4gIG11bHRpcGx5KG4pIHtcbiAgICByZXR1cm4gQmlnRGVjaW1hbC5fZGl2Um91bmQodGhpcy52YWx1ZSAqIG5ldyBCaWdEZWNpbWFsKG4pLnZhbHVlLCBCaWdEZWNpbWFsLlNISUZUKTtcbiAgfVxuICBkaXZpZGUobikge1xuICAgIHJldHVybiBCaWdEZWNpbWFsLl9kaXZSb3VuZCh0aGlzLnZhbHVlICogQmlnRGVjaW1hbC5TSElGVCwgbmV3IEJpZ0RlY2ltYWwobikudmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkTnVtYmVyKG51bWJlclN0cmluZykge1xuICByZXR1cm4gISghbnVtYmVyU3RyaW5nIHx8IGlzTmFOKE51bWJlcihudW1iZXJTdHJpbmcpKSk7XG59XG5mdW5jdGlvbiBwYXJzZU51bWJlclN0cmluZyhudW1iZXJTdHJpbmcpIHtcbiAgaWYgKCFudW1iZXJTdHJpbmcgfHwgIXN0cmluZ0NvbnRhaW5zTnVtYmVycyhudW1iZXJTdHJpbmcpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIHNhbml0aXplRXhwb25lbnRpYWxOdW1iZXJTdHJpbmcobnVtYmVyU3RyaW5nLCAobm9uRXhwb051bVN0cmluZykgPT4ge1xuICAgIGxldCBjb250YWluc0RlY2ltYWwgPSBmYWxzZTtcbiAgICBjb25zdCByZXN1bHQgPSBub25FeHBvTnVtU3RyaW5nLnNwbGl0KFwiXCIpLmZpbHRlcigodmFsdWUsIGkpID0+IHtcbiAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXFwuL2cpICYmICFjb250YWluc0RlY2ltYWwpIHtcbiAgICAgICAgY29udGFpbnNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUubWF0Y2goLy0vZykgJiYgaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1iZXJLZXlzLmluY2x1ZGVzKHZhbHVlKTtcbiAgICB9KS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBpc1ZhbGlkTnVtYmVyKHJlc3VsdCkgPyBuZXcgQmlnRGVjaW1hbChyZXN1bHQpLnRvU3RyaW5nKCkgOiBcIlwiO1xuICB9KTtcbn1cbmNvbnN0IGFsbExlYWRpbmdaZXJvc09wdGlvbmFsbHlOZWdhdGl2ZSA9IC9eKFstMF0pMCsoPz1cXGQpLztcbmNvbnN0IGRlY2ltYWxPbmx5QXRFbmRPZlN0cmluZyA9IC8oPyFeXFwuKVxcLiQvO1xuY29uc3QgYWxsSHlwaGVuc0V4Y2VwdFRoZVN0YXJ0ID0gLyg/IV4tKS0vZztcbmNvbnN0IGlzTmVnYXRpdmVEZWNpbWFsT25seVplcm9zID0gL14tXFxiMFxcYlxcLj8wKiQvO1xuY29uc3QgaGFzVHJhaWxpbmdEZWNpbWFsWmVyb3MgPSAvMCokLztcbmNvbnN0IGNoYXJBbGxvd2xpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJlXCIsIFwiRVwiLCBcIi1cIiwgXCIsXCIsIFwiLlwiLCAuLi5udW1iZXJLZXlzXSk7XG5jb25zdCBzYW5pdGl6ZU51bWJlclN0cmluZyA9IChudW1iZXJTdHJpbmcpID0+IHtcbiAgY29uc3Qgc3RyaXBwZWRJbnZhbGlkQ2hhcnNWYWx1ZSA9IEFycmF5LmZyb20obnVtYmVyU3RyaW5nKS5maWx0ZXIoKGNoYXIpID0+IGNoYXJBbGxvd2xpc3QuaGFzKGNoYXIpKS5qb2luKFwiXCIpO1xuICByZXR1cm4gc2FuaXRpemVFeHBvbmVudGlhbE51bWJlclN0cmluZyhzdHJpcHBlZEludmFsaWRDaGFyc1ZhbHVlLCAobm9uRXhwb051bVN0cmluZykgPT4ge1xuICAgIGNvbnN0IHNhbml0aXplZFZhbHVlID0gbm9uRXhwb051bVN0cmluZy5yZXBsYWNlKGFsbEh5cGhlbnNFeGNlcHRUaGVTdGFydCwgXCJcIikucmVwbGFjZShkZWNpbWFsT25seUF0RW5kT2ZTdHJpbmcsIFwiXCIpLnJlcGxhY2UoYWxsTGVhZGluZ1plcm9zT3B0aW9uYWxseU5lZ2F0aXZlLCBcIiQxXCIpO1xuICAgIHJldHVybiBpc1ZhbGlkTnVtYmVyKHNhbml0aXplZFZhbHVlKSA/IGlzTmVnYXRpdmVEZWNpbWFsT25seVplcm9zLnRlc3Qoc2FuaXRpemVkVmFsdWUpID8gc2FuaXRpemVkVmFsdWUgOiBnZXRCaWdEZWNpbWFsQXNTdHJpbmcoc2FuaXRpemVkVmFsdWUpIDogbm9uRXhwb051bVN0cmluZztcbiAgfSk7XG59O1xuZnVuY3Rpb24gZ2V0QmlnRGVjaW1hbEFzU3RyaW5nKHNhbml0aXplZFZhbHVlKSB7XG4gIGNvbnN0IHNhbml0aXplZFZhbHVlRGVjaW1hbHMgPSBzYW5pdGl6ZWRWYWx1ZS5zcGxpdChcIi5cIilbMV07XG4gIGNvbnN0IHZhbHVlID0gbmV3IEJpZ0RlY2ltYWwoc2FuaXRpemVkVmFsdWUpLnRvU3RyaW5nKCk7XG4gIGNvbnN0IFtiaWdEZWNpbWFsVmFsdWVJbnRlZ2VyLCBiaWdEZWNpbWFsVmFsdWVEZWNpbWFsc10gPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gIHJldHVybiBzYW5pdGl6ZWRWYWx1ZURlY2ltYWxzICYmIGJpZ0RlY2ltYWxWYWx1ZURlY2ltYWxzICE9PSBzYW5pdGl6ZWRWYWx1ZURlY2ltYWxzID8gYCR7YmlnRGVjaW1hbFZhbHVlSW50ZWdlcn0uJHtzYW5pdGl6ZWRWYWx1ZURlY2ltYWxzfWAgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplRXhwb25lbnRpYWxOdW1iZXJTdHJpbmcobnVtYmVyU3RyaW5nLCBmdW5jKSB7XG4gIGlmICghbnVtYmVyU3RyaW5nKSB7XG4gICAgcmV0dXJuIG51bWJlclN0cmluZztcbiAgfVxuICBjb25zdCBmaXJzdEUgPSBudW1iZXJTdHJpbmcudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiZVwiKSArIDE7XG4gIGlmICghZmlyc3RFKSB7XG4gICAgcmV0dXJuIGZ1bmMobnVtYmVyU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gbnVtYmVyU3RyaW5nLnJlcGxhY2UoL1tlRV0qJC9nLCBcIlwiKS5zdWJzdHJpbmcoMCwgZmlyc3RFKS5jb25jYXQobnVtYmVyU3RyaW5nLnNsaWNlKGZpcnN0RSkucmVwbGFjZSgvW2VFXS9nLCBcIlwiKSkuc3BsaXQoL1tlRV0vKS5tYXAoKHNlY3Rpb24sIGkpID0+IGkgPT09IDEgPyBmdW5jKHNlY3Rpb24ucmVwbGFjZSgvXFwuL2csIFwiXCIpKSA6IGZ1bmMoc2VjdGlvbikpLmpvaW4oXCJlXCIpLnJlcGxhY2UoL15lLywgXCIxZVwiKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZEV4cG9uZW50aWFsTnVtYmVyU3RyaW5nKG51bWJlclN0cmluZykge1xuICBjb25zdCBleHBvbmVudGlhbFBhcnRzID0gbnVtYmVyU3RyaW5nLnNwbGl0KC9bZUVdLyk7XG4gIGlmIChleHBvbmVudGlhbFBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBudW1iZXJTdHJpbmc7XG4gIH1cbiAgY29uc3QgbnVtYmVyID0gK251bWJlclN0cmluZztcbiAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcikpIHtcbiAgICByZXR1cm4gYCR7bnVtYmVyfWA7XG4gIH1cbiAgY29uc3QgaXNOZWdhdGl2ZSA9IG51bWJlclN0cmluZy5jaGFyQXQoMCkgPT09IFwiLVwiO1xuICBjb25zdCBtYWduaXR1ZGUgPSArZXhwb25lbnRpYWxQYXJ0c1sxXTtcbiAgY29uc3QgZGVjaW1hbFBhcnRzID0gZXhwb25lbnRpYWxQYXJ0c1swXS5zcGxpdChcIi5cIik7XG4gIGNvbnN0IGludGVnZXJzID0gKGlzTmVnYXRpdmUgPyBkZWNpbWFsUGFydHNbMF0uc3Vic3RyaW5nKDEpIDogZGVjaW1hbFBhcnRzWzBdKSB8fCBcIlwiO1xuICBjb25zdCBkZWNpbWFscyA9IGRlY2ltYWxQYXJ0c1sxXSB8fCBcIlwiO1xuICBjb25zdCBzaGlmdERlY2ltYWxMZWZ0ID0gKGludGVnZXJzMiwgbWFnbml0dWRlMikgPT4ge1xuICAgIGNvbnN0IG1hZ25pdHVkZURlbHRhID0gTWF0aC5hYnMobWFnbml0dWRlMikgLSBpbnRlZ2VyczIubGVuZ3RoO1xuICAgIGNvbnN0IGxlZnRQYWRkZWRaZXJvcyA9IG1hZ25pdHVkZURlbHRhID4gMCA/IGAke1wiMFwiLnJlcGVhdChtYWduaXR1ZGVEZWx0YSl9JHtpbnRlZ2VyczJ9YCA6IGludGVnZXJzMjtcbiAgICBjb25zdCBzaGlmdGVkRGVjaW1hbCA9IGAke2xlZnRQYWRkZWRaZXJvcy5zbGljZSgwLCBtYWduaXR1ZGUyKX0ke1wiLlwifSR7bGVmdFBhZGRlZFplcm9zLnNsaWNlKG1hZ25pdHVkZTIpfWA7XG4gICAgcmV0dXJuIHNoaWZ0ZWREZWNpbWFsO1xuICB9O1xuICBjb25zdCBzaGlmdERlY2ltYWxSaWdodCA9IChkZWNpbWFsczIsIG1hZ25pdHVkZTIpID0+IHtcbiAgICBjb25zdCByaWdodFBhZGRlZFplcm9zID0gbWFnbml0dWRlMiA+IGRlY2ltYWxzMi5sZW5ndGggPyBgJHtkZWNpbWFsczJ9JHtcIjBcIi5yZXBlYXQobWFnbml0dWRlMiAtIGRlY2ltYWxzMi5sZW5ndGgpfWAgOiBkZWNpbWFsczI7XG4gICAgY29uc3Qgc2hpZnRlZERlY2ltYWwgPSBgJHtyaWdodFBhZGRlZFplcm9zLnNsaWNlKDAsIG1hZ25pdHVkZTIpfSR7XCIuXCJ9JHtyaWdodFBhZGRlZFplcm9zLnNsaWNlKG1hZ25pdHVkZTIpfWA7XG4gICAgcmV0dXJuIHNoaWZ0ZWREZWNpbWFsO1xuICB9O1xuICBjb25zdCBleHBhbmRlZE51bWJlclN0cmluZyA9IG1hZ25pdHVkZSA+IDAgPyBgJHtpbnRlZ2Vyc30ke3NoaWZ0RGVjaW1hbFJpZ2h0KGRlY2ltYWxzLCBtYWduaXR1ZGUpfWAgOiBgJHtzaGlmdERlY2ltYWxMZWZ0KGludGVnZXJzLCBtYWduaXR1ZGUpfSR7ZGVjaW1hbHN9YDtcbiAgcmV0dXJuIGAke2lzTmVnYXRpdmUgPyBcIi1cIiA6IFwiXCJ9JHtleHBhbmRlZE51bWJlclN0cmluZy5jaGFyQXQoMCkgPT09IFwiLlwiID8gXCIwXCIgOiBcIlwifSR7ZXhwYW5kZWROdW1iZXJTdHJpbmcucmVwbGFjZSh1bm5lY2Vzc2FyeURlY2ltYWwsIFwiXCIpLnJlcGxhY2UoYWxsTGVhZGluZ1plcm9zT3B0aW9uYWxseU5lZ2F0aXZlLCBcIlwiKX1gO1xufVxuZnVuY3Rpb24gc3RyaW5nQ29udGFpbnNOdW1iZXJzKHN0cmluZykge1xuICByZXR1cm4gbnVtYmVyS2V5cy5zb21lKChudW1iZXIpID0+IHN0cmluZy5pbmNsdWRlcyhudW1iZXIpKTtcbn1cbmZ1bmN0aW9uIGFkZExvY2FsaXplZFRyYWlsaW5nRGVjaW1hbFplcm9zKGxvY2FsaXplZFZhbHVlLCB2YWx1ZSwgZm9ybWF0dGVyKSB7XG4gIGNvbnN0IGRlY2ltYWxzID0gdmFsdWUuc3BsaXQoXCIuXCIpWzFdO1xuICBpZiAoZGVjaW1hbHMpIHtcbiAgICBjb25zdCB0cmFpbGluZ0RlY2ltYWxaZXJvcyA9IGRlY2ltYWxzLm1hdGNoKGhhc1RyYWlsaW5nRGVjaW1hbFplcm9zKVswXTtcbiAgICBpZiAodHJhaWxpbmdEZWNpbWFsWmVyb3MgJiYgZm9ybWF0dGVyLmRlbG9jYWxpemUobG9jYWxpemVkVmFsdWUpLmxlbmd0aCAhPT0gdmFsdWUubGVuZ3RoICYmIGRlY2ltYWxzLmluZGV4T2YoXCJlXCIpID09PSAtMSkge1xuICAgICAgY29uc3QgZGVjaW1hbFNlcGFyYXRvciA9IGZvcm1hdHRlci5kZWNpbWFsO1xuICAgICAgbG9jYWxpemVkVmFsdWUgPSAhbG9jYWxpemVkVmFsdWUuaW5jbHVkZXMoZGVjaW1hbFNlcGFyYXRvcikgPyBgJHtsb2NhbGl6ZWRWYWx1ZX0ke2RlY2ltYWxTZXBhcmF0b3J9YCA6IGxvY2FsaXplZFZhbHVlO1xuICAgICAgcmV0dXJuIGxvY2FsaXplZFZhbHVlLnBhZEVuZChsb2NhbGl6ZWRWYWx1ZS5sZW5ndGggKyB0cmFpbGluZ0RlY2ltYWxaZXJvcy5sZW5ndGgsIGZvcm1hdHRlci5sb2NhbGl6ZShcIjBcIikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG9jYWxpemVkVmFsdWU7XG59XG5jb25zdCBkZWZhdWx0TG9jYWxlID0gXCJlblwiO1xuY29uc3QgbG9jYWxlcyA9IFtcbiAgXCJhclwiLFxuICBcImJnXCIsXG4gIFwiYnNcIixcbiAgXCJjYVwiLFxuICBcImNzXCIsXG4gIFwiZGFcIixcbiAgXCJkZVwiLFxuICBcImRlLUFUXCIsXG4gIFwiZGUtQ0hcIixcbiAgXCJlbFwiLFxuICBkZWZhdWx0TG9jYWxlLFxuICBcImVuLUFVXCIsXG4gIFwiZW4tQ0FcIixcbiAgXCJlbi1HQlwiLFxuICBcImVzXCIsXG4gIFwiZXMtTVhcIixcbiAgXCJldFwiLFxuICBcImZpXCIsXG4gIFwiZnJcIixcbiAgXCJmci1DSFwiLFxuICBcImhlXCIsXG4gIFwiaGlcIixcbiAgXCJoclwiLFxuICBcImh1XCIsXG4gIFwiaWRcIixcbiAgXCJpdFwiLFxuICBcIml0LUNIXCIsXG4gIFwiamFcIixcbiAgXCJrb1wiLFxuICBcImx0XCIsXG4gIFwibHZcIixcbiAgXCJta1wiLFxuICBcIm5vXCIsXG4gIFwibmxcIixcbiAgXCJwbFwiLFxuICBcInB0XCIsXG4gIFwicHQtUFRcIixcbiAgXCJyb1wiLFxuICBcInJ1XCIsXG4gIFwic2tcIixcbiAgXCJzbFwiLFxuICBcInNyXCIsXG4gIFwic3ZcIixcbiAgXCJ0aFwiLFxuICBcInRyXCIsXG4gIFwidWtcIixcbiAgXCJ2aVwiLFxuICBcInpoLUNOXCIsXG4gIFwiemgtSEtcIixcbiAgXCJ6aC1UV1wiXG5dO1xuY29uc3QgbG9jYWxpemVkVHdlbnR5Rm91ckhvdXJNZXJpZGllbXMgPSBuZXcgTWFwKFxuICBPYmplY3QuZW50cmllcyh7XG4gICAgYmc6IHsgYW06IFwi0L/RgC7QvtCxLlwiLCBwbTogXCLRgdC7LtC+0LEuXCIgfSxcbiAgICBiczogeyBhbTogXCJwcmlqZXBvZG5lXCIsIHBtOiBcInBvcG9kbmVcIiB9LFxuICAgIGNhOiB7IGFtOiBcImEuwqBtLlwiLCBwbTogXCJwLsKgbS5cIiB9LFxuICAgIGNzOiB7IGFtOiBcImRvcC5cIiwgcG06IFwib2RwLlwiIH0sXG4gICAgZXM6IHsgYW06IFwiYS7CoG0uXCIsIHBtOiBcInAuwqBtLlwiIH0sXG4gICAgXCJlcy1teFwiOiB7IGFtOiBcImEubS5cIiwgcG06IFwicC5tLlwiIH0sXG4gICAgXCJlcy1NWFwiOiB7IGFtOiBcImEubS5cIiwgcG06IFwicC5tLlwiIH0sXG4gICAgZmk6IHsgYW06IFwiYXAuXCIsIHBtOiBcImlwLlwiIH0sXG4gICAgaGU6IHsgYW06IFwi15zXpNeg15TXtNemXCIsIHBtOiBcIteQ15fXlNe016ZcIiB9LFxuICAgIGh1OiB7IGFtOiBcImRlLiBcIiwgcG06IFwiZHUuXCIgfSxcbiAgICBsdDogeyBhbTogXCJwcmllxaFwaWV0XCIsIHBtOiBcInBvcGlldFwiIH0sXG4gICAgbHY6IHsgYW06IFwicHJpZWvFoXB1c2RpZW7EgVwiLCBwbTogXCJwxJNjcHVzZGllbsSBXCIgfSxcbiAgICBtazogeyBhbTogXCLQv9GA0LXRgtC/0LsuXCIsIHBtOiBcItC/0L7Qv9C7LlwiIH0sXG4gICAgbm86IHsgYW06IFwiYS5tLlwiLCBwbTogXCJwLm0uXCIgfSxcbiAgICBubDogeyBhbTogXCJhLm0uXCIsIHBtOiBcInAubS5cIiB9LFxuICAgIFwicHQtcHRcIjogeyBhbTogXCJkYSBtYW5ow6NcIiwgcG06IFwiZGEgdGFyZGVcIiB9LFxuICAgIFwicHQtUFRcIjogeyBhbTogXCJkYSBtYW5ow6NcIiwgcG06IFwiZGEgdGFyZGVcIiB9LFxuICAgIHJvOiB7IGFtOiBcImEubS5cIiwgcG06IFwicC5tLlwiIH0sXG4gICAgc2w6IHsgYW06IFwiZG9wLlwiLCBwbTogXCJwb3AuXCIgfSxcbiAgICBzdjogeyBhbTogXCJmbVwiLCBwbTogXCJlbVwiIH0sXG4gICAgdGg6IHsgYW06IFwi4LiB4LmI4Lit4LiZ4LmA4LiX4Li14LmI4Lii4LiHXCIsIHBtOiBcIuC4q+C4peC4seC4h+C5gOC4l+C4teC5iOC4ouC4h1wiIH0sXG4gICAgdHI6IHsgYW06IFwiw5bDllwiLCBwbTogXCLDllNcIiB9LFxuICAgIHVrOiB7IGFtOiBcItC00L9cIiwgcG06IFwi0L/Qv1wiIH0sXG4gICAgdmk6IHsgYW06IFwiU0FcIiwgcG06IFwiQ0hcIiB9XG4gIH0pXG4pO1xuY29uc3QgbnVtYmVyaW5nU3lzdGVtcyA9IFtcImFyYWJcIiwgXCJhcmFiZXh0XCIsIFwibGF0blwiXTtcbmNvbnN0IHN1cHBvcnRlZExvY2FsZXMgPSBbLi4ubG9jYWxlc107XG5jb25zdCBpc051bWJlcmluZ1N5c3RlbVN1cHBvcnRlZCA9IChudW1iZXJpbmdTeXN0ZW0pID0+IG51bWJlcmluZ1N5c3RlbXMuaW5jbHVkZXMobnVtYmVyaW5nU3lzdGVtKTtcbmNvbnN0IGJyb3dzZXJOdW1iZXJpbmdTeXN0ZW0gPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS5udW1iZXJpbmdTeXN0ZW07XG5jb25zdCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gYnJvd3Nlck51bWJlcmluZ1N5c3RlbSA9PT0gXCJhcmFiXCIgfHwgIWlzTnVtYmVyaW5nU3lzdGVtU3VwcG9ydGVkKGJyb3dzZXJOdW1iZXJpbmdTeXN0ZW0pID8gXCJsYXRuXCIgOiBicm93c2VyTnVtYmVyaW5nU3lzdGVtO1xuY29uc3QgZ2V0U3VwcG9ydGVkTnVtYmVyaW5nU3lzdGVtID0gKG51bWJlcmluZ1N5c3RlbSkgPT4gaXNOdW1iZXJpbmdTeXN0ZW1TdXBwb3J0ZWQobnVtYmVyaW5nU3lzdGVtKSA/IG51bWJlcmluZ1N5c3RlbSA6IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW07XG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRMb2NhbGUobG9jYWxlKSB7XG4gIGlmICghbG9jYWxlKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2NhbGU7XG4gIH1cbiAgaWYgKHN1cHBvcnRlZExvY2FsZXMuaW5jbHVkZXMobG9jYWxlKSkge1xuICAgIHJldHVybiBsb2NhbGU7XG4gIH1cbiAgbG9jYWxlID0gbG9jYWxlLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChsb2NhbGUuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgbG9jYWxlID0gbG9jYWxlLnJlcGxhY2UoLyhcXHcrKS0oXFx3KykvLCAoX21hdGNoLCBsYW5ndWFnZSwgcmVnaW9uKSA9PiBgJHtsYW5ndWFnZX0tJHtyZWdpb24udG9VcHBlckNhc2UoKX1gKTtcbiAgICBpZiAoIXN1cHBvcnRlZExvY2FsZXMuaW5jbHVkZXMobG9jYWxlKSkge1xuICAgICAgbG9jYWxlID0gbG9jYWxlLnNwbGl0KFwiLVwiKVswXTtcbiAgICB9XG4gIH1cbiAgaWYgKGxvY2FsZSA9PT0gXCJuYlwiIHx8IGxvY2FsZSA9PT0gXCJublwiKSB7XG4gICAgcmV0dXJuIFwibm9cIjtcbiAgfVxuICBpZiAobG9jYWxlID09PSBcInpoXCIpIHtcbiAgICByZXR1cm4gXCJ6aC1DTlwiO1xuICB9XG4gIGlmICghc3VwcG9ydGVkTG9jYWxlcy5pbmNsdWRlcyhsb2NhbGUpKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFRyYW5zbGF0aW9ucyBmb3IgdGhlIFwiJHtsb2NhbGV9XCIgbG9jYWxlIGFyZSBub3QgYXZhaWxhYmxlIGFuZCB3aWxsIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCwgRW5nbGlzaCAoZW4pLmBcbiAgICApO1xuICAgIHJldHVybiBkZWZhdWx0TG9jYWxlO1xuICB9XG4gIHJldHVybiBsb2NhbGU7XG59XG5mdW5jdGlvbiBnZXREYXRlRm9ybWF0U3VwcG9ydGVkTG9jYWxlKGxvY2FsZSkge1xuICBzd2l0Y2ggKGxvY2FsZSkge1xuICAgIGNhc2UgXCJpdC1DSFwiOlxuICAgICAgcmV0dXJuIFwiZGUtQ0hcIjtcbiAgICBjYXNlIFwiYnNcIjpcbiAgICAgIHJldHVybiBcInNyLUxhdG4tQ1NcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgfVxufVxuY2xhc3MgTnVtYmVyU3RyaW5nRm9ybWF0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kZWxvY2FsaXplID0gKG51bWJlclN0cmluZykgPT4gKFxuICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlLCAoZGUpbG9jYWxpemF0aW9uIGlzIHNraXBwZWQgaWYgdGhlIGZvcm1hdHRlciBpc24ndCBpbml0aWFsaXplZC5cbiAgICAgIC8vIEluIG9yZGVyIHRvIGxvY2FsaXplL2RlbG9jYWxpemUsIGUuZy4gd2hlbiBsYW5nL251bWJlcmluZ1N5c3RlbSBwcm9wcyBhcmUgbm90IGRlZmF1bHQgdmFsdWVzLFxuICAgICAgLy8gYG51bWJlckZvcm1hdE9wdGlvbnNgIG11c3QgYmUgc2V0IGluIGEgY29tcG9uZW50IHRvIGNyZWF0ZSBhbmQgY2FjaGUgdGhlIGZvcm1hdHRlci5cbiAgICAgIHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnMgPyBzYW5pdGl6ZUV4cG9uZW50aWFsTnVtYmVyU3RyaW5nKFxuICAgICAgICBudW1iZXJTdHJpbmcsXG4gICAgICAgIChub25FeHBvTnVtU3RyaW5nKSA9PiBub25FeHBvTnVtU3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChgWyR7dGhpcy5fbWludXNTaWdufV1gLCBcImdcIiksIFwiLVwiKS5yZXBsYWNlKG5ldyBSZWdFeHAoYFske3RoaXMuX2dyb3VwfV1gLCBcImdcIiksIFwiXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChgWyR7dGhpcy5fZGVjaW1hbH1dYCwgXCJnXCIpLCBcIi5cIikucmVwbGFjZShuZXcgUmVnRXhwKGBbJHt0aGlzLl9kaWdpdHMuam9pbihcIlwiKX1dYCwgXCJnXCIpLCB0aGlzLl9nZXREaWdpdEluZGV4KVxuICAgICAgKSA6IG51bWJlclN0cmluZ1xuICAgICk7XG4gICAgdGhpcy5sb2NhbGl6ZSA9IChudW1iZXJTdHJpbmcpID0+IHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnMgPyBzYW5pdGl6ZUV4cG9uZW50aWFsTnVtYmVyU3RyaW5nKFxuICAgICAgbnVtYmVyU3RyaW5nLFxuICAgICAgKG5vbkV4cG9OdW1TdHJpbmcpID0+IGlzVmFsaWROdW1iZXIobm9uRXhwb051bVN0cmluZy50cmltKCkpID8gbmV3IEJpZ0RlY2ltYWwobm9uRXhwb051bVN0cmluZy50cmltKCkpLmZvcm1hdCh0aGlzKS5yZXBsYWNlKG5ldyBSZWdFeHAoYFske3RoaXMuX2FjdHVhbEdyb3VwfV1gLCBcImdcIiksIHRoaXMuX2dyb3VwKSA6IG5vbkV4cG9OdW1TdHJpbmdcbiAgICApIDogbnVtYmVyU3RyaW5nO1xuICB9XG4gIGdldCBncm91cCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JvdXA7XG4gIH1cbiAgZ2V0IGRlY2ltYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlY2ltYWw7XG4gIH1cbiAgZ2V0IG1pbnVzU2lnbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWludXNTaWduO1xuICB9XG4gIGdldCBkaWdpdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpZ2l0cztcbiAgfVxuICBnZXQgbnVtYmVyRm9ybWF0dGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9udW1iZXJGb3JtYXR0ZXI7XG4gIH1cbiAgZ2V0IG51bWJlckZvcm1hdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnM7XG4gIH1cbiAgLyoqIG51bWJlckZvcm1hdE9wdGlvbnMgbmVlZHMgdG8gYmUgc2V0IGJlZm9yZSBsb2NhbGl6ZS9kZWxvY2FsaXplIGlzIGNhbGxlZCB0byBlbnN1cmUgdGhlIG9wdGlvbnMgYXJlIHVwIHRvIGRhdGUgKi9cbiAgc2V0IG51bWJlckZvcm1hdE9wdGlvbnMob3B0aW9ucykge1xuICAgIG9wdGlvbnMubG9jYWxlID0gZ2V0U3VwcG9ydGVkTG9jYWxlKG9wdGlvbnM/LmxvY2FsZSk7XG4gICAgb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gPSBnZXRTdXBwb3J0ZWROdW1iZXJpbmdTeXN0ZW0ob3B0aW9ucz8ubnVtYmVyaW5nU3lzdGVtKTtcbiAgICBpZiAoXG4gICAgICAvLyBObyBuZWVkIHRvIGNyZWF0ZSB0aGUgZm9ybWF0dGVyIGlmIGBsb2NhbGVgIGFuZCBgbnVtYmVyaW5nU3lzdGVtYFxuICAgICAgLy8gYXJlIHRoZSBkZWZhdWx0IHZhbHVlcyBhbmQgYG51bWJlckZvcm1hdE9wdGlvbnNgIGhhcyBub3QgYmVlbiBzZXRcbiAgICAgICF0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zICYmIG9wdGlvbnMubG9jYWxlID09PSBkZWZhdWx0TG9jYWxlICYmIG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtID09PSBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtICYmIC8vIGRvbid0IHNraXAgaW5pdGlhbGl6YXRpb24gaWYgYW55IG9wdGlvbnMgYmVzaWRlcyBsb2NhbGUvbnVtYmVyaW5nU3lzdGVtIGFyZSBzZXRcbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA9PT0gMiB8fCAvLyBjYWNoZSBmb3JtYXR0ZXIgYnkgb25seSByZWNyZWF0aW5nIHdoZW4gb3B0aW9ucyBjaGFuZ2VcbiAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnMpID09PSBKU09OLnN0cmluZ2lmeShvcHRpb25zKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9udW1iZXJGb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoXG4gICAgICB0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zLmxvY2FsZSxcbiAgICAgIHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnNcbiAgICApO1xuICAgIHRoaXMuX2RpZ2l0cyA9IFtcbiAgICAgIC4uLm5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zLmxvY2FsZSwge1xuICAgICAgICB1c2VHcm91cGluZzogZmFsc2UsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbTogdGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9ucy5udW1iZXJpbmdTeXN0ZW1cbiAgICAgIH0pLmZvcm1hdCg5ODc2NTQzMjEwKVxuICAgIF0ucmV2ZXJzZSgpO1xuICAgIGNvbnN0IGluZGV4ID0gbmV3IE1hcCh0aGlzLl9kaWdpdHMubWFwKChkLCBpKSA9PiBbZCwgaV0pKTtcbiAgICBjb25zdCBwYXJ0cyA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zLmxvY2FsZSwge1xuICAgICAgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zLm51bWJlcmluZ1N5c3RlbVxuICAgIH0pLmZvcm1hdFRvUGFydHMoLTEyMzQ1Njc4OWUtMSk7XG4gICAgdGhpcy5fYWN0dWFsR3JvdXAgPSBwYXJ0cy5maW5kKChkKSA9PiBkLnR5cGUgPT09IFwiZ3JvdXBcIikudmFsdWU7XG4gICAgdGhpcy5fZ3JvdXAgPSB0aGlzLl9hY3R1YWxHcm91cC50cmltKCkubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdHVhbEdyb3VwID09IFwiIFwiID8gXCLCoFwiIDogdGhpcy5fYWN0dWFsR3JvdXA7XG4gICAgdGhpcy5fZGVjaW1hbCA9IG9wdGlvbnMubG9jYWxlID09PSBcImJzXCIgfHwgb3B0aW9ucy5sb2NhbGUgPT09IFwibWtcIiA/IFwiLFwiIDogcGFydHMuZmluZCgoZCkgPT4gZC50eXBlID09PSBcImRlY2ltYWxcIikudmFsdWU7XG4gICAgdGhpcy5fbWludXNTaWduID0gcGFydHMuZmluZCgoZCkgPT4gZC50eXBlID09PSBcIm1pbnVzU2lnblwiKS52YWx1ZTtcbiAgICB0aGlzLl9nZXREaWdpdEluZGV4ID0gKGQpID0+IGluZGV4LmdldChkKTtcbiAgfVxufVxuY29uc3QgbnVtYmVyU3RyaW5nRm9ybWF0dGVyID0gbmV3IE51bWJlclN0cmluZ0Zvcm1hdCgpO1xubGV0IGRhdGVUaW1lRm9ybWF0Q2FjaGU7XG5sZXQgcHJldmlvdXNMb2NhbGVVc2VkRm9yQ2FjaGluZztcbmZ1bmN0aW9uIGJ1aWxkRGF0ZVRpbWVGb3JtYXRDYWNoZUtleShvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLnNvcnQoKFtrZXkxXSwgW2tleTJdKSA9PiBrZXkxLmxvY2FsZUNvbXBhcmUoa2V5MikpLm1hcCgoa2V5VmFsdWUpID0+IGAke2tleVZhbHVlWzBdfS0ke2tleVZhbHVlWzFdfWApLmZsYXQoKS5qb2luKFwiOlwiKTtcbn1cbmZ1bmN0aW9uIGdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykge1xuICBsb2NhbGUgPSBnZXRTdXBwb3J0ZWRMb2NhbGUobG9jYWxlKTtcbiAgaWYgKCFkYXRlVGltZUZvcm1hdENhY2hlKSB7XG4gICAgZGF0ZVRpbWVGb3JtYXRDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgaWYgKHByZXZpb3VzTG9jYWxlVXNlZEZvckNhY2hpbmcgIT09IGxvY2FsZSkge1xuICAgIGRhdGVUaW1lRm9ybWF0Q2FjaGUuY2xlYXIoKTtcbiAgICBwcmV2aW91c0xvY2FsZVVzZWRGb3JDYWNoaW5nID0gbG9jYWxlO1xuICB9XG4gIGNvbnN0IGtleSA9IGJ1aWxkRGF0ZVRpbWVGb3JtYXRDYWNoZUtleShvcHRpb25zKTtcbiAgY29uc3QgY2FjaGVkID0gZGF0ZVRpbWVGb3JtYXRDYWNoZS5nZXQoa2V5KTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgZm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgZGF0ZVRpbWVGb3JtYXRDYWNoZS5zZXQoa2V5LCBmb3JtYXQpO1xuICByZXR1cm4gZm9ybWF0O1xufVxuZXhwb3J0IHtcbiAgQmlnRGVjaW1hbCBhcyBCLFxuICBOdW1iZXJTdHJpbmdGb3JtYXQgYXMgTixcbiAgZ2V0U3VwcG9ydGVkTnVtYmVyaW5nU3lzdGVtIGFzIGEsXG4gIGdldFN1cHBvcnRlZExvY2FsZSBhcyBiLFxuICBhZGRMb2NhbGl6ZWRUcmFpbGluZ0RlY2ltYWxaZXJvcyBhcyBjLFxuICBnZXREYXRlRm9ybWF0U3VwcG9ydGVkTG9jYWxlIGFzIGQsXG4gIGdldERhdGVUaW1lRm9ybWF0IGFzIGcsXG4gIGlzVmFsaWROdW1iZXIgYXMgaSxcbiAgbG9jYWxpemVkVHdlbnR5Rm91ckhvdXJNZXJpZGllbXMgYXMgbCxcbiAgbnVtYmVyU3RyaW5nRm9ybWF0dGVyIGFzIG4sXG4gIHBhcnNlTnVtYmVyU3RyaW5nIGFzIHAsXG4gIHNhbml0aXplTnVtYmVyU3RyaW5nIGFzIHNcbn07XG4iLCIvKiEgQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vYmxvYi9kZXYvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbnYzLjMuMyAqL1xuaW1wb3J0IHsgYyBhcyBjdXN0b21FbGVtZW50IH0gZnJvbSBcIi4uLy4uL2NodW5rcy9ydW50aW1lLmpzXCI7XG5pbXBvcnQgeyBjc3MsIGh0bWwgfSBmcm9tIFwibGl0XCI7XG5pbXBvcnQgeyBMaXRFbGVtZW50LCBzdHJpbmdPckJvb2xlYW4sIHNldEF0dHJpYnV0ZSwgc2FmZUNsYXNzTWFwIH0gZnJvbSBcIkBhcmNnaXMvbHVtaW5hXCI7XG5pbXBvcnQgeyB2IGFzIHNldFJlcXVlc3RlZEljb24gfSBmcm9tIFwiLi4vLi4vY2h1bmtzL2RvbS5qc1wiO1xuY29uc3QgU3RhdHVzSWNvbkRlZmF1bHRzID0ge1xuICB2YWxpZDogXCJjaGVjay1jaXJjbGVcIixcbiAgaW52YWxpZDogXCJleGNsYW1hdGlvbi1tYXJrLXRyaWFuZ2xlXCIsXG4gIGlkbGU6IFwiaW5mb3JtYXRpb25cIlxufTtcbmNvbnN0IHN0eWxlcyA9IGNzc2A6aG9zdHstLWNhbGNpdGUtaW50ZXJuYWwtY29sb3ItZm9jdXM6IHZhciggLS1jYWxjaXRlLWNvbG9yLWZvY3VzLCB2YXIoLS1jYWxjaXRlLXVpLWZvY3VzLWNvbG9yLCB2YXIoLS1jYWxjaXRlLWNvbG9yLWJyYW5kKSkgKX06aG9zdHtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpmbGV4O2Jsb2NrLXNpemU6YXV0bztpbmxpbmUtc2l6ZToxMDAlO2FsaWduLWl0ZW1zOmNlbnRlcjtmb250LXdlaWdodDp2YXIoLS1jYWxjaXRlLWZvbnQtd2VpZ2h0LW1lZGl1bSk7Y29sb3I6dmFyKC0tY2FsY2l0ZS1jb2xvci10ZXh0LTEpO29wYWNpdHk6MTt0cmFuc2l0aW9uLXByb3BlcnR5OmJhY2tncm91bmQtY29sb3IsYmxvY2stc2l6ZSxib3JkZXItY29sb3IsYm94LXNoYWRvdyxjb2xvcixpbnNldC1ibG9jay1lbmQsaW5zZXQtYmxvY2stc3RhcnQsaW5zZXQtaW5saW5lLWVuZCxpbnNldC1pbmxpbmUtc3RhcnQsaW5zZXQtc2l6ZSxvcGFjaXR5LG91dGxpbmUtY29sb3IsdHJhbnNmb3JtO3RyYW5zaXRpb24tZHVyYXRpb246dmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLWluLW91dDttYXJnaW4tYmxvY2stc3RhcnQ6dmFyKC0tY2FsY2l0ZS1pbnB1dC1tZXNzYWdlLXNwYWNpbmcsIHZhcigtLWNhbGNpdGUtaW5wdXQtbWVzc2FnZS1zcGFjaW5nLXZhbHVlLCB2YXIoLS1jYWxjaXRlLXNwYWNpbmcteHhzKSkpfS5jYWxjaXRlLWlucHV0LW1lc3NhZ2UtaWNvbntwb2ludGVyLWV2ZW50czpub25lO2Rpc3BsYXk6aW5saW5lLWZsZXg7ZmxleC1zaHJpbms6MDt0cmFuc2l0aW9uLXByb3BlcnR5OmJhY2tncm91bmQtY29sb3IsYmxvY2stc2l6ZSxib3JkZXItY29sb3IsYm94LXNoYWRvdyxjb2xvcixpbnNldC1ibG9jay1lbmQsaW5zZXQtYmxvY2stc3RhcnQsaW5zZXQtaW5saW5lLWVuZCxpbnNldC1pbmxpbmUtc3RhcnQsaW5zZXQtc2l6ZSxvcGFjaXR5LG91dGxpbmUtY29sb3IsdHJhbnNmb3JtO3RyYW5zaXRpb24tZHVyYXRpb246dmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLWluLW91dDttYXJnaW4taW5saW5lLWVuZDp2YXIoLS1jYWxjaXRlLXNwYWNpbmctc20pfTpob3N0KFtzdGF0dXM9aW52YWxpZF0pIC5jYWxjaXRlLWlucHV0LW1lc3NhZ2UtaWNvbntjb2xvcjp2YXIoLS1jYWxjaXRlLWlucHV0LW1lc3NhZ2UtaWNvbi1jb2xvciwgdmFyKC0tY2FsY2l0ZS1pY29uLWNvbG9yLCB2YXIoLS1jYWxjaXRlLWNvbG9yLXN0YXR1cy1kYW5nZXIpKSl9Omhvc3QoW3N0YXR1cz12YWxpZF0pIC5jYWxjaXRlLWlucHV0LW1lc3NhZ2UtaWNvbntjb2xvcjp2YXIoLS1jYWxjaXRlLWlucHV0LW1lc3NhZ2UtaWNvbi1jb2xvciwgdmFyKC0tY2FsY2l0ZS1pY29uLWNvbG9yLCB2YXIoLS1jYWxjaXRlLWNvbG9yLXN0YXR1cy1zdWNjZXNzKSkpfTpob3N0KFtzdGF0dXM9aWRsZV0pIC5jYWxjaXRlLWlucHV0LW1lc3NhZ2UtaWNvbntjb2xvcjp2YXIoLS1jYWxjaXRlLWlucHV0LW1lc3NhZ2UtaWNvbi1jb2xvciwgdmFyKC0tY2FsY2l0ZS1pY29uLWNvbG9yLCB2YXIoLS1jYWxjaXRlLWNvbG9yLWJyYW5kKSkpfTpob3N0KFtzY2FsZT1zXSl7Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0zKTtsaW5lLWhlaWdodDouNzVyZW19Omhvc3QoW3NjYWxlPW1dKXtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTIpO2xpbmUtaGVpZ2h0OjFyZW19Omhvc3QoW3NjYWxlPWxdKXtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTEpO2xpbmUtaGVpZ2h0OjFyZW19Omhvc3QoW2hpZGRlbl0pe2Rpc3BsYXk6bm9uZX1baGlkZGVuXXtkaXNwbGF5Om5vbmV9YDtcbmNvbnN0IENTUyA9IHtcbiAgaW5wdXRNZXNzYWdlSWNvbjogXCJjYWxjaXRlLWlucHV0LW1lc3NhZ2UtaWNvblwiXG59O1xuY2xhc3MgSW5wdXRNZXNzYWdlIGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5pY29uRmxpcFJ0bCA9IGZhbHNlO1xuICAgIHRoaXMuc2NhbGUgPSBcIm1cIjtcbiAgICB0aGlzLnN0YXR1cyA9IFwiaWRsZVwiO1xuICB9XG4gIHN0YXRpYyB7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0geyBpY29uOiBbMywgeyBjb252ZXJ0ZXI6IHN0cmluZ09yQm9vbGVhbiB9LCB7IHJlZmxlY3Q6IHRydWUgfV0sIGljb25GbGlwUnRsOiBbNywge30sIHsgcmVmbGVjdDogdHJ1ZSwgdHlwZTogQm9vbGVhbiB9XSwgc2NhbGU6IFszLCB7fSwgeyByZWZsZWN0OiB0cnVlIH1dLCBzdGF0dXM6IFszLCB7fSwgeyByZWZsZWN0OiB0cnVlIH1dIH07XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHRoaXMucmVxdWVzdGVkSWNvbiA9IHNldFJlcXVlc3RlZEljb24oU3RhdHVzSWNvbkRlZmF1bHRzLCB0aGlzLmljb24sIHRoaXMuc3RhdHVzKTtcbiAgfVxuICB3aWxsVXBkYXRlKGNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5oYXMoXCJzdGF0dXNcIikgJiYgKHRoaXMuaGFzVXBkYXRlZCB8fCB0aGlzLnN0YXR1cyAhPT0gXCJpZGxlXCIpIHx8IGNoYW5nZXMuaGFzKFwiaWNvblwiKSkge1xuICAgICAgdGhpcy5yZXF1ZXN0ZWRJY29uID0gc2V0UmVxdWVzdGVkSWNvbihTdGF0dXNJY29uRGVmYXVsdHMsIHRoaXMuaWNvbiwgdGhpcy5zdGF0dXMpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgaGlkZGVuID0gdGhpcy5lbC5oaWRkZW47XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuZWwsIFwiY2FsY2l0ZS1oeWRyYXRlZC1oaWRkZW5cIiwgaGlkZGVuKTtcbiAgICByZXR1cm4gaHRtbGAke3RoaXMucmVuZGVySWNvbih0aGlzLnJlcXVlc3RlZEljb24pfTxzbG90Pjwvc2xvdD5gO1xuICB9XG4gIHJlbmRlckljb24oaWNvbk5hbWUpIHtcbiAgICBpZiAoaWNvbk5hbWUpIHtcbiAgICAgIHJldHVybiBodG1sYDxjYWxjaXRlLWljb24gY2xhc3M9JHtzYWZlQ2xhc3NNYXAoQ1NTLmlucHV0TWVzc2FnZUljb24pfSAuZmxpcFJ0bD0ke3RoaXMuaWNvbkZsaXBSdGx9IC5pY29uPSR7aWNvbk5hbWV9IHNjYWxlPXM+PC9jYWxjaXRlLWljb24+YDtcbiAgICB9XG4gIH1cbn1cbmN1c3RvbUVsZW1lbnQoXCJjYWxjaXRlLWlucHV0LW1lc3NhZ2VcIiwgSW5wdXRNZXNzYWdlKTtcbmV4cG9ydCB7XG4gIElucHV0TWVzc2FnZVxufTtcbiIsImltcG9ydCBcIi4uL2NhbGNpdGUtaWNvbi9pbmRleC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vY3VzdG9tRWxlbWVudC5qc1wiOyIsIi8qISBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL2Rldi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxudjMuMy4zICovXG5pbXBvcnQgeyBDIGFzIENTU19VVElMSVRZLCBjIGFzIGN1c3RvbUVsZW1lbnQgfSBmcm9tIFwiLi4vLi4vY2h1bmtzL3J1bnRpbWUuanNcIjtcbmltcG9ydCB7IGNzcywgaHRtbCB9IGZyb20gXCJsaXRcIjtcbmltcG9ydCB7IExpdEVsZW1lbnQsIHNhZmVDbGFzc01hcCwgc2FmZVN0eWxlTWFwIH0gZnJvbSBcIkBhcmNnaXMvbHVtaW5hXCI7XG5pbXBvcnQgeyBnIGFzIGdldEVsZW1lbnREaXIgfSBmcm9tIFwiLi4vLi4vY2h1bmtzL2RvbS5qc1wiO1xuY29uc3Qgc3R5bGVzID0gY3NzYDpob3N0ey0tY2FsY2l0ZS1pbnRlcm5hbC1jb2xvci1mb2N1czogdmFyKCAtLWNhbGNpdGUtY29sb3ItZm9jdXMsIHZhcigtLWNhbGNpdGUtdWktZm9jdXMtY29sb3IsIHZhcigtLWNhbGNpdGUtY29sb3ItYnJhbmQpKSApfTpob3N0e3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7aW5saW5lLXNpemU6MTAwJX0udHJhY2ssLmJhcntwb3NpdGlvbjphYnNvbHV0ZTtpbnNldC1ibG9jay1zdGFydDowcHg7YmxvY2stc2l6ZToycHh9LnRyYWNre3otaW5kZXg6dmFyKC0tY2FsY2l0ZS16LWluZGV4KTtpbmxpbmUtc2l6ZToxMDAlO292ZXJmbG93OmhpZGRlbjtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtcHJvZ3Jlc3MtYmFja2dyb3VuZC1jb2xvciwgdmFyKC0tY2FsY2l0ZS1jb2xvci1ib3JkZXItMykpfS5iYXJ7ei1pbmRleDp2YXIoLS1jYWxjaXRlLXotaW5kZXgpO2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS1wcm9ncmVzcy1maWxsLWNvbG9yLCB2YXIoLS1jYWxjaXRlLWNvbG9yLWJyYW5kKSl9QG1lZGlhIChmb3JjZWQtY29sb3JzOiBhY3RpdmUpey50cmFja3tiYWNrZ3JvdW5kLWNvbG9yOmhpZ2hsaWdodFRleHR9LmJhcntiYWNrZ3JvdW5kLWNvbG9yOmxpbmtUZXh0fX0uaW5kZXRlcm1pbmF0ZXtpbmxpbmUtc2l6ZToyMCU7YW5pbWF0aW9uOmxvb3BpbmctcHJvZ3Jlc3MtYmFyLWFuaSBjYWxjKHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1tZWRpdW0pIC8gdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpICogMTEgLyB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpIGxpbmVhciBpbmZpbml0ZX0uaW5kZXRlcm1pbmF0ZS5jYWxjaXRlLS1ydGx7YW5pbWF0aW9uLW5hbWU6bG9vcGluZy1wcm9ncmVzcy1iYXItYW5pLXJ0bH0ucmV2ZXJzZWR7YW5pbWF0aW9uLWRpcmVjdGlvbjpyZXZlcnNlfS50ZXh0e3BhZGRpbmctaW5saW5lOjBweDtwYWRkaW5nLWJsb2NrOjFyZW0gMHB4O3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMik7bGluZS1oZWlnaHQ6MXJlbTtmb250LXdlaWdodDp2YXIoLS1jYWxjaXRlLWZvbnQtd2VpZ2h0LW1lZGl1bSk7Y29sb3I6dmFyKC0tY2FsY2l0ZS1wcm9ncmVzcy10ZXh0LWNvbG9yLCB2YXIoLS1jYWxjaXRlLWNvbG9yLXRleHQtMikpfUBrZXlmcmFtZXMgbG9vcGluZy1wcm9ncmVzcy1iYXItYW5pezAle3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMTAwJSwwLDApfTUwJXtpbmxpbmUtc2l6ZTo0MCV9dG97dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDYwMCUsMCwwKX19QGtleWZyYW1lcyBsb29waW5nLXByb2dyZXNzLWJhci1hbmktcnRsezAle3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgxMDAlLDAsMCl9NTAle2lubGluZS1zaXplOjQwJX10b3t0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTYwMCUsMCwwKX19Omhvc3QoW2hpZGRlbl0pe2Rpc3BsYXk6bm9uZX1baGlkZGVuXXtkaXNwbGF5Om5vbmV9YDtcbmNvbnN0IENTUyA9IHtcbiAgdHJhY2s6IFwidHJhY2tcIixcbiAgYmFyOiBcImJhclwiLFxuICB0ZXh0OiBcInRleHRcIlxufTtcbmNsYXNzIFByb2dyZXNzIGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5yZXZlcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMudHlwZSA9IFwiZGV0ZXJtaW5hdGVcIjtcbiAgICB0aGlzLnZhbHVlID0gMDtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMucHJvcGVydGllcyA9IHsgbGFiZWw6IDEsIHJldmVyc2VkOiBbNywge30sIHsgcmVmbGVjdDogdHJ1ZSwgdHlwZTogQm9vbGVhbiB9XSwgdGV4dDogMSwgdHlwZTogWzMsIHt9LCB7IHJlZmxlY3Q6IHRydWUgfV0sIHZhbHVlOiBbOSwge30sIHsgdHlwZTogTnVtYmVyIH1dIH07XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgaXNEZXRlcm1pbmF0ZSA9IHRoaXMudHlwZSA9PT0gXCJkZXRlcm1pbmF0ZVwiO1xuICAgIGNvbnN0IGJhclN0eWxlcyA9IGlzRGV0ZXJtaW5hdGUgPyB7IHdpZHRoOiBgJHt0aGlzLnZhbHVlfSVgIH0gOiB7fTtcbiAgICBjb25zdCBkaXIgPSBnZXRFbGVtZW50RGlyKHRoaXMuZWwpO1xuICAgIHJldHVybiBodG1sYDxkaXYgLmFyaWFMYWJlbD0ke3RoaXMubGFiZWwgfHwgdGhpcy50ZXh0fSAuYXJpYVZhbHVlTWF4PSR7aXNEZXRlcm1pbmF0ZSA/IFwiMTAwXCIgOiB2b2lkIDB9IC5hcmlhVmFsdWVNaW49JHtpc0RldGVybWluYXRlID8gXCIwXCIgOiB2b2lkIDB9IC5hcmlhVmFsdWVOb3c9JHtpc0RldGVybWluYXRlID8gdGhpcy52YWx1ZSA6IHZvaWQgMH0gcm9sZT1wcm9ncmVzc2Jhcj48ZGl2IGNsYXNzPSR7c2FmZUNsYXNzTWFwKENTUy50cmFjayl9PjxkaXYgY2xhc3M9JHtzYWZlQ2xhc3NNYXAoe1xuICAgICAgW0NTUy5iYXJdOiB0cnVlLFxuICAgICAgaW5kZXRlcm1pbmF0ZTogdGhpcy50eXBlID09PSBcImluZGV0ZXJtaW5hdGVcIixcbiAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBkaXIgPT09IFwicnRsXCIsXG4gICAgICByZXZlcnNlZDogdGhpcy5yZXZlcnNlZFxuICAgIH0pfSBzdHlsZT0ke3NhZmVTdHlsZU1hcChiYXJTdHlsZXMpfT48L2Rpdj48L2Rpdj4ke3RoaXMudGV4dCA/IGh0bWxgPGRpdiBjbGFzcz0ke3NhZmVDbGFzc01hcChDU1MudGV4dCl9PiR7dGhpcy50ZXh0fTwvZGl2PmAgOiBudWxsfTwvZGl2PmA7XG4gIH1cbn1cbmN1c3RvbUVsZW1lbnQoXCJjYWxjaXRlLXByb2dyZXNzXCIsIFByb2dyZXNzKTtcbmV4cG9ydCB7XG4gIFByb2dyZXNzXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5pbXBvcnQgeyBub3RoaW5nIH0gZnJvbSAnLi4vbGl0LWh0bWwuanMnO1xuaW1wb3J0IHsgZGlyZWN0aXZlLCBEaXJlY3RpdmUsIH0gZnJvbSAnLi4vZGlyZWN0aXZlLmpzJztcbmltcG9ydCB7IHNldENvbW1pdHRlZFZhbHVlIH0gZnJvbSAnLi4vZGlyZWN0aXZlLWhlbHBlcnMuanMnO1xuY2xhc3MgS2V5ZWQgZXh0ZW5kcyBEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmtleSA9IG5vdGhpbmc7XG4gICAgfVxuICAgIHJlbmRlcihrLCB2KSB7XG4gICAgICAgIHRoaXMua2V5ID0gaztcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHVwZGF0ZShwYXJ0LCBbaywgdl0pIHtcbiAgICAgICAgaWYgKGsgIT09IHRoaXMua2V5KSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgcGFydCBiZWZvcmUgcmV0dXJuaW5nIGEgdmFsdWUuIFRoZSBvbmUtYXJnIGZvcm0gb2ZcbiAgICAgICAgICAgIC8vIHNldENvbW1pdHRlZFZhbHVlIHNldHMgdGhlIHZhbHVlIHRvIGEgc2VudGluZWwgd2hpY2ggZm9yY2VzIGFcbiAgICAgICAgICAgIC8vIGNvbW1pdCB0aGUgbmV4dCByZW5kZXIuXG4gICAgICAgICAgICBzZXRDb21taXR0ZWRWYWx1ZShwYXJ0KTtcbiAgICAgICAgICAgIHRoaXMua2V5ID0gaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG4vKipcbiAqIEFzc29jaWF0ZXMgYSByZW5kZXJhYmxlIHZhbHVlIHdpdGggYSB1bmlxdWUga2V5LiBXaGVuIHRoZSBrZXkgY2hhbmdlcywgdGhlXG4gKiBwcmV2aW91cyBET00gaXMgcmVtb3ZlZCBhbmQgZGlzcG9zZWQgYmVmb3JlIHJlbmRlcmluZyB0aGUgbmV4dCB2YWx1ZSwgZXZlblxuICogaWYgdGhlIHZhbHVlIC0gc3VjaCBhcyBhIHRlbXBsYXRlIC0gaXMgdGhlIHNhbWUuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGZvcmNpbmcgcmUtcmVuZGVycyBvZiBzdGF0ZWZ1bCBjb21wb25lbnRzLCBvciB3b3JraW5nXG4gKiB3aXRoIGNvZGUgdGhhdCBleHBlY3RzIG5ldyBkYXRhIHRvIGdlbmVyYXRlIG5ldyBIVE1MIGVsZW1lbnRzLCBzdWNoIGFzIHNvbWVcbiAqIGFuaW1hdGlvbiB0ZWNobmlxdWVzLlxuICovXG5leHBvcnQgY29uc3Qga2V5ZWQgPSBkaXJlY3RpdmUoS2V5ZWQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5ZWQuanMubWFwIiwiZXhwb3J0KmZyb21cImxpdC1odG1sL2RpcmVjdGl2ZXMva2V5ZWQuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleWVkLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9