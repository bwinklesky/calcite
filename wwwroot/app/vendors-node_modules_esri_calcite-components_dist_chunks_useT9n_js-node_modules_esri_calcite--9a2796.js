export const __webpack_id__ = "vendors-node_modules_esri_calcite-components_dist_chunks_useT9n_js-node_modules_esri_calcite--9a2796";
export const __webpack_ids__ = ["vendors-node_modules_esri_calcite-components_dist_chunks_useT9n_js-node_modules_esri_calcite--9a2796"];
export const __webpack_modules__ = {

/***/ "./node_modules/@esri/calcite-components/dist/chunks/observers.js":
/*!************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/chunks/observers.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createObserver),
/* harmony export */   u: () => (/* binding */ updateRefObserver)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */

function createObserver(type, callback, options) {
  if (lit__WEBPACK_IMPORTED_MODULE_0__.isServer) {
    return void 0;
  }
  const Observer = getObserver(type);
  return new Observer(callback, options);
}
function getObserver(type) {
  class ExtendedMutationObserver extends window.MutationObserver {
    constructor(callback) {
      super(callback);
      this.observedEntry = [];
      this.callback = callback;
    }
    observe(target, options) {
      this.observedEntry.push({ target, options });
      return super.observe(target, options);
    }
    unobserve(target) {
      const newObservedEntries = this.observedEntry.filter((observed) => observed.target !== target);
      this.observedEntry = [];
      this.callback(super.takeRecords(), this);
      this.disconnect();
      newObservedEntries.forEach((observed) => this.observe(observed.target, observed.options));
    }
  }
  return function() {
    return type === "intersection" ? window.IntersectionObserver : type === "mutation" ? ExtendedMutationObserver : window.ResizeObserver;
  }();
}
function updateRefObserver(observer, oldTarget, target, options) {
  if (!observer) {
    return;
  }
  if (oldTarget) {
    observer.unobserve(oldTarget);
  }
  if (!target) {
    return;
  }
  if (observer instanceof MutationObserver) {
    observer.observe(target, options);
    return;
  }
  observer.observe(target);
}



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/chunks/useT9n.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/chunks/useT9n.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ useT9n)
/* harmony export */ });
/* harmony import */ var _arcgis_lumina_controllers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @arcgis/lumina/controllers */ "./node_modules/@arcgis/lumina/dist/controllers/index.js");
/* harmony import */ var _runtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runtime.js */ "./node_modules/@esri/calcite-components/dist/chunks/runtime.js");
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */


const useT9n = (0,_arcgis_lumina_controllers__WEBPACK_IMPORTED_MODULE_0__.makeT9nController)(_runtime_js__WEBPACK_IMPORTED_MODULE_1__.g);



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/components/calcite-icon/customElement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/components/calcite-icon/customElement.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Icon: () => (/* binding */ Icon)
/* harmony export */ });
/* harmony import */ var _chunks_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../chunks/runtime.js */ "./node_modules/@esri/calcite-components/dist/chunks/runtime.js");
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit */ "./node_modules/lit/index.js");
/* harmony import */ var _arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcgis/lumina */ "./node_modules/@arcgis/lumina/dist/index.js");
/* harmony import */ var _chunks_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../chunks/dom.js */ "./node_modules/@esri/calcite-components/dist/chunks/dom.js");
/* harmony import */ var _chunks_observers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../chunks/observers.js */ "./node_modules/@esri/calcite-components/dist/chunks/observers.js");
/* harmony import */ var _chunks_logger_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../chunks/logger.js */ "./node_modules/@esri/calcite-components/dist/chunks/logger.js");
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */






const CSS = {
  flipRtl: "flip-rtl",
  svg: "svg"
};
const iconCache = {};
const requestCache = {};
const scaleToPx = {
  s: 16,
  m: 24,
  l: 32
};
function generateIconId({ icon, scale }) {
  const size = scaleToPx[scale];
  const name = normalizeIconName(icon);
  const filled = name.charAt(name.length - 1) === "F";
  const iconName = filled ? name.substring(0, name.length - 1) : name;
  return `${iconName}${size}${filled ? "F" : ""}`;
}
async function fetchIcon(props) {
  const cachedIconKey = generateIconId(props);
  const cachedIconData = getCachedIconDataByKey(cachedIconKey);
  if (cachedIconData) {
    return cachedIconData;
  }
  if (!requestCache[cachedIconKey]) {
    requestCache[cachedIconKey] = fetch((0,_chunks_runtime_js__WEBPACK_IMPORTED_MODULE_0__.g)(`./assets/icon/${cachedIconKey}.json`)).then((resp) => resp.json()).catch(() => {
      _chunks_logger_js__WEBPACK_IMPORTED_MODULE_5__.l.error(`${props.icon} (${props.scale}) icon failed to load`);
      return "";
    });
  }
  const path = await requestCache[cachedIconKey];
  iconCache[cachedIconKey] = path;
  return path;
}
function getCachedIconData(props) {
  return getCachedIconDataByKey(generateIconId(props));
}
function getCachedIconDataByKey(id) {
  return iconCache[id];
}
function normalizeIconName(name) {
  const numberLeadingName = !isNaN(Number(name.charAt(0)));
  const parts = name.split("-");
  const kebabCased = parts.length > 0;
  if (kebabCased) {
    const firstNonDigitInPartPattern = /[a-z]/i;
    name = parts.map((part, partIndex) => {
      return part.replace(firstNonDigitInPartPattern, function replacer(match, offset) {
        const isFirstCharInName = partIndex === 0 && offset === 0;
        if (isFirstCharInName) {
          return match;
        }
        return match.toUpperCase();
      });
    }).join("");
  }
  return numberLeadingName ? `i${name}` : name;
}
const styles = (0,lit__WEBPACK_IMPORTED_MODULE_1__.css)`:host{--calcite-internal-color-focus: var( --calcite-color-focus, var(--calcite-ui-focus-color, var(--calcite-color-brand)) )}:host{display:inline-flex;color:var(--calcite-icon-color, var(--calcite-ui-icon-color, currentColor))}:host([scale=s]){inline-size:16px;block-size:16px;min-inline-size:16px;min-block-size:16px}:host([scale=m]){inline-size:24px;block-size:24px;min-inline-size:24px;min-block-size:24px}:host([scale=l]){inline-size:32px;block-size:32px;min-inline-size:32px;min-block-size:32px}.flip-rtl{transform:scaleX(-1)}.svg{display:block}:host([hidden]){display:none}[hidden]{display:none}`;
class Icon extends _arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.LitElement {
  constructor() {
    super(...arguments);
    this.visible = false;
    this.flipRtl = false;
    this.icon = null;
    this.preload = false;
    this.scale = "m";
  }
  static {
    this.properties = { pathData: [16, {}, { state: true }], visible: [16, {}, { state: true }], flipRtl: [7, {}, { reflect: true, type: Boolean }], icon: [3, {}, { reflect: true }], preload: [7, {}, { reflect: true, type: Boolean }], scale: [3, {}, { reflect: true }], textLabel: 1 };
  }
  static {
    this.styles = styles;
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.preload) {
      this.visible = true;
      this.loadIconPathData();
      return;
    }
    if (!this.visible) {
      this.waitUntilVisible(() => {
        this.visible = true;
        this.loadIconPathData();
      });
    }
  }
  willUpdate(changes) {
    if (changes.has("icon") && (this.hasUpdated || this.icon !== null) || changes.has("scale") && (this.hasUpdated || this.scale !== "m")) {
      this.loadIconPathData();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.intersectionObserver?.disconnect();
    this.intersectionObserver = null;
  }
  async loadIconPathData() {
    const { icon, scale, visible } = this;
    if (lit__WEBPACK_IMPORTED_MODULE_1__.isServer || !icon || !visible) {
      return;
    }
    const fetchIconProps = { icon, scale };
    const pathData = getCachedIconData(fetchIconProps) || await fetchIcon(fetchIconProps);
    if (icon !== this.icon) {
      return;
    }
    this.pathData = pathData;
  }
  waitUntilVisible(callback) {
    this.intersectionObserver = (0,_chunks_observers_js__WEBPACK_IMPORTED_MODULE_4__.c)("intersection", (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.intersectionObserver.disconnect();
          this.intersectionObserver = null;
          callback();
        }
      });
    }, { rootMargin: "50px" });
    if (!this.intersectionObserver) {
      callback();
      return;
    }
    this.intersectionObserver.observe(this.el);
  }
  render() {
    const { el, flipRtl, pathData, scale, textLabel } = this;
    const dir = (0,_chunks_dom_js__WEBPACK_IMPORTED_MODULE_3__.g)(el);
    const size = scaleToPx[scale];
    const semantic = !!textLabel;
    const paths = [].concat(pathData || "");
    this.el.ariaHidden = (0,_chunks_dom_js__WEBPACK_IMPORTED_MODULE_3__.t)(!semantic);
    this.el.ariaLabel = semantic ? textLabel : null;
    this.el.role = semantic ? "img" : null;
    return (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)`<svg aria-hidden=true class=${(0,_arcgis_lumina__WEBPACK_IMPORTED_MODULE_2__.safeClassMap)({
      [CSS.flipRtl]: dir === "rtl" && flipRtl,
      [CSS.svg]: true
    })} fill=currentColor height=100% viewBox=${`0 0 ${size} ${size}`} width=100% xmlns=http://www.w3.org/2000/svg>${paths.map((path) => typeof path === "string" ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.svg)`<path d=${path ?? lit__WEBPACK_IMPORTED_MODULE_1__.nothing} />` : (0,lit__WEBPACK_IMPORTED_MODULE_1__.svg)`<path d=${path.d ?? lit__WEBPACK_IMPORTED_MODULE_1__.nothing} opacity=${("opacity" in path ? path.opacity : 1) ?? lit__WEBPACK_IMPORTED_MODULE_1__.nothing} />`)}</svg>`;
  }
}
(0,_chunks_runtime_js__WEBPACK_IMPORTED_MODULE_0__.c)("calcite-icon", Icon);



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/components/calcite-icon/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/components/calcite-icon/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Icon: () => (/* reexport safe */ _customElement_js__WEBPACK_IMPORTED_MODULE_0__.Icon)
/* harmony export */ });
/* harmony import */ var _customElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./customElement.js */ "./node_modules/@esri/calcite-components/dist/components/calcite-icon/customElement.js");


/***/ }),

/***/ "./node_modules/lit-html/development/static.js":
/*!*****************************************************!*\
  !*** ./node_modules/lit-html/development/static.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   html: () => (/* binding */ html),
/* harmony export */   literal: () => (/* binding */ literal),
/* harmony export */   mathml: () => (/* binding */ mathml),
/* harmony export */   svg: () => (/* binding */ svg),
/* harmony export */   unsafeStatic: () => (/* binding */ unsafeStatic),
/* harmony export */   withStatic: () => (/* binding */ withStatic)
/* harmony export */ });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lit-html.js */ "./node_modules/lit-html/development/lit-html.js");
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
// Any new exports need to be added to the export statement in
// `packages/lit/src/index.all.ts`.

/**
 * Prevents JSON injection attacks.
 *
 * The goals of this brand:
 *   1) fast to check
 *   2) code is small on the wire
 *   3) multiple versions of Lit in a single page will all produce mutually
 *      interoperable StaticValues
 *   4) normal JSON.parse (without an unusual reviver) can not produce a
 *      StaticValue
 *
 * Symbols satisfy (1), (2), and (4). We use Symbol.for to satisfy (3), but
 * we don't care about the key, so we break ties via (2) and use the empty
 * string.
 */
const brand = Symbol.for('');
/** Safely extracts the string part of a StaticValue. */
const unwrapStaticValue = (value) => {
    if (value?.r !== brand) {
        return undefined;
    }
    return value?.['_$litStatic$'];
};
/**
 * Wraps a string so that it behaves like part of the static template
 * strings instead of a dynamic value.
 *
 * Users must take care to ensure that adding the static string to the template
 * results in well-formed HTML, or else templates may break unexpectedly.
 *
 * Note that this function is unsafe to use on untrusted content, as it will be
 * directly parsed into HTML. Do not pass user input to this function
 * without sanitizing it.
 *
 * Static values can be changed, but they will cause a complete re-render
 * since they effectively create a new template.
 */
const unsafeStatic = (value) => ({
    ['_$litStatic$']: value,
    r: brand,
});
const textFromStatic = (value) => {
    if (value['_$litStatic$'] !== undefined) {
        return value['_$litStatic$'];
    }
    else {
        throw new Error(`Value passed to 'literal' function must be a 'literal' result: ${value}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
    }
};
/**
 * Tags a string literal so that it behaves like part of the static template
 * strings instead of a dynamic value.
 *
 * The only values that may be used in template expressions are other tagged
 * `literal` results or `unsafeStatic` values (note that untrusted content
 * should never be passed to `unsafeStatic`).
 *
 * Users must take care to ensure that adding the static string to the template
 * results in well-formed HTML, or else templates may break unexpectedly.
 *
 * Static values can be changed, but they will cause a complete re-render since
 * they effectively create a new template.
 */
const literal = (strings, ...values) => ({
    ['_$litStatic$']: values.reduce((acc, v, idx) => acc + textFromStatic(v) + strings[idx + 1], strings[0]),
    r: brand,
});
const stringsCache = new Map();
/**
 * Wraps a lit-html template tag (`html` or `svg`) to add static value support.
 */
const withStatic = (coreTag) => (strings, ...values) => {
    const l = values.length;
    let staticValue;
    let dynamicValue;
    const staticStrings = [];
    const dynamicValues = [];
    let i = 0;
    let hasStatics = false;
    let s;
    while (i < l) {
        s = strings[i];
        // Collect any unsafeStatic values, and their following template strings
        // so that we treat a run of template strings and unsafe static values as
        // a single template string.
        while (i < l &&
            ((dynamicValue = values[i]),
                (staticValue = unwrapStaticValue(dynamicValue))) !== undefined) {
            s += staticValue + strings[++i];
            hasStatics = true;
        }
        // If the last value is static, we don't need to push it.
        if (i !== l) {
            dynamicValues.push(dynamicValue);
        }
        staticStrings.push(s);
        i++;
    }
    // If the last value isn't static (which would have consumed the last
    // string), then we need to add the last string.
    if (i === l) {
        staticStrings.push(strings[l]);
    }
    if (hasStatics) {
        const key = staticStrings.join('$$lit$$');
        strings = stringsCache.get(key);
        if (strings === undefined) {
            // Beware: in general this pattern is unsafe, and doing so may bypass
            // lit's security checks and allow an attacker to execute arbitrary
            // code and inject arbitrary content.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            staticStrings.raw = staticStrings;
            stringsCache.set(key, (strings = staticStrings));
        }
        values = dynamicValues;
    }
    return coreTag(strings, ...values);
};
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 *
 * Includes static value support from `lit-html/static.js`.
 */
const html = withStatic(_lit_html_js__WEBPACK_IMPORTED_MODULE_0__.html);
/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 *
 * Includes static value support from `lit-html/static.js`.
 */
const svg = withStatic(_lit_html_js__WEBPACK_IMPORTED_MODULE_0__.svg);
/**
 * Interprets a template literal as MathML fragment that can efficiently render
 * to and update a container.
 *
 * Includes static value support from `lit-html/static.js`.
 */
const mathml = withStatic(_lit_html_js__WEBPACK_IMPORTED_MODULE_0__.mathml);
//# sourceMappingURL=static.js.map

/***/ })

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZXNyaV9jYWxjaXRlLWNvbXBvbmVudHNfZGlzdF9jaHVua3NfdXNlVDluX2pzLW5vZGVfbW9kdWxlc19lc3JpX2NhbGNpdGUtLTlhMjc5Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQytCO0FBQy9CO0FBQ0EsTUFBTSx5Q0FBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JERjtBQUNBO0FBQ0E7QUFDK0Q7QUFDZDtBQUNqRCxlQUFlLDZFQUFpQixDQUFDLDBDQUFZO0FBRzNDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSRjtBQUNBO0FBQ0E7QUFDZ0Y7QUFDeEI7QUFDRTtBQUNtQjtBQUNiO0FBQ1g7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTLEVBQUUsS0FBSyxFQUFFLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFEQUFZLGtCQUFrQixjQUFjO0FBQ3BGLE1BQU0sZ0RBQU0sVUFBVSxZQUFZLEdBQUcsWUFBWTtBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IsOENBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUJBQXVCLDZDQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQixnREFBVTtBQUMzQyxrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2NodW5rcy9vYnNlcnZlcnMuanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Rpc3QvY2h1bmtzL3VzZVQ5bi5qcyIsIndlYnBhY2s6Ly9wcmVjaXNpb25mYXJtcy8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jb21wb25lbnRzL2NhbGNpdGUtaWNvbi9jdXN0b21FbGVtZW50LmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2RldmVsb3BtZW50L3N0YXRpYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vYmxvYi9kZXYvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbnYzLjMuMyAqL1xuaW1wb3J0IHsgaXNTZXJ2ZXIgfSBmcm9tIFwibGl0XCI7XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IE9ic2VydmVyID0gZ2V0T2JzZXJ2ZXIodHlwZSk7XG4gIHJldHVybiBuZXcgT2JzZXJ2ZXIoY2FsbGJhY2ssIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXIodHlwZSkge1xuICBjbGFzcyBFeHRlbmRlZE11dGF0aW9uT2JzZXJ2ZXIgZXh0ZW5kcyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICAgIHN1cGVyKGNhbGxiYWNrKTtcbiAgICAgIHRoaXMub2JzZXJ2ZWRFbnRyeSA9IFtdO1xuICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBvYnNlcnZlKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5vYnNlcnZlZEVudHJ5LnB1c2goeyB0YXJnZXQsIG9wdGlvbnMgfSk7XG4gICAgICByZXR1cm4gc3VwZXIub2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB1bm9ic2VydmUodGFyZ2V0KSB7XG4gICAgICBjb25zdCBuZXdPYnNlcnZlZEVudHJpZXMgPSB0aGlzLm9ic2VydmVkRW50cnkuZmlsdGVyKChvYnNlcnZlZCkgPT4gb2JzZXJ2ZWQudGFyZ2V0ICE9PSB0YXJnZXQpO1xuICAgICAgdGhpcy5vYnNlcnZlZEVudHJ5ID0gW107XG4gICAgICB0aGlzLmNhbGxiYWNrKHN1cGVyLnRha2VSZWNvcmRzKCksIHRoaXMpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICBuZXdPYnNlcnZlZEVudHJpZXMuZm9yRWFjaCgob2JzZXJ2ZWQpID0+IHRoaXMub2JzZXJ2ZShvYnNlcnZlZC50YXJnZXQsIG9ic2VydmVkLm9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0eXBlID09PSBcImludGVyc2VjdGlvblwiID8gd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyIDogdHlwZSA9PT0gXCJtdXRhdGlvblwiID8gRXh0ZW5kZWRNdXRhdGlvbk9ic2VydmVyIDogd2luZG93LlJlc2l6ZU9ic2VydmVyO1xuICB9KCk7XG59XG5mdW5jdGlvbiB1cGRhdGVSZWZPYnNlcnZlcihvYnNlcnZlciwgb2xkVGFyZ2V0LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgaWYgKCFvYnNlcnZlcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob2xkVGFyZ2V0KSB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKG9sZFRhcmdldCk7XG4gIH1cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9ic2VydmVyIGluc3RhbmNlb2YgTXV0YXRpb25PYnNlcnZlcikge1xuICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0LCBvcHRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQpO1xufVxuZXhwb3J0IHtcbiAgY3JlYXRlT2JzZXJ2ZXIgYXMgYyxcbiAgdXBkYXRlUmVmT2JzZXJ2ZXIgYXMgdVxufTtcbiIsIi8qISBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL2Rldi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxudjMuMy4zICovXG5pbXBvcnQgeyBtYWtlVDluQ29udHJvbGxlciB9IGZyb20gXCJAYXJjZ2lzL2x1bWluYS9jb250cm9sbGVyc1wiO1xuaW1wb3J0IHsgZyBhcyBnZXRBc3NldFBhdGggfSBmcm9tIFwiLi9ydW50aW1lLmpzXCI7XG5jb25zdCB1c2VUOW4gPSBtYWtlVDluQ29udHJvbGxlcihnZXRBc3NldFBhdGgpO1xuZXhwb3J0IHtcbiAgdXNlVDluIGFzIHVcbn07XG4iLCIvKiEgQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vYmxvYi9kZXYvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbnYzLjMuMyAqL1xuaW1wb3J0IHsgZyBhcyBnZXRBc3NldFBhdGgsIGMgYXMgY3VzdG9tRWxlbWVudCB9IGZyb20gXCIuLi8uLi9jaHVua3MvcnVudGltZS5qc1wiO1xuaW1wb3J0IHsgY3NzLCBpc1NlcnZlciwgbm90aGluZywgc3ZnLCBodG1sIH0gZnJvbSBcImxpdFwiO1xuaW1wb3J0IHsgTGl0RWxlbWVudCwgc2FmZUNsYXNzTWFwIH0gZnJvbSBcIkBhcmNnaXMvbHVtaW5hXCI7XG5pbXBvcnQgeyBnIGFzIGdldEVsZW1lbnREaXIsIHQgYXMgdG9BcmlhQm9vbGVhbiB9IGZyb20gXCIuLi8uLi9jaHVua3MvZG9tLmpzXCI7XG5pbXBvcnQgeyBjIGFzIGNyZWF0ZU9ic2VydmVyIH0gZnJvbSBcIi4uLy4uL2NodW5rcy9vYnNlcnZlcnMuanNcIjtcbmltcG9ydCB7IGwgYXMgbG9nZ2VyIH0gZnJvbSBcIi4uLy4uL2NodW5rcy9sb2dnZXIuanNcIjtcbmNvbnN0IENTUyA9IHtcbiAgZmxpcFJ0bDogXCJmbGlwLXJ0bFwiLFxuICBzdmc6IFwic3ZnXCJcbn07XG5jb25zdCBpY29uQ2FjaGUgPSB7fTtcbmNvbnN0IHJlcXVlc3RDYWNoZSA9IHt9O1xuY29uc3Qgc2NhbGVUb1B4ID0ge1xuICBzOiAxNixcbiAgbTogMjQsXG4gIGw6IDMyXG59O1xuZnVuY3Rpb24gZ2VuZXJhdGVJY29uSWQoeyBpY29uLCBzY2FsZSB9KSB7XG4gIGNvbnN0IHNpemUgPSBzY2FsZVRvUHhbc2NhbGVdO1xuICBjb25zdCBuYW1lID0gbm9ybWFsaXplSWNvbk5hbWUoaWNvbik7XG4gIGNvbnN0IGZpbGxlZCA9IG5hbWUuY2hhckF0KG5hbWUubGVuZ3RoIC0gMSkgPT09IFwiRlwiO1xuICBjb25zdCBpY29uTmFtZSA9IGZpbGxlZCA/IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSkgOiBuYW1lO1xuICByZXR1cm4gYCR7aWNvbk5hbWV9JHtzaXplfSR7ZmlsbGVkID8gXCJGXCIgOiBcIlwifWA7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEljb24ocHJvcHMpIHtcbiAgY29uc3QgY2FjaGVkSWNvbktleSA9IGdlbmVyYXRlSWNvbklkKHByb3BzKTtcbiAgY29uc3QgY2FjaGVkSWNvbkRhdGEgPSBnZXRDYWNoZWRJY29uRGF0YUJ5S2V5KGNhY2hlZEljb25LZXkpO1xuICBpZiAoY2FjaGVkSWNvbkRhdGEpIHtcbiAgICByZXR1cm4gY2FjaGVkSWNvbkRhdGE7XG4gIH1cbiAgaWYgKCFyZXF1ZXN0Q2FjaGVbY2FjaGVkSWNvbktleV0pIHtcbiAgICByZXF1ZXN0Q2FjaGVbY2FjaGVkSWNvbktleV0gPSBmZXRjaChnZXRBc3NldFBhdGgoYC4vYXNzZXRzL2ljb24vJHtjYWNoZWRJY29uS2V5fS5qc29uYCkpLnRoZW4oKHJlc3ApID0+IHJlc3AuanNvbigpKS5jYXRjaCgoKSA9PiB7XG4gICAgICBsb2dnZXIuZXJyb3IoYCR7cHJvcHMuaWNvbn0gKCR7cHJvcHMuc2NhbGV9KSBpY29uIGZhaWxlZCB0byBsb2FkYCk7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBwYXRoID0gYXdhaXQgcmVxdWVzdENhY2hlW2NhY2hlZEljb25LZXldO1xuICBpY29uQ2FjaGVbY2FjaGVkSWNvbktleV0gPSBwYXRoO1xuICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGdldENhY2hlZEljb25EYXRhKHByb3BzKSB7XG4gIHJldHVybiBnZXRDYWNoZWRJY29uRGF0YUJ5S2V5KGdlbmVyYXRlSWNvbklkKHByb3BzKSk7XG59XG5mdW5jdGlvbiBnZXRDYWNoZWRJY29uRGF0YUJ5S2V5KGlkKSB7XG4gIHJldHVybiBpY29uQ2FjaGVbaWRdO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSWNvbk5hbWUobmFtZSkge1xuICBjb25zdCBudW1iZXJMZWFkaW5nTmFtZSA9ICFpc05hTihOdW1iZXIobmFtZS5jaGFyQXQoMCkpKTtcbiAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KFwiLVwiKTtcbiAgY29uc3Qga2ViYWJDYXNlZCA9IHBhcnRzLmxlbmd0aCA+IDA7XG4gIGlmIChrZWJhYkNhc2VkKSB7XG4gICAgY29uc3QgZmlyc3ROb25EaWdpdEluUGFydFBhdHRlcm4gPSAvW2Etel0vaTtcbiAgICBuYW1lID0gcGFydHMubWFwKChwYXJ0LCBwYXJ0SW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBwYXJ0LnJlcGxhY2UoZmlyc3ROb25EaWdpdEluUGFydFBhdHRlcm4sIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgaXNGaXJzdENoYXJJbk5hbWUgPSBwYXJ0SW5kZXggPT09IDAgJiYgb2Zmc2V0ID09PSAwO1xuICAgICAgICBpZiAoaXNGaXJzdENoYXJJbk5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9XG4gIHJldHVybiBudW1iZXJMZWFkaW5nTmFtZSA/IGBpJHtuYW1lfWAgOiBuYW1lO1xufVxuY29uc3Qgc3R5bGVzID0gY3NzYDpob3N0ey0tY2FsY2l0ZS1pbnRlcm5hbC1jb2xvci1mb2N1czogdmFyKCAtLWNhbGNpdGUtY29sb3ItZm9jdXMsIHZhcigtLWNhbGNpdGUtdWktZm9jdXMtY29sb3IsIHZhcigtLWNhbGNpdGUtY29sb3ItYnJhbmQpKSApfTpob3N0e2Rpc3BsYXk6aW5saW5lLWZsZXg7Y29sb3I6dmFyKC0tY2FsY2l0ZS1pY29uLWNvbG9yLCB2YXIoLS1jYWxjaXRlLXVpLWljb24tY29sb3IsIGN1cnJlbnRDb2xvcikpfTpob3N0KFtzY2FsZT1zXSl7aW5saW5lLXNpemU6MTZweDtibG9jay1zaXplOjE2cHg7bWluLWlubGluZS1zaXplOjE2cHg7bWluLWJsb2NrLXNpemU6MTZweH06aG9zdChbc2NhbGU9bV0pe2lubGluZS1zaXplOjI0cHg7YmxvY2stc2l6ZToyNHB4O21pbi1pbmxpbmUtc2l6ZToyNHB4O21pbi1ibG9jay1zaXplOjI0cHh9Omhvc3QoW3NjYWxlPWxdKXtpbmxpbmUtc2l6ZTozMnB4O2Jsb2NrLXNpemU6MzJweDttaW4taW5saW5lLXNpemU6MzJweDttaW4tYmxvY2stc2l6ZTozMnB4fS5mbGlwLXJ0bHt0cmFuc2Zvcm06c2NhbGVYKC0xKX0uc3Zne2Rpc3BsYXk6YmxvY2t9Omhvc3QoW2hpZGRlbl0pe2Rpc3BsYXk6bm9uZX1baGlkZGVuXXtkaXNwbGF5Om5vbmV9YDtcbmNsYXNzIEljb24gZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLmZsaXBSdGwgPSBmYWxzZTtcbiAgICB0aGlzLmljb24gPSBudWxsO1xuICAgIHRoaXMucHJlbG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuc2NhbGUgPSBcIm1cIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMucHJvcGVydGllcyA9IHsgcGF0aERhdGE6IFsxNiwge30sIHsgc3RhdGU6IHRydWUgfV0sIHZpc2libGU6IFsxNiwge30sIHsgc3RhdGU6IHRydWUgfV0sIGZsaXBSdGw6IFs3LCB7fSwgeyByZWZsZWN0OiB0cnVlLCB0eXBlOiBCb29sZWFuIH1dLCBpY29uOiBbMywge30sIHsgcmVmbGVjdDogdHJ1ZSB9XSwgcHJlbG9hZDogWzcsIHt9LCB7IHJlZmxlY3Q6IHRydWUsIHR5cGU6IEJvb2xlYW4gfV0sIHNjYWxlOiBbMywge30sIHsgcmVmbGVjdDogdHJ1ZSB9XSwgdGV4dExhYmVsOiAxIH07XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIGlmICh0aGlzLnByZWxvYWQpIHtcbiAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmxvYWRJY29uUGF0aERhdGEoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnZpc2libGUpIHtcbiAgICAgIHRoaXMud2FpdFVudGlsVmlzaWJsZSgoKSA9PiB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMubG9hZEljb25QYXRoRGF0YSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHdpbGxVcGRhdGUoY2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzLmhhcyhcImljb25cIikgJiYgKHRoaXMuaGFzVXBkYXRlZCB8fCB0aGlzLmljb24gIT09IG51bGwpIHx8IGNoYW5nZXMuaGFzKFwic2NhbGVcIikgJiYgKHRoaXMuaGFzVXBkYXRlZCB8fCB0aGlzLnNjYWxlICE9PSBcIm1cIikpIHtcbiAgICAgIHRoaXMubG9hZEljb25QYXRoRGF0YSgpO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gbnVsbDtcbiAgfVxuICBhc3luYyBsb2FkSWNvblBhdGhEYXRhKCkge1xuICAgIGNvbnN0IHsgaWNvbiwgc2NhbGUsIHZpc2libGUgfSA9IHRoaXM7XG4gICAgaWYgKGlzU2VydmVyIHx8ICFpY29uIHx8ICF2aXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZldGNoSWNvblByb3BzID0geyBpY29uLCBzY2FsZSB9O1xuICAgIGNvbnN0IHBhdGhEYXRhID0gZ2V0Q2FjaGVkSWNvbkRhdGEoZmV0Y2hJY29uUHJvcHMpIHx8IGF3YWl0IGZldGNoSWNvbihmZXRjaEljb25Qcm9wcyk7XG4gICAgaWYgKGljb24gIT09IHRoaXMuaWNvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhdGhEYXRhID0gcGF0aERhdGE7XG4gIH1cbiAgd2FpdFVudGlsVmlzaWJsZShjYWxsYmFjaykge1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBjcmVhdGVPYnNlcnZlcihcImludGVyc2VjdGlvblwiLCAoZW50cmllcykgPT4ge1xuICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB7IHJvb3RNYXJnaW46IFwiNTBweFwiIH0pO1xuICAgIGlmICghdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuZWwpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGVsLCBmbGlwUnRsLCBwYXRoRGF0YSwgc2NhbGUsIHRleHRMYWJlbCB9ID0gdGhpcztcbiAgICBjb25zdCBkaXIgPSBnZXRFbGVtZW50RGlyKGVsKTtcbiAgICBjb25zdCBzaXplID0gc2NhbGVUb1B4W3NjYWxlXTtcbiAgICBjb25zdCBzZW1hbnRpYyA9ICEhdGV4dExhYmVsO1xuICAgIGNvbnN0IHBhdGhzID0gW10uY29uY2F0KHBhdGhEYXRhIHx8IFwiXCIpO1xuICAgIHRoaXMuZWwuYXJpYUhpZGRlbiA9IHRvQXJpYUJvb2xlYW4oIXNlbWFudGljKTtcbiAgICB0aGlzLmVsLmFyaWFMYWJlbCA9IHNlbWFudGljID8gdGV4dExhYmVsIDogbnVsbDtcbiAgICB0aGlzLmVsLnJvbGUgPSBzZW1hbnRpYyA/IFwiaW1nXCIgOiBudWxsO1xuICAgIHJldHVybiBodG1sYDxzdmcgYXJpYS1oaWRkZW49dHJ1ZSBjbGFzcz0ke3NhZmVDbGFzc01hcCh7XG4gICAgICBbQ1NTLmZsaXBSdGxdOiBkaXIgPT09IFwicnRsXCIgJiYgZmxpcFJ0bCxcbiAgICAgIFtDU1Muc3ZnXTogdHJ1ZVxuICAgIH0pfSBmaWxsPWN1cnJlbnRDb2xvciBoZWlnaHQ9MTAwJSB2aWV3Qm94PSR7YDAgMCAke3NpemV9ICR7c2l6ZX1gfSB3aWR0aD0xMDAlIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnPiR7cGF0aHMubWFwKChwYXRoKSA9PiB0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiA/IHN2Z2A8cGF0aCBkPSR7cGF0aCA/PyBub3RoaW5nfSAvPmAgOiBzdmdgPHBhdGggZD0ke3BhdGguZCA/PyBub3RoaW5nfSBvcGFjaXR5PSR7KFwib3BhY2l0eVwiIGluIHBhdGggPyBwYXRoLm9wYWNpdHkgOiAxKSA/PyBub3RoaW5nfSAvPmApfTwvc3ZnPmA7XG4gIH1cbn1cbmN1c3RvbUVsZW1lbnQoXCJjYWxjaXRlLWljb25cIiwgSWNvbik7XG5leHBvcnQge1xuICBJY29uXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG4vLyBBbnkgbmV3IGV4cG9ydHMgbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgZXhwb3J0IHN0YXRlbWVudCBpblxuLy8gYHBhY2thZ2VzL2xpdC9zcmMvaW5kZXguYWxsLnRzYC5cbmltcG9ydCB7IGh0bWwgYXMgY29yZUh0bWwsIHN2ZyBhcyBjb3JlU3ZnLCBtYXRobWwgYXMgY29yZU1hdGhtbCwgfSBmcm9tICcuL2xpdC1odG1sLmpzJztcbi8qKlxuICogUHJldmVudHMgSlNPTiBpbmplY3Rpb24gYXR0YWNrcy5cbiAqXG4gKiBUaGUgZ29hbHMgb2YgdGhpcyBicmFuZDpcbiAqICAgMSkgZmFzdCB0byBjaGVja1xuICogICAyKSBjb2RlIGlzIHNtYWxsIG9uIHRoZSB3aXJlXG4gKiAgIDMpIG11bHRpcGxlIHZlcnNpb25zIG9mIExpdCBpbiBhIHNpbmdsZSBwYWdlIHdpbGwgYWxsIHByb2R1Y2UgbXV0dWFsbHlcbiAqICAgICAgaW50ZXJvcGVyYWJsZSBTdGF0aWNWYWx1ZXNcbiAqICAgNCkgbm9ybWFsIEpTT04ucGFyc2UgKHdpdGhvdXQgYW4gdW51c3VhbCByZXZpdmVyKSBjYW4gbm90IHByb2R1Y2UgYVxuICogICAgICBTdGF0aWNWYWx1ZVxuICpcbiAqIFN5bWJvbHMgc2F0aXNmeSAoMSksICgyKSwgYW5kICg0KS4gV2UgdXNlIFN5bWJvbC5mb3IgdG8gc2F0aXNmeSAoMyksIGJ1dFxuICogd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUga2V5LCBzbyB3ZSBicmVhayB0aWVzIHZpYSAoMikgYW5kIHVzZSB0aGUgZW1wdHlcbiAqIHN0cmluZy5cbiAqL1xuY29uc3QgYnJhbmQgPSBTeW1ib2wuZm9yKCcnKTtcbi8qKiBTYWZlbHkgZXh0cmFjdHMgdGhlIHN0cmluZyBwYXJ0IG9mIGEgU3RhdGljVmFsdWUuICovXG5jb25zdCB1bndyYXBTdGF0aWNWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZT8uciAhPT0gYnJhbmQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlPy5bJ18kbGl0U3RhdGljJCddO1xufTtcbi8qKlxuICogV3JhcHMgYSBzdHJpbmcgc28gdGhhdCBpdCBiZWhhdmVzIGxpa2UgcGFydCBvZiB0aGUgc3RhdGljIHRlbXBsYXRlXG4gKiBzdHJpbmdzIGluc3RlYWQgb2YgYSBkeW5hbWljIHZhbHVlLlxuICpcbiAqIFVzZXJzIG11c3QgdGFrZSBjYXJlIHRvIGVuc3VyZSB0aGF0IGFkZGluZyB0aGUgc3RhdGljIHN0cmluZyB0byB0aGUgdGVtcGxhdGVcbiAqIHJlc3VsdHMgaW4gd2VsbC1mb3JtZWQgSFRNTCwgb3IgZWxzZSB0ZW1wbGF0ZXMgbWF5IGJyZWFrIHVuZXhwZWN0ZWRseS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyB1bnNhZmUgdG8gdXNlIG9uIHVudHJ1c3RlZCBjb250ZW50LCBhcyBpdCB3aWxsIGJlXG4gKiBkaXJlY3RseSBwYXJzZWQgaW50byBIVE1MLiBEbyBub3QgcGFzcyB1c2VyIGlucHV0IHRvIHRoaXMgZnVuY3Rpb25cbiAqIHdpdGhvdXQgc2FuaXRpemluZyBpdC5cbiAqXG4gKiBTdGF0aWMgdmFsdWVzIGNhbiBiZSBjaGFuZ2VkLCBidXQgdGhleSB3aWxsIGNhdXNlIGEgY29tcGxldGUgcmUtcmVuZGVyXG4gKiBzaW5jZSB0aGV5IGVmZmVjdGl2ZWx5IGNyZWF0ZSBhIG5ldyB0ZW1wbGF0ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuc2FmZVN0YXRpYyA9ICh2YWx1ZSkgPT4gKHtcbiAgICBbJ18kbGl0U3RhdGljJCddOiB2YWx1ZSxcbiAgICByOiBicmFuZCxcbn0pO1xuY29uc3QgdGV4dEZyb21TdGF0aWMgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWVbJ18kbGl0U3RhdGljJCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlWydfJGxpdFN0YXRpYyQnXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgcGFzc2VkIHRvICdsaXRlcmFsJyBmdW5jdGlvbiBtdXN0IGJlIGEgJ2xpdGVyYWwnIHJlc3VsdDogJHt2YWx1ZX0uIFVzZSAndW5zYWZlU3RhdGljJyB0byBwYXNzIG5vbi1saXRlcmFsIHZhbHVlcywgYnV0XG4gICAgICAgICAgICB0YWtlIGNhcmUgdG8gZW5zdXJlIHBhZ2Ugc2VjdXJpdHkuYCk7XG4gICAgfVxufTtcbi8qKlxuICogVGFncyBhIHN0cmluZyBsaXRlcmFsIHNvIHRoYXQgaXQgYmVoYXZlcyBsaWtlIHBhcnQgb2YgdGhlIHN0YXRpYyB0ZW1wbGF0ZVxuICogc3RyaW5ncyBpbnN0ZWFkIG9mIGEgZHluYW1pYyB2YWx1ZS5cbiAqXG4gKiBUaGUgb25seSB2YWx1ZXMgdGhhdCBtYXkgYmUgdXNlZCBpbiB0ZW1wbGF0ZSBleHByZXNzaW9ucyBhcmUgb3RoZXIgdGFnZ2VkXG4gKiBgbGl0ZXJhbGAgcmVzdWx0cyBvciBgdW5zYWZlU3RhdGljYCB2YWx1ZXMgKG5vdGUgdGhhdCB1bnRydXN0ZWQgY29udGVudFxuICogc2hvdWxkIG5ldmVyIGJlIHBhc3NlZCB0byBgdW5zYWZlU3RhdGljYCkuXG4gKlxuICogVXNlcnMgbXVzdCB0YWtlIGNhcmUgdG8gZW5zdXJlIHRoYXQgYWRkaW5nIHRoZSBzdGF0aWMgc3RyaW5nIHRvIHRoZSB0ZW1wbGF0ZVxuICogcmVzdWx0cyBpbiB3ZWxsLWZvcm1lZCBIVE1MLCBvciBlbHNlIHRlbXBsYXRlcyBtYXkgYnJlYWsgdW5leHBlY3RlZGx5LlxuICpcbiAqIFN0YXRpYyB2YWx1ZXMgY2FuIGJlIGNoYW5nZWQsIGJ1dCB0aGV5IHdpbGwgY2F1c2UgYSBjb21wbGV0ZSByZS1yZW5kZXIgc2luY2VcbiAqIHRoZXkgZWZmZWN0aXZlbHkgY3JlYXRlIGEgbmV3IHRlbXBsYXRlLlxuICovXG5leHBvcnQgY29uc3QgbGl0ZXJhbCA9IChzdHJpbmdzLCAuLi52YWx1ZXMpID0+ICh7XG4gICAgWydfJGxpdFN0YXRpYyQnXTogdmFsdWVzLnJlZHVjZSgoYWNjLCB2LCBpZHgpID0+IGFjYyArIHRleHRGcm9tU3RhdGljKHYpICsgc3RyaW5nc1tpZHggKyAxXSwgc3RyaW5nc1swXSksXG4gICAgcjogYnJhbmQsXG59KTtcbmNvbnN0IHN0cmluZ3NDYWNoZSA9IG5ldyBNYXAoKTtcbi8qKlxuICogV3JhcHMgYSBsaXQtaHRtbCB0ZW1wbGF0ZSB0YWcgKGBodG1sYCBvciBgc3ZnYCkgdG8gYWRkIHN0YXRpYyB2YWx1ZSBzdXBwb3J0LlxuICovXG5leHBvcnQgY29uc3Qgd2l0aFN0YXRpYyA9IChjb3JlVGFnKSA9PiAoc3RyaW5ncywgLi4udmFsdWVzKSA9PiB7XG4gICAgY29uc3QgbCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgbGV0IHN0YXRpY1ZhbHVlO1xuICAgIGxldCBkeW5hbWljVmFsdWU7XG4gICAgY29uc3Qgc3RhdGljU3RyaW5ncyA9IFtdO1xuICAgIGNvbnN0IGR5bmFtaWNWYWx1ZXMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGhhc1N0YXRpY3MgPSBmYWxzZTtcbiAgICBsZXQgcztcbiAgICB3aGlsZSAoaSA8IGwpIHtcbiAgICAgICAgcyA9IHN0cmluZ3NbaV07XG4gICAgICAgIC8vIENvbGxlY3QgYW55IHVuc2FmZVN0YXRpYyB2YWx1ZXMsIGFuZCB0aGVpciBmb2xsb3dpbmcgdGVtcGxhdGUgc3RyaW5nc1xuICAgICAgICAvLyBzbyB0aGF0IHdlIHRyZWF0IGEgcnVuIG9mIHRlbXBsYXRlIHN0cmluZ3MgYW5kIHVuc2FmZSBzdGF0aWMgdmFsdWVzIGFzXG4gICAgICAgIC8vIGEgc2luZ2xlIHRlbXBsYXRlIHN0cmluZy5cbiAgICAgICAgd2hpbGUgKGkgPCBsICYmXG4gICAgICAgICAgICAoKGR5bmFtaWNWYWx1ZSA9IHZhbHVlc1tpXSksXG4gICAgICAgICAgICAgICAgKHN0YXRpY1ZhbHVlID0gdW53cmFwU3RhdGljVmFsdWUoZHluYW1pY1ZhbHVlKSkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMgKz0gc3RhdGljVmFsdWUgKyBzdHJpbmdzWysraV07XG4gICAgICAgICAgICBoYXNTdGF0aWNzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgbGFzdCB2YWx1ZSBpcyBzdGF0aWMsIHdlIGRvbid0IG5lZWQgdG8gcHVzaCBpdC5cbiAgICAgICAgaWYgKGkgIT09IGwpIHtcbiAgICAgICAgICAgIGR5bmFtaWNWYWx1ZXMucHVzaChkeW5hbWljVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpY1N0cmluZ3MucHVzaChzKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbGFzdCB2YWx1ZSBpc24ndCBzdGF0aWMgKHdoaWNoIHdvdWxkIGhhdmUgY29uc3VtZWQgdGhlIGxhc3RcbiAgICAvLyBzdHJpbmcpLCB0aGVuIHdlIG5lZWQgdG8gYWRkIHRoZSBsYXN0IHN0cmluZy5cbiAgICBpZiAoaSA9PT0gbCkge1xuICAgICAgICBzdGF0aWNTdHJpbmdzLnB1c2goc3RyaW5nc1tsXSk7XG4gICAgfVxuICAgIGlmIChoYXNTdGF0aWNzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHN0YXRpY1N0cmluZ3Muam9pbignJCRsaXQkJCcpO1xuICAgICAgICBzdHJpbmdzID0gc3RyaW5nc0NhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoc3RyaW5ncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBCZXdhcmU6IGluIGdlbmVyYWwgdGhpcyBwYXR0ZXJuIGlzIHVuc2FmZSwgYW5kIGRvaW5nIHNvIG1heSBieXBhc3NcbiAgICAgICAgICAgIC8vIGxpdCdzIHNlY3VyaXR5IGNoZWNrcyBhbmQgYWxsb3cgYW4gYXR0YWNrZXIgdG8gZXhlY3V0ZSBhcmJpdHJhcnlcbiAgICAgICAgICAgIC8vIGNvZGUgYW5kIGluamVjdCBhcmJpdHJhcnkgY29udGVudC5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBzdGF0aWNTdHJpbmdzLnJhdyA9IHN0YXRpY1N0cmluZ3M7XG4gICAgICAgICAgICBzdHJpbmdzQ2FjaGUuc2V0KGtleSwgKHN0cmluZ3MgPSBzdGF0aWNTdHJpbmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzID0gZHluYW1pY1ZhbHVlcztcbiAgICB9XG4gICAgcmV0dXJuIGNvcmVUYWcoc3RyaW5ncywgLi4udmFsdWVzKTtcbn07XG4vKipcbiAqIEludGVycHJldHMgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIGFuIEhUTUwgdGVtcGxhdGUgdGhhdCBjYW4gZWZmaWNpZW50bHlcbiAqIHJlbmRlciB0byBhbmQgdXBkYXRlIGEgY29udGFpbmVyLlxuICpcbiAqIEluY2x1ZGVzIHN0YXRpYyB2YWx1ZSBzdXBwb3J0IGZyb20gYGxpdC1odG1sL3N0YXRpYy5qc2AuXG4gKi9cbmV4cG9ydCBjb25zdCBodG1sID0gd2l0aFN0YXRpYyhjb3JlSHRtbCk7XG4vKipcbiAqIEludGVycHJldHMgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIGFuIFNWRyB0ZW1wbGF0ZSB0aGF0IGNhbiBlZmZpY2llbnRseVxuICogcmVuZGVyIHRvIGFuZCB1cGRhdGUgYSBjb250YWluZXIuXG4gKlxuICogSW5jbHVkZXMgc3RhdGljIHZhbHVlIHN1cHBvcnQgZnJvbSBgbGl0LWh0bWwvc3RhdGljLmpzYC5cbiAqL1xuZXhwb3J0IGNvbnN0IHN2ZyA9IHdpdGhTdGF0aWMoY29yZVN2Zyk7XG4vKipcbiAqIEludGVycHJldHMgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIE1hdGhNTCBmcmFnbWVudCB0aGF0IGNhbiBlZmZpY2llbnRseSByZW5kZXJcbiAqIHRvIGFuZCB1cGRhdGUgYSBjb250YWluZXIuXG4gKlxuICogSW5jbHVkZXMgc3RhdGljIHZhbHVlIHN1cHBvcnQgZnJvbSBgbGl0LWh0bWwvc3RhdGljLmpzYC5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGhtbCA9IHdpdGhTdGF0aWMoY29yZU1hdGhtbCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0aWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9