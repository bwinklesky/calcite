export const __webpack_id__ = "vendors-node_modules_arcgis_core_views_2d_engine_vectorTiles_shaders_VTLMaterialManager_js";
export const __webpack_ids__ = ["vendors-node_modules_arcgis_core_views_2d_engine_vectorTiles_shaders_VTLMaterialManager_js"];
export const __webpack_modules__ = {

/***/ "./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/Programs.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/Programs.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   background: () => (/* binding */ a),
/* harmony export */   circle: () => (/* binding */ d),
/* harmony export */   fill: () => (/* binding */ i),
/* harmony export */   icon: () => (/* binding */ f),
/* harmony export */   line: () => (/* binding */ o),
/* harmony export */   outline: () => (/* binding */ l),
/* harmony export */   text: () => (/* binding */ g)
/* harmony export */ });
/* harmony import */ var _sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sources/resolver.js */ "./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js");
/* harmony import */ var _webgl_programUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../webgl/programUtils.js */ "./node_modules/@arcgis/core/views/webgl/programUtils.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const t=e=>(0,_webgl_programUtils_js__WEBPACK_IMPORTED_MODULE_1__.glslifyDefineMap)({PATTERN:e.pattern}),a={shaders:r=>({vertexShader:t(r)+(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("background/background.vert"),fragmentShader:t(r)+(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("background/background.frag")})},d={shaders:r=>({vertexShader:(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("circle/circle.vert"),fragmentShader:(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("circle/circle.frag")})},n=e=>(0,_webgl_programUtils_js__WEBPACK_IMPORTED_MODULE_1__.glslifyDefineMap)({PATTERN:e.pattern}),i={shaders:r=>({vertexShader:n(r)+(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("fill/fill.vert"),fragmentShader:n(r)+(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("fill/fill.frag")})},l={shaders:r=>({vertexShader:(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("outline/outline.vert"),fragmentShader:(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("outline/outline.frag")})},s=e=>(0,_webgl_programUtils_js__WEBPACK_IMPORTED_MODULE_1__.glslifyDefineMap)({SDF:e.sdf}),f={shaders:r=>({vertexShader:s(r)+(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("icon/icon.vert"),fragmentShader:s(r)+(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("icon/icon.frag")})},h=e=>(0,_webgl_programUtils_js__WEBPACK_IMPORTED_MODULE_1__.glslifyDefineMap)({PATTERN:e.pattern,SDF:e.sdf}),o={shaders:r=>({vertexShader:h(r)+(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("line/line.vert"),fragmentShader:h(r)+(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("line/line.frag")})},g={shaders:r=>({vertexShader:(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("text/text.vert"),fragmentShader:(0,_sources_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveIncludes)("text/text.frag")})};


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLMaterialManager.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLMaterialManager.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ p)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@arcgis/core/views/2d/engine/vectorTiles/enums.js");
/* harmony import */ var _Programs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Programs.js */ "./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/Programs.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
class p{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach((e=>e.dispose())),this._programByKey.clear()}getMaterialProgram(e,r,t){const a=r.key<<3|this._getMaterialOptionsValue(r.type,t);if(this._programByKey.has(a))return this._programByKey.get(a);const s=this._getProgramTemplate(r.type),{shaders:n}=s,{vertexShader:c,fragmentShader:o}=n(t),p=r.getShaderHeader(),u=r.getShaderMain(),i=c.replace("#pragma header",p).replace("#pragma main",u),g=e.programCache.acquire(i,o,r.getAttributeLocations());return this._programByKey.set(a,g),g}_getMaterialOptionsValue(r,t){switch(r){case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.BACKGROUND:return(t.pattern?1:0)<<1;case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.FILL:return(t.pattern?1:0)<<1;case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.OUTLINE:return 0;case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.LINE:{const e=t;return(e.sdf?1:0)<<2|(e.pattern?1:0)<<1}case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.ICON:return(t.sdf?1:0)<<1;case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.CIRCLE:case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.TEXT:default:return 0}}_getProgramTemplate(p){switch(p){case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.BACKGROUND:return _Programs_js__WEBPACK_IMPORTED_MODULE_1__.background;case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.CIRCLE:return _Programs_js__WEBPACK_IMPORTED_MODULE_1__.circle;case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.FILL:return _Programs_js__WEBPACK_IMPORTED_MODULE_1__.fill;case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.ICON:return _Programs_js__WEBPACK_IMPORTED_MODULE_1__.icon;case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.LINE:return _Programs_js__WEBPACK_IMPORTED_MODULE_1__.line;case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.OUTLINE:return _Programs_js__WEBPACK_IMPORTED_MODULE_1__.outline;case _enums_js__WEBPACK_IMPORTED_MODULE_0__.ShaderProgramType.TEXT:return _Programs_js__WEBPACK_IMPORTED_MODULE_1__.text;default:return null}}}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveIncludes: () => (/* binding */ n)
/* harmony export */ });
/* harmony import */ var _shaderRepository_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaderRepository.js */ "./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js");
/* harmony import */ var _webgl_ShaderCompiler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../webgl/ShaderCompiler.js */ "./node_modules/@arcgis/core/views/webgl/ShaderCompiler.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
function o(e){let o=_shaderRepository_js__WEBPACK_IMPORTED_MODULE_0__["default"];return e.split("/").forEach((r=>{o&&(o=o[r])})),o}const t=new _webgl_ShaderCompiler_js__WEBPACK_IMPORTED_MODULE_1__.ShaderCompiler(o);function n(r){return t.resolveIncludes(r)}


/***/ }),

/***/ "./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
const e={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}};


/***/ }),

/***/ "./node_modules/@arcgis/core/views/webgl/programUtils.js":
/*!***************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/webgl/programUtils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   glslifyDefineMap: () => (/* binding */ n)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
function e(e){const{options:n,value:o}=e;return"number"==typeof n[o]}function n(n){let o="";for(const t in n){const i=n[t];if("boolean"==typeof i)i&&(o+=`#define ${t}\n`);else if("number"==typeof i)o+=`#define ${t} ${i.toFixed()}\n`;else if("object"==typeof i)if(e(i)){const{value:e,options:n,namespace:f}=i,s=f?`${f}_`:"";for(const t in n)o+=`#define ${s}${t} ${n[t].toFixed()}\n`;o+=`#define ${t} ${s}${e}\n`}else{const e=i.options;let n=0;for(const t in e)o+=`#define ${e[t]} ${(n++).toFixed()}\n`;o+=`#define ${t} ${e[i.value]}\n`}}return o}


/***/ })

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYXJjZ2lzX2NvcmVfdmlld3NfMmRfZW5naW5lX3ZlY3RvclRpbGVzX3NoYWRlcnNfVlRMTWF0ZXJpYWxNYW5hZ2VyX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM2SCxXQUFXLHdFQUFDLEVBQUUsa0JBQWtCLEtBQUssYUFBYSxrQkFBa0IscUVBQUMsbURBQW1ELHFFQUFDLCtCQUErQixFQUFFLElBQUksYUFBYSxhQUFhLHFFQUFDLHNDQUFzQyxxRUFBQyx1QkFBdUIsRUFBRSxNQUFNLHdFQUFDLEVBQUUsa0JBQWtCLEtBQUssYUFBYSxrQkFBa0IscUVBQUMsdUNBQXVDLHFFQUFDLG1CQUFtQixFQUFFLElBQUksYUFBYSxhQUFhLHFFQUFDLHdDQUF3QyxxRUFBQyx5QkFBeUIsRUFBRSxNQUFNLHdFQUFDLEVBQUUsVUFBVSxLQUFLLGFBQWEsa0JBQWtCLHFFQUFDLHVDQUF1QyxxRUFBQyxtQkFBbUIsRUFBRSxNQUFNLHdFQUFDLEVBQUUsNEJBQTRCLEtBQUssYUFBYSxrQkFBa0IscUVBQUMsdUNBQXVDLHFFQUFDLG1CQUFtQixFQUFFLElBQUksYUFBYSxhQUFhLHFFQUFDLGtDQUFrQyxxRUFBQyxtQkFBbUIsR0FBNEY7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSm5nQztBQUNBO0FBQ0E7QUFDQTtBQUM0SixRQUFRLGNBQWMsMkJBQTJCLFVBQVUsd0VBQXdFLDBCQUEwQix5REFBeUQsOERBQThELDBDQUEwQyxVQUFVLElBQUksZ0NBQWdDLGtLQUFrSyxxQ0FBcUMsOEJBQThCLFVBQVUsS0FBSyx3REFBQyxxQ0FBcUMsS0FBSyx3REFBQywrQkFBK0IsS0FBSyx3REFBQyxrQkFBa0IsS0FBSyx3REFBQyxPQUFPLFVBQVUsd0NBQXdDLEtBQUssd0RBQUMsMkJBQTJCLEtBQUssd0RBQUMsYUFBYSx3REFBQyx3QkFBd0IsdUJBQXVCLFVBQVUsS0FBSyx3REFBQyxtQkFBbUIs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QUErQywrQ0FBK0MsbURBQW1ELHFEQUFxRCxxREFBcUQsOEJBQThCLDREQUE0RCx1Q0FBdUMsa0hBQWtILEdBQUcsU0FBUyxrSEFBa0gsR0FBRyw2Q0FBNkMsdUNBQXVDLG1DQUFtQyxrQ0FBa0MsK0NBQStDLHlEQUF5RCx5TEFBeUwscURBQXFELEdBQUcsRUFBRSxPQUFPLGlMQUFpTCwrQkFBK0IsdUNBQXVDLEdBQUcsMENBQTBDLHNDQUFzQyxHQUFHLElBQXlCOzs7Ozs7Ozs7Ozs7Ozs7QUNKOTllO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNLGtCQUFrQixHQUFHLDRCQUE0QixjQUFjLFNBQVMsa0JBQWtCLGFBQWEseUNBQXlDLEVBQUUsS0FBSyx5Q0FBeUMsR0FBRyxFQUFFLFlBQVksSUFBSSxvQ0FBb0MsTUFBTSw4QkFBOEIsVUFBVSxFQUFFLE1BQU0sK0JBQStCLEVBQUUsRUFBRSxHQUFHLEVBQUUsZUFBZSxJQUFJLGNBQWMsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLElBQUksS0FBSyxrQkFBa0IsUUFBUSwrQkFBK0IsTUFBTSxFQUFFLGdCQUFnQixJQUFJLGNBQWMsR0FBRyxFQUFFLFdBQVcsS0FBSyxTQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy8yZC9lbmdpbmUvdmVjdG9yVGlsZXMvc2hhZGVycy9Qcm9ncmFtcy5qcyIsIndlYnBhY2s6Ly9wcmVjaXNpb25mYXJtcy8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvdmlld3MvMmQvZW5naW5lL3ZlY3RvclRpbGVzL3NoYWRlcnMvVlRMTWF0ZXJpYWxNYW5hZ2VyLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy8yZC9lbmdpbmUvdmVjdG9yVGlsZXMvc2hhZGVycy9zb3VyY2VzL3Jlc29sdmVyLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS92aWV3cy8yZC9lbmdpbmUvdmVjdG9yVGlsZXMvc2hhZGVycy9zb3VyY2VzL3NoYWRlclJlcG9zaXRvcnkuanMiLCJ3ZWJwYWNrOi8vcHJlY2lzaW9uZmFybXMvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3ZpZXdzL3dlYmdsL3Byb2dyYW1VdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e3Jlc29sdmVJbmNsdWRlcyBhcyBlfWZyb21cIi4vc291cmNlcy9yZXNvbHZlci5qc1wiO2ltcG9ydHtnbHNsaWZ5RGVmaW5lTWFwIGFzIHJ9ZnJvbVwiLi4vLi4vLi4vLi4vd2ViZ2wvcHJvZ3JhbVV0aWxzLmpzXCI7Y29uc3QgdD1lPT5yKHtQQVRURVJOOmUucGF0dGVybn0pLGE9e3NoYWRlcnM6cj0+KHt2ZXJ0ZXhTaGFkZXI6dChyKStlKFwiYmFja2dyb3VuZC9iYWNrZ3JvdW5kLnZlcnRcIiksZnJhZ21lbnRTaGFkZXI6dChyKStlKFwiYmFja2dyb3VuZC9iYWNrZ3JvdW5kLmZyYWdcIil9KX0sZD17c2hhZGVyczpyPT4oe3ZlcnRleFNoYWRlcjplKFwiY2lyY2xlL2NpcmNsZS52ZXJ0XCIpLGZyYWdtZW50U2hhZGVyOmUoXCJjaXJjbGUvY2lyY2xlLmZyYWdcIil9KX0sbj1lPT5yKHtQQVRURVJOOmUucGF0dGVybn0pLGk9e3NoYWRlcnM6cj0+KHt2ZXJ0ZXhTaGFkZXI6bihyKStlKFwiZmlsbC9maWxsLnZlcnRcIiksZnJhZ21lbnRTaGFkZXI6bihyKStlKFwiZmlsbC9maWxsLmZyYWdcIil9KX0sbD17c2hhZGVyczpyPT4oe3ZlcnRleFNoYWRlcjplKFwib3V0bGluZS9vdXRsaW5lLnZlcnRcIiksZnJhZ21lbnRTaGFkZXI6ZShcIm91dGxpbmUvb3V0bGluZS5mcmFnXCIpfSl9LHM9ZT0+cih7U0RGOmUuc2RmfSksZj17c2hhZGVyczpyPT4oe3ZlcnRleFNoYWRlcjpzKHIpK2UoXCJpY29uL2ljb24udmVydFwiKSxmcmFnbWVudFNoYWRlcjpzKHIpK2UoXCJpY29uL2ljb24uZnJhZ1wiKX0pfSxoPWU9PnIoe1BBVFRFUk46ZS5wYXR0ZXJuLFNERjplLnNkZn0pLG89e3NoYWRlcnM6cj0+KHt2ZXJ0ZXhTaGFkZXI6aChyKStlKFwibGluZS9saW5lLnZlcnRcIiksZnJhZ21lbnRTaGFkZXI6aChyKStlKFwibGluZS9saW5lLmZyYWdcIil9KX0sZz17c2hhZGVyczpyPT4oe3ZlcnRleFNoYWRlcjplKFwidGV4dC90ZXh0LnZlcnRcIiksZnJhZ21lbnRTaGFkZXI6ZShcInRleHQvdGV4dC5mcmFnXCIpfSl9O2V4cG9ydHthIGFzIGJhY2tncm91bmQsZCBhcyBjaXJjbGUsaSBhcyBmaWxsLGYgYXMgaWNvbixvIGFzIGxpbmUsbCBhcyBvdXRsaW5lLGcgYXMgdGV4dH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e1NoYWRlclByb2dyYW1UeXBlIGFzIGV9ZnJvbVwiLi4vZW51bXMuanNcIjtpbXBvcnR7dGV4dCBhcyByLG91dGxpbmUgYXMgdCxsaW5lIGFzIGEsaWNvbiBhcyBzLGZpbGwgYXMgbixjaXJjbGUgYXMgYyxiYWNrZ3JvdW5kIGFzIG99ZnJvbVwiLi9Qcm9ncmFtcy5qc1wiO2NsYXNzIHB7Y29uc3RydWN0b3IoKXt0aGlzLl9wcm9ncmFtQnlLZXk9bmV3IE1hcH1kaXNwb3NlKCl7dGhpcy5fcHJvZ3JhbUJ5S2V5LmZvckVhY2goKGU9PmUuZGlzcG9zZSgpKSksdGhpcy5fcHJvZ3JhbUJ5S2V5LmNsZWFyKCl9Z2V0TWF0ZXJpYWxQcm9ncmFtKGUscix0KXtjb25zdCBhPXIua2V5PDwzfHRoaXMuX2dldE1hdGVyaWFsT3B0aW9uc1ZhbHVlKHIudHlwZSx0KTtpZih0aGlzLl9wcm9ncmFtQnlLZXkuaGFzKGEpKXJldHVybiB0aGlzLl9wcm9ncmFtQnlLZXkuZ2V0KGEpO2NvbnN0IHM9dGhpcy5fZ2V0UHJvZ3JhbVRlbXBsYXRlKHIudHlwZSkse3NoYWRlcnM6bn09cyx7dmVydGV4U2hhZGVyOmMsZnJhZ21lbnRTaGFkZXI6b309bih0KSxwPXIuZ2V0U2hhZGVySGVhZGVyKCksdT1yLmdldFNoYWRlck1haW4oKSxpPWMucmVwbGFjZShcIiNwcmFnbWEgaGVhZGVyXCIscCkucmVwbGFjZShcIiNwcmFnbWEgbWFpblwiLHUpLGc9ZS5wcm9ncmFtQ2FjaGUuYWNxdWlyZShpLG8sci5nZXRBdHRyaWJ1dGVMb2NhdGlvbnMoKSk7cmV0dXJuIHRoaXMuX3Byb2dyYW1CeUtleS5zZXQoYSxnKSxnfV9nZXRNYXRlcmlhbE9wdGlvbnNWYWx1ZShyLHQpe3N3aXRjaChyKXtjYXNlIGUuQkFDS0dST1VORDpyZXR1cm4odC5wYXR0ZXJuPzE6MCk8PDE7Y2FzZSBlLkZJTEw6cmV0dXJuKHQucGF0dGVybj8xOjApPDwxO2Nhc2UgZS5PVVRMSU5FOnJldHVybiAwO2Nhc2UgZS5MSU5FOntjb25zdCBlPXQ7cmV0dXJuKGUuc2RmPzE6MCk8PDJ8KGUucGF0dGVybj8xOjApPDwxfWNhc2UgZS5JQ09OOnJldHVybih0LnNkZj8xOjApPDwxO2Nhc2UgZS5DSVJDTEU6Y2FzZSBlLlRFWFQ6ZGVmYXVsdDpyZXR1cm4gMH19X2dldFByb2dyYW1UZW1wbGF0ZShwKXtzd2l0Y2gocCl7Y2FzZSBlLkJBQ0tHUk9VTkQ6cmV0dXJuIG87Y2FzZSBlLkNJUkNMRTpyZXR1cm4gYztjYXNlIGUuRklMTDpyZXR1cm4gbjtjYXNlIGUuSUNPTjpyZXR1cm4gcztjYXNlIGUuTElORTpyZXR1cm4gYTtjYXNlIGUuT1VUTElORTpyZXR1cm4gdDtjYXNlIGUuVEVYVDpyZXR1cm4gcjtkZWZhdWx0OnJldHVybiBudWxsfX19ZXhwb3J0e3AgYXMgZGVmYXVsdH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4zMy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0IHIgZnJvbVwiLi9zaGFkZXJSZXBvc2l0b3J5LmpzXCI7aW1wb3J0e1NoYWRlckNvbXBpbGVyIGFzIGV9ZnJvbVwiLi4vLi4vLi4vLi4vLi4vd2ViZ2wvU2hhZGVyQ29tcGlsZXIuanNcIjtmdW5jdGlvbiBvKGUpe2xldCBvPXI7cmV0dXJuIGUuc3BsaXQoXCIvXCIpLmZvckVhY2goKHI9PntvJiYobz1vW3JdKX0pKSxvfWNvbnN0IHQ9bmV3IGUobyk7ZnVuY3Rpb24gbihyKXtyZXR1cm4gdC5yZXNvbHZlSW5jbHVkZXMocil9ZXhwb3J0e24gYXMgcmVzb2x2ZUluY2x1ZGVzfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjMzL2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5jb25zdCBlPXtiYWNrZ3JvdW5kOntcImJhY2tncm91bmQuZnJhZ1wiOlwiI2lmZGVmIFBBVFRFUk5cXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9vcGFjaXR5O1xcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IHZfdGxicjtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RpbGVUZXh0dXJlQ29vcmQ7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3AgdmVjNCB1X2NvbG9yO1xcbiNlbmRpZlxcbnZvaWQgbWFpbigpIHtcXG4jaWZkZWYgUEFUVEVSTlxcbm1lZGl1bXAgdmVjMiBub3JtYWxpemVkVGV4dHVyZUNvb3JkID0gbW9kKHZfdGlsZVRleHR1cmVDb29yZCwgMS4wKTtcXG5tZWRpdW1wIHZlYzIgc2FtcGxlUG9zID0gbWl4KHZfdGxici54eSwgdl90bGJyLnp3LCBub3JtYWxpemVkVGV4dHVyZUNvb3JkKTtcXG5sb3dwIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCBzYW1wbGVQb3MpO1xcbmdsX0ZyYWdDb2xvciA9IHVfb3BhY2l0eSAqIGNvbG9yO1xcbiNlbHNlXFxuZ2xfRnJhZ0NvbG9yID0gdV9jb2xvcjtcXG4jZW5kaWZcXG59XCIsXCJiYWNrZ3JvdW5kLnZlcnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2R2c01hdDM7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfY29vcmRfcmFuZ2U7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfZGVwdGg7XFxuI2lmZGVmIFBBVFRFUk5cXG51bmlmb3JtIG1lZGl1bXAgbWF0MyB1X3BhdHRlcm5fbWF0cml4O1xcbnZhcnlpbmcgbWVkaXVtcCB2ZWMyIHZfdGlsZVRleHR1cmVDb29yZDtcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCB1X3RsYnI7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzIgdV9tb3NhaWNTaXplO1xcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IHZfdGxicjtcXG4jZW5kaWZcXG52b2lkIG1haW4oKSB7XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KCh1X2R2c01hdDMgKiB2ZWMzKHVfY29vcmRfcmFuZ2UgKiBhX3BvcywgMS4wKSkueHksIHVfZGVwdGgsIDEuMCk7XFxuI2lmZGVmIFBBVFRFUk5cXG52X3RpbGVUZXh0dXJlQ29vcmQgPSAodV9wYXR0ZXJuX21hdHJpeCAqIHZlYzMoYV9wb3MsIDEuMCkpLnh5O1xcbnZfdGxiciAgICAgICAgICAgICA9IHVfdGxiciAvIHVfbW9zYWljU2l6ZS54eXh5O1xcbiNlbmRpZlxcbn1cIn0sY2lyY2xlOntcImNpcmNsZS5mcmFnXCI6XCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IHZfc3Ryb2tlX2NvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2JsdXI7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfc3Ryb2tlX3dpZHRoO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X3JhZGl1cztcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X29mZnNldDtcXG52b2lkIG1haW4oKVxcbntcXG5tZWRpdW1wIGZsb2F0IGRpc3QgPSBsZW5ndGgodl9vZmZzZXQpO1xcbm1lZGl1bXAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKDAuMCwgLXZfYmx1ciwgZGlzdCAtIDEuMCk7XFxubG93cCBmbG9hdCBjb2xvcl9taXhfcmF0aW8gPSB2X3N0cm9rZV93aWR0aCA8IDAuMDEgPyAwLjAgOiBzbW9vdGhzdGVwKC12X2JsdXIsIDAuMCwgZGlzdCAtIHZfcmFkaXVzIC8gKHZfcmFkaXVzICsgdl9zdHJva2Vfd2lkdGgpKTtcXG5nbF9GcmFnQ29sb3IgPSBhbHBoYSAqIG1peCh2X2NvbG9yLCB2X3N0cm9rZV9jb2xvciwgY29sb3JfbWl4X3JhdGlvKTtcXG59XCIsXCJjaXJjbGUudmVydFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuI3ByYWdtYSBoZWFkZXJcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IHZfc3Ryb2tlX2NvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2JsdXI7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfc3Ryb2tlX3dpZHRoO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X3JhZGl1cztcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X29mZnNldDtcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kdnNNYXQzO1xcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2Rpc3BsYXlNYXQzO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVfY2lyY2xlVHJhbnNsYXRpb247XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfZGVwdGg7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfYW50aWFsaWFzaW5nV2lkdGg7XFxudm9pZCBtYWluKClcXG57XFxuI3ByYWdtYSBtYWluXFxudl9jb2xvciA9IGNvbG9yICogb3BhY2l0eTtcXG52X3N0cm9rZV9jb2xvciA9IHN0cm9rZV9jb2xvciAqIHN0cm9rZV9vcGFjaXR5O1xcbnZfc3Ryb2tlX3dpZHRoID0gc3Ryb2tlX3dpZHRoO1xcbnZfcmFkaXVzID0gcmFkaXVzO1xcbnZfYmx1ciA9IG1heChibHVyLCB1X2FudGlhbGlhc2luZ1dpZHRoIC8gKHJhZGl1cyArIHN0cm9rZV93aWR0aCkpO1xcbm1lZGl1bXAgdmVjMiBvZmZzZXQgPSB2ZWMyKG1vZChhX3BvcywgMi4wKSAqIDIuMCAtIDEuMCk7XFxudl9vZmZzZXQgPSBvZmZzZXQ7XFxubWVkaXVtcCB2ZWMzIHBvcyA9IHVfZHZzTWF0MyAqIHZlYzMoYV9wb3MgKiAwLjUsIDEuMCkgKyB1X2Rpc3BsYXlNYXQzICogdmVjMygodl9yYWRpdXMgKyB2X3N0cm9rZV93aWR0aCkgKiBvZmZzZXQgKyB1X2NpcmNsZVRyYW5zbGF0aW9uLCAwLjApO1xcbmdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIHVfZGVwdGgsIDEuMCk7XFxufVwifSxmaWxsOntcImZpbGwuZnJhZ1wiOlwicHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuI2lmZGVmIFBBVFRFUk5cXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RpbGVUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl90bGJyO1xcbiNlbmRpZlxcbnZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxudmVjNCBtaXhDb2xvcnModmVjNCBjb2xvcjEsIHZlYzQgY29sb3IyKSB7XFxuZmxvYXQgY29tcG9zaXRlQWxwaGEgPSBjb2xvcjIuYSArIGNvbG9yMS5hICogKDEuMCAtIGNvbG9yMi5hKTtcXG52ZWMzIGNvbXBvc2l0ZUNvbG9yID0gY29sb3IyLnJnYiArIGNvbG9yMS5yZ2IgKiAoMS4wIC0gY29sb3IyLmEpO1xcbnJldHVybiB2ZWM0KGNvbXBvc2l0ZUNvbG9yLCBjb21wb3NpdGVBbHBoYSk7XFxufVxcbnZvaWQgbWFpbigpXFxue1xcbiNpZmRlZiBQQVRURVJOXFxubWVkaXVtcCB2ZWMyIG5vcm1hbGl6ZWRUZXh0dXJlQ29vcmQgPSBmcmFjdCh2X3RpbGVUZXh0dXJlQ29vcmQpO1xcbm1lZGl1bXAgdmVjMiBzYW1wbGVQb3MgPSBtaXgodl90bGJyLnh5LCB2X3RsYnIuencsIG5vcm1hbGl6ZWRUZXh0dXJlQ29vcmQpO1xcbmxvd3AgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHNhbXBsZVBvcyk7XFxuZ2xfRnJhZ0NvbG9yID0gdl9jb2xvclszXSAqIGNvbG9yO1xcbiNlbHNlXFxuZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcXG4jZW5kaWZcXG59XCIsXCJmaWxsLnZlcnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbiNwcmFnbWEgaGVhZGVyXFxudW5pZm9ybSBoaWdocCBtYXQzIHVfZHZzTWF0MztcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kaXNwbGF5TWF0MztcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9kZXB0aDtcXG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1X2ZpbGxUcmFuc2xhdGlvbjtcXG4jaWZkZWYgUEFUVEVSTlxcbiNpbmNsdWRlIDx1dGlsL3V0aWwuZ2xzbD5cXG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1X21vc2FpY1NpemU7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfcGF0dGVybkZhY3RvcjtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3RpbGVUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzQgdl90bGJyO1xcbiNlbmRpZlxcbnZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxudm9pZCBtYWluKClcXG57XFxuI3ByYWdtYSBtYWluXFxudl9jb2xvciA9IGNvbG9yICogb3BhY2l0eTtcXG4jaWZkZWYgUEFUVEVSTlxcbmZsb2F0IHBhdHRlcm5XaWR0aCA9IG5leHRQT1QodGxici56IC0gdGxici54KTtcXG5mbG9hdCBwYXR0ZXJuSGVpZ2h0ID0gbmV4dFBPVCh0bGJyLncgLSB0bGJyLnkpO1xcbmZsb2F0IHNjYWxlWCA9IDEuMCAvIChwYXR0ZXJuV2lkdGggKiB1X3BhdHRlcm5GYWN0b3IpO1xcbmZsb2F0IHNjYWxlWSA9IDEuMCAvIChwYXR0ZXJuSGVpZ2h0ICogdV9wYXR0ZXJuRmFjdG9yKTtcXG5tYXQzIHBhdHRlck1hdCA9IG1hdDMoc2NhbGVYLCAwLjAsICAgIDAuMCxcXG4wLjAsICAgIC1zY2FsZVksIDAuMCxcXG4wLjAsICAgIDAuMCwgICAgMS4wKTtcXG52X3RpbGVUZXh0dXJlQ29vcmQgPSAocGF0dGVyTWF0ICogdmVjMyhhX3BvcywgMS4wKSkueHk7XFxudl90bGJyICAgICAgICAgICAgID0gdGxiciAvIHVfbW9zYWljU2l6ZS54eXh5O1xcbiNlbmRpZlxcbnZlYzMgcG9zID0gdV9kdnNNYXQzICogdmVjMyhhX3BvcywgMS4wKSArIHVfZGlzcGxheU1hdDMgKiB2ZWMzKHVfZmlsbFRyYW5zbGF0aW9uLCAwLjApO1xcbmdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIHVfZGVwdGgsIDEuMCk7XFxufVwifSxpY29uOntcImljb24uZnJhZ1wiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuI2lmZGVmIFNERlxcbnVuaWZvcm0gbG93cCB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBsb3dwIHZlYzQgdV9vdXRsaW5lQ29sb3I7XFxuI2VuZGlmXFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl90ZXg7XFxudmFyeWluZyBsb3dwIGZsb2F0IHZfb3BhY2l0eTtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3NpemU7XFxudmFyeWluZyBsb3dwIHZlYzQgdl9jb2xvcjtcXG4jaWZkZWYgU0RGXFxudmFyeWluZyBtZWRpdW1wIGZsYW90IHZfaGFsb193aWR0aDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8dXRpbC9lbmNvZGluZy5nbHNsPlxcbnZlYzQgbWl4Q29sb3JzKHZlYzQgY29sb3IxLCB2ZWM0IGNvbG9yMikge1xcbmZsb2F0IGNvbXBvc2l0ZUFscGhhID0gY29sb3IyLmEgKyBjb2xvcjEuYSAqICgxLjAgLSBjb2xvcjIuYSk7XFxudmVjMyBjb21wb3NpdGVDb2xvciA9IGNvbG9yMi5yZ2IgKyBjb2xvcjEucmdiICogKDEuMCAtIGNvbG9yMi5hKTtcXG5yZXR1cm4gdmVjNChjb21wb3NpdGVDb2xvciwgY29tcG9zaXRlQWxwaGEpO1xcbn1cXG52b2lkIG1haW4oKVxcbntcXG4jaWZkZWYgU0RGXFxubG93cCB2ZWM0IGZpbGxQaXhlbENvbG9yID0gdl9jb2xvcjtcXG5mbG9hdCBkID0gcmdiYTJmbG9hdCh0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3RleCkpIC0gMC41O1xcbmNvbnN0IGZsb2F0IHNvZnRFZGdlUmF0aW8gPSAwLjI0ODA2MjAxNjtcXG5mbG9hdCBzaXplID0gbWF4KHZfc2l6ZS54LCB2X3NpemUueSk7XFxuZmxvYXQgZGlzdCA9IGQgKiBzb2Z0RWRnZVJhdGlvICogc2l6ZTtcXG5maWxsUGl4ZWxDb2xvciAqPSBjbGFtcCgwLjUgLSBkaXN0LCAwLjAsIDEuMCk7XFxuaWYgKHZfaGFsb193aWR0aCA+IDAuMjUpIHtcXG5sb3dwIHZlYzQgb3V0bGluZVBpeGVsQ29sb3IgPSB1X291dGxpbmVDb2xvcjtcXG5jb25zdCBmbG9hdCBvdXRsaW5lTGltaXRSYXRpbyA9ICgxNi4wIC8gODYuMCk7XFxuZmxvYXQgY2xhbXBlZE91dGxpbmVTaXplID0gc29mdEVkZ2VSYXRpbyAqIG1pbih2X2hhbG9fd2lkdGgsIG91dGxpbmVMaW1pdFJhdGlvICogbWF4KHZfc2l6ZS54LCB2X3NpemUueSkpO1xcbm91dGxpbmVQaXhlbENvbG9yICo9IGNsYW1wKDAuNSAtIChhYnMoZGlzdCkgLSBjbGFtcGVkT3V0bGluZVNpemUpLCAwLjAsIDEuMCk7XFxuZ2xfRnJhZ0NvbG9yID0gdl9vcGFjaXR5ICogbWl4Q29sb3JzKGZpbGxQaXhlbENvbG9yLCBvdXRsaW5lUGl4ZWxDb2xvcik7XFxufVxcbmVsc2Uge1xcbmdsX0ZyYWdDb2xvciA9IHZfb3BhY2l0eSAqIGZpbGxQaXhlbENvbG9yO1xcbn1cXG4jZWxzZVxcbmxvd3AgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4KTtcXG5nbF9GcmFnQ29sb3IgPSB2X29wYWNpdHkgKiB0ZXhDb2xvcjtcXG4jZW5kaWZcXG59XCIsXCJpY29uLnZlcnRcIjpcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdmVydGV4T2Zmc2V0O1xcbmF0dHJpYnV0ZSB2ZWM0IGFfdGV4QW5nbGVSYW5nZTtcXG5hdHRyaWJ1dGUgdmVjNCBhX2xldmVsSW5mbztcXG5hdHRyaWJ1dGUgZmxvYXQgYV9vcGFjaXR5SW5mbztcXG4jcHJhZ21hIGhlYWRlclxcbnZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxuI2lmZGVmIFNERlxcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2hhbG9fd2lkdGg7XFxuI2VuZGlmXFxudW5pZm9ybSBoaWdocCBtYXQzIHVfZHZzTWF0MztcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kaXNwbGF5TWF0MztcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kaXNwbGF5Vmlld01hdDM7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzIgdV9pY29uVHJhbnNsYXRpb247XFxudW5pZm9ybSB2ZWMyIHVfbW9zYWljU2l6ZTtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9kZXB0aDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9tYXBSb3RhdGlvbjtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9sZXZlbDtcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9rZWVwVXByaWdodDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9mYWRlRHVyYXRpb247XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl90ZXg7XFxudmFyeWluZyBsb3dwIGZsb2F0IHZfb3BhY2l0eTtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3NpemU7XFxuY29uc3QgZmxvYXQgQ19PRkZTRVRfUFJFQ0lTSU9OID0gMS4wIC8gOC4wO1xcbmNvbnN0IGZsb2F0IENfMjU2X1RPX1JBRCA9IDMuMTQxNTkyNjUzNTkgLyAxMjguMDtcXG5jb25zdCBmbG9hdCBDX0RFR19UT19SQUQgPSAzLjE0MTU5MjY1MzU5IC8gMTgwLjA7XFxuY29uc3QgZmxvYXQgdGlsZUNvb3JkUmF0aW8gPSAxLjAgLyA4LjA7XFxudW5pZm9ybSBoaWdocCBmbG9hdCB1X3RpbWU7XFxudm9pZCBtYWluKClcXG57XFxuI3ByYWdtYSBtYWluXFxudl9jb2xvciA9IGNvbG9yO1xcbnZfb3BhY2l0eSA9IG9wYWNpdHk7XFxuI2lmZGVmIFNERlxcbnZfaGFsb193aWR0aCA9IGhhbG9fd2lkdGg7XFxuI2VuZGlmXFxuZmxvYXQgbW9kZGVkID0gbW9kKGFfb3BhY2l0eUluZm8sIDEyOC4wKTtcXG5mbG9hdCB0YXJnZXRPcGFjaXR5ID0gKGFfb3BhY2l0eUluZm8gLSBtb2RkZWQpIC8gMTI4LjA7XFxuZmxvYXQgc3RhcnRPcGFjaXR5ID0gbW9kZGVkIC8gMTI3LjA7XFxuZmxvYXQgaW50ZXJwb2xhdGVkT3BhY2l0eSA9IGNsYW1wKHN0YXJ0T3BhY2l0eSArIDIuMCAqICh0YXJnZXRPcGFjaXR5IC0gMC41KSAqIHVfdGltZSAvIHVfZmFkZUR1cmF0aW9uLCAwLjAsIDEuMCk7XFxudl9vcGFjaXR5ICo9IGludGVycG9sYXRlZE9wYWNpdHk7XFxubWVkaXVtcCBmbG9hdCBhX2FuZ2xlICAgICAgICAgPSBhX2xldmVsSW5mb1sxXTtcXG5tZWRpdW1wIGZsb2F0IGFfbWluTGV2ZWwgICAgICA9IGFfbGV2ZWxJbmZvWzJdO1xcbm1lZGl1bXAgZmxvYXQgYV9tYXhMZXZlbCAgICAgID0gYV9sZXZlbEluZm9bM107XFxubWVkaXVtcCB2ZWMyIGFfdGV4ICAgICAgICAgICAgPSBhX3RleEFuZ2xlUmFuZ2UueHk7XFxubWVkaXVtcCBmbG9hdCBkZWx0YV96ID0gMC4wO1xcbm1lZGl1bXAgZmxvYXQgcm90YXRlZCA9IG1vZChhX2FuZ2xlICsgdV9tYXBSb3RhdGlvbiwgMjU2LjApO1xcbmRlbHRhX3ogKz0gKDEuMCAtIHN0ZXAodV9rZWVwVXByaWdodCwgMC4wKSkgKiBzdGVwKDY0LjAsIHJvdGF0ZWQpICogKDEuMCAtIHN0ZXAoMTkyLjAsIHJvdGF0ZWQpKTtcXG5kZWx0YV96ICs9IDEuMCAtIHN0ZXAoYV9taW5MZXZlbCwgdV9sZXZlbCk7XFxuZGVsdGFfeiArPSBzdGVwKGFfbWF4TGV2ZWwsIHVfbGV2ZWwpO1xcbmRlbHRhX3ogKz0gc3RlcCh2X29wYWNpdHksIDAuMCk7XFxudmVjMiBvZmZzZXQgPSBDX09GRlNFVF9QUkVDSVNJT04gKiBhX3ZlcnRleE9mZnNldDtcXG52X3NpemUgPSBhYnMob2Zmc2V0KTtcXG4jaWZkZWYgU0RGXFxub2Zmc2V0ID0gKDEyMC4wIC8gODYuMCkgKiBvZmZzZXQ7XFxuI2VuZGlmXFxubWVkaXVtcCB2ZWMzIHBvcyA9IHVfZHZzTWF0MyAqIHZlYzMoYV9wb3MsIDEuMCkgKyB1X2Rpc3BsYXlWaWV3TWF0MyAqIHZlYzMoc2l6ZSAqIG9mZnNldCwgMC4wKSArIHVfZGlzcGxheU1hdDMgKiB2ZWMzKHVfaWNvblRyYW5zbGF0aW9uLCAwLjApO1xcbmdsX1Bvc2l0aW9uID0gdmVjNChwb3MueHksIHVfZGVwdGggKyBkZWx0YV96LCAxLjApO1xcbnZfdGV4ID0gYV90ZXgueHkgLyB1X21vc2FpY1NpemU7XFxufVwifSxsaW5lOntcImxpbmUuZnJhZ1wiOlwicHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBoaWdocCBmbG9hdCB2X2FjY3VtdWxhdGVkRGlzdGFuY2U7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfbGluZUhhbGZXaWR0aDtcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2JsdXI7XFxuI2lmIGRlZmluZWQgKFBBVFRFUk4pIHx8IGRlZmluZWQoU0RGKVxcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IHZfdGxicjtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X3BhdHRlcm5TaXplO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X3dpZHRoUmF0aW87XFxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2FudGlhbGlhc2luZztcXG4jZW5kaWZcXG4jaWZkZWYgU0RGXFxuI2luY2x1ZGUgPHV0aWwvZW5jb2RpbmcuZ2xzbD5cXG4jZW5kaWZcXG52b2lkIG1haW4oKVxcbntcXG5tZWRpdW1wIGZsb2F0IGZyYWdEaXN0ID0gbGVuZ3RoKHZfbm9ybWFsKSAqIHZfbGluZUhhbGZXaWR0aDtcXG5sb3dwIGZsb2F0IGFscGhhID0gY2xhbXAoKHZfbGluZUhhbGZXaWR0aCAtIGZyYWdEaXN0KSAvIHZfYmx1ciwgMC4wLCAxLjApO1xcbiNpZmRlZiBQQVRURVJOXFxubWVkaXVtcCBmbG9hdCByZWxhdGl2ZVRleFggPSBmcmFjdCh2X2FjY3VtdWxhdGVkRGlzdGFuY2UgLyAodl9wYXR0ZXJuU2l6ZS54ICogdl93aWR0aFJhdGlvKSk7XFxubWVkaXVtcCBmbG9hdCByZWxhdGl2ZVRleFkgPSAwLjUgKyB2X25vcm1hbC55ICogdl9saW5lSGFsZldpZHRoIC8gKHZfcGF0dGVyblNpemUueSAqIHZfd2lkdGhSYXRpbyk7XFxubWVkaXVtcCB2ZWMyIHRleENvb3JkID0gbWl4KHZfdGxici54eSwgdl90bGJyLnp3LCB2ZWMyKHJlbGF0aXZlVGV4WCwgcmVsYXRpdmVUZXhZKSk7XFxubG93cCB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdGV4Q29vcmQpO1xcbmdsX0ZyYWdDb2xvciA9IGFscGhhICogdl9jb2xvclszXSAqIGNvbG9yO1xcbiNlbGlmIGRlZmluZWQoU0RGKVxcbm1lZGl1bXAgZmxvYXQgcmVsYXRpdmVUZXhYID0gZnJhY3QoKHZfYWNjdW11bGF0ZWREaXN0YW5jZSAqIDAuNSkgLyAodl9wYXR0ZXJuU2l6ZS54ICogdl93aWR0aFJhdGlvKSk7XFxubWVkaXVtcCBmbG9hdCByZWxhdGl2ZVRleFkgPSAgMC41ICsgMC4yNSAqIHZfbm9ybWFsLnk7XFxubWVkaXVtcCB2ZWMyIHRleENvb3JkID0gbWl4KHZfdGxici54eSwgdl90bGJyLnp3LCB2ZWMyKHJlbGF0aXZlVGV4WCwgcmVsYXRpdmVUZXhZKSk7XFxubWVkaXVtcCBmbG9hdCBkID0gcmdiYTJmbG9hdCh0ZXh0dXJlMkQodV90ZXh0dXJlLCB0ZXhDb29yZCkpIC0gMC41O1xcbmZsb2F0IGRpc3QgPSBkICogKHZfbGluZUhhbGZXaWR0aCArIHVfYW50aWFsaWFzaW5nIC8gMi4wKTtcXG5nbF9GcmFnQ29sb3IgPSBhbHBoYSAqIGNsYW1wKDAuNSAtIGRpc3QsIDAuMCwgMS4wKSAqIHZfY29sb3I7XFxuI2Vsc2VcXG5nbF9GcmFnQ29sb3IgPSBhbHBoYSAqIHZfY29sb3I7XFxuI2VuZGlmXFxufVwiLFwibGluZS52ZXJ0XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjNCBhX2V4dHJ1ZGVfb2Zmc2V0O1xcbmF0dHJpYnV0ZSB2ZWM0IGFfZGlyX25vcm1hbDtcXG5hdHRyaWJ1dGUgdmVjMiBhX2FjY3VtdWxhdGVkRGlzdGFuY2U7XFxuI3ByYWdtYSBoZWFkZXJcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kdnNNYXQzO1xcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2Rpc3BsYXlNYXQzO1xcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2Rpc3BsYXlWaWV3TWF0MztcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV96b29tRmFjdG9yO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVfbGluZVRyYW5zbGF0aW9uO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2FudGlhbGlhc2luZztcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9kZXB0aDtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGhpZ2hwIGZsb2F0IHZfYWNjdW11bGF0ZWREaXN0YW5jZTtcXG5jb25zdCBmbG9hdCBzY2FsZSA9IDEuMCAvIDMxLjA7XFxuY29uc3QgbWVkaXVtcCBmbG9hdCB0aWxlQ29vcmRSYXRpbyA9IDguMDtcXG4jaWYgZGVmaW5lZCAoU0RGKVxcbmNvbnN0IG1lZGl1bXAgZmxvYXQgc2RmUGF0dGVybkhhbGZXaWR0aCA9IDE1LjU7XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQgKFBBVFRFUk4pIHx8IGRlZmluZWQoU0RGKVxcbnVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVfbW9zYWljU2l6ZTtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjNCB2X3RsYnI7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl9wYXR0ZXJuU2l6ZTtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgdl93aWR0aFJhdGlvO1xcbiNlbmRpZlxcbnZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfbGluZUhhbGZXaWR0aDtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgdl9ibHVyO1xcbnZvaWQgbWFpbigpXFxue1xcbiNwcmFnbWEgbWFpblxcbnZfY29sb3IgPSBjb2xvciAqIG9wYWNpdHk7XFxudl9ibHVyID0gYmx1ciArIHVfYW50aWFsaWFzaW5nO1xcbnZfbm9ybWFsID0gYV9kaXJfbm9ybWFsLnp3ICogc2NhbGU7XFxuI2lmIGRlZmluZWQgKFBBVFRFUk4pIHx8IGRlZmluZWQoU0RGKVxcbnZfdGxiciAgICAgICAgICA9IHRsYnIgLyB1X21vc2FpY1NpemUueHl4eTtcXG52X3BhdHRlcm5TaXplICAgPSB2ZWMyKHRsYnIueiAtIHRsYnIueCwgdGxici55IC0gdGxici53KTtcXG4jaWYgZGVmaW5lZCAoUEFUVEVSTilcXG52X3dpZHRoUmF0aW8gPSB3aWR0aCAvIHZfcGF0dGVyblNpemUueTtcXG4jZWxzZVxcbnZfd2lkdGhSYXRpbyA9IHdpZHRoIC8gc2RmUGF0dGVybkhhbGZXaWR0aCAvIDIuMDtcXG4jZW5kaWZcXG4jZW5kaWZcXG52X2xpbmVIYWxmV2lkdGggPSAod2lkdGggKyB1X2FudGlhbGlhc2luZykgKiAwLjU7XFxubWVkaXVtcCB2ZWMyIGRpciA9IGFfZGlyX25vcm1hbC54eSAqIHNjYWxlO1xcbm1lZGl1bXAgdmVjMiBvZmZzZXRfID0gYV9leHRydWRlX29mZnNldC56dyAqIHNjYWxlICogb2Zmc2V0O1xcbm1lZGl1bXAgdmVjMiBkaXN0ID0gdl9saW5lSGFsZldpZHRoICogc2NhbGUgKiBhX2V4dHJ1ZGVfb2Zmc2V0Lnh5O1xcbm1lZGl1bXAgdmVjMyBwb3MgPSB1X2R2c01hdDMgKiB2ZWMzKGFfcG9zICsgb2Zmc2V0XyAqIHRpbGVDb29yZFJhdGlvIC8gdV96b29tRmFjdG9yLCAxLjApICsgdV9kaXNwbGF5Vmlld01hdDMgKiB2ZWMzKGRpc3QsIDAuMCkgKyB1X2Rpc3BsYXlNYXQzICogdmVjMyh1X2xpbmVUcmFuc2xhdGlvbiwgMC4wKTtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCB1X2RlcHRoLCAxLjApO1xcbiNpZiBkZWZpbmVkIChQQVRURVJOKSB8fCBkZWZpbmVkKFNERilcXG52X2FjY3VtdWxhdGVkRGlzdGFuY2UgPSBhX2FjY3VtdWxhdGVkRGlzdGFuY2UueCAqIHVfem9vbUZhY3RvciAvIHRpbGVDb29yZFJhdGlvICsgZG90KGRpciwgZGlzdCArIG9mZnNldF8pO1xcbiNlbmRpZlxcbn1cIn0sb3V0bGluZTp7XCJvdXRsaW5lLmZyYWdcIjpcInZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdl9ub3JtYWw7XFxudm9pZCBtYWluKClcXG57XFxubG93cCBmbG9hdCBkaXN0ID0gYWJzKHZfbm9ybWFsLnkpO1xcbmxvd3AgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKDEuMCwgMC4wLCBkaXN0KTtcXG5nbF9GcmFnQ29sb3IgPSBhbHBoYSAqIHZfY29sb3I7XFxufVwiLFwib3V0bGluZS52ZXJ0XCI6XCJhdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX29mZnNldDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3hub3JtYWw7XFxuI3ByYWdtYSBoZWFkZXJcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2R2c01hdDM7XFxudW5pZm9ybSBoaWdocCBtYXQzIHVfZGlzcGxheU1hdDM7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzIgdV9maWxsVHJhbnNsYXRpb247XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfZGVwdGg7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfb3V0bGluZV93aWR0aDtcXG52YXJ5aW5nIGxvd3AgdmVjMiB2X25vcm1hbDtcXG5jb25zdCBmbG9hdCBzY2FsZSA9IDEuMCAvIDE1LjA7XFxudm9pZCBtYWluKClcXG57XFxuI3ByYWdtYSBtYWluXFxudl9jb2xvciA9IGNvbG9yICogb3BhY2l0eTtcXG52X25vcm1hbCA9IGFfeG5vcm1hbDtcXG5tZWRpdW1wIHZlYzIgZGlzdCA9IHVfb3V0bGluZV93aWR0aCAqIHNjYWxlICogYV9vZmZzZXQ7XFxubWVkaXVtcCB2ZWMzIHBvcyA9IHVfZHZzTWF0MyAqIHZlYzMoYV9wb3MsIDEuMCkgKyB1X2Rpc3BsYXlNYXQzICogdmVjMyhkaXN0ICsgdV9maWxsVHJhbnNsYXRpb24sIDAuMCk7XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcy54eSwgdV9kZXB0aCwgMS4wKTtcXG59XCJ9LHRleHQ6e1widGV4dC5mcmFnXCI6XCJ1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG52YXJ5aW5nIGxvd3AgdmVjMiB2X3RleDtcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCB2X2VkZ2VXaWR0aDtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgdl9lZGdlRGlzdGFuY2U7XFxudm9pZCBtYWluKClcXG57XFxubG93cCBmbG9hdCBkaXN0ID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXgpLmE7XFxubWVkaXVtcCBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAodl9lZGdlRGlzdGFuY2UgLSB2X2VkZ2VXaWR0aCwgdl9lZGdlRGlzdGFuY2UgKyB2X2VkZ2VXaWR0aCwgZGlzdCk7XFxuZ2xfRnJhZ0NvbG9yID0gYWxwaGEgKiB2X2NvbG9yO1xcbn1cIixcInRleHQudmVydFwiOlwiYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV92ZXJ0ZXhPZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzQgYV90ZXhBbmdsZVJhbmdlO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfbGV2ZWxJbmZvO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX29wYWNpdHlJbmZvO1xcbiNwcmFnbWEgaGVhZGVyXFxudmFyeWluZyBsb3dwIHZlYzQgdl9jb2xvcjtcXG51bmlmb3JtIGhpZ2hwIG1hdDMgdV9kdnNNYXQzO1xcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2Rpc3BsYXlNYXQzO1xcbnVuaWZvcm0gaGlnaHAgbWF0MyB1X2Rpc3BsYXlWaWV3TWF0MztcXG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1X3RleHRUcmFuc2xhdGlvbjtcXG51bmlmb3JtIHZlYzIgdV9tb3NhaWNTaXplO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2RlcHRoO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X21hcFJvdGF0aW9uO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2xldmVsO1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X2tlZXBVcHJpZ2h0O1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2ZhZGVEdXJhdGlvbjtcXG52YXJ5aW5nIGxvd3AgdmVjMiB2X3RleDtcXG5jb25zdCBmbG9hdCBvZmZzZXRQcmVjaXNpb24gPSAxLjAgLyA4LjA7XFxuY29uc3QgbWVkaXVtcCBmbG9hdCBlZGdlUG9zID0gMC43NTtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9hbnRpYWxpYXNpbmdXaWR0aDtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgdl9lZGdlRGlzdGFuY2U7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHZfZWRnZVdpZHRoO1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X2hhbG87XFxuY29uc3QgZmxvYXQgc2RmRm9udFNjYWxlID0gMS4wIC8gMjQuMDtcXG5jb25zdCBmbG9hdCBzZGZQaXhlbCA9IDMuMDtcXG51bmlmb3JtIGhpZ2hwIGZsb2F0IHVfdGltZTtcXG52b2lkIG1haW4oKVxcbntcXG4jcHJhZ21hIG1haW5cXG5pZiAodV9oYWxvID4gMC41KVxcbntcXG52X2NvbG9yID0gaGFsb19jb2xvciAqIG9wYWNpdHk7XFxuaGFsb193aWR0aCAqPSBzZGZQaXhlbDtcXG5oYWxvX2JsdXIgKj0gc2RmUGl4ZWw7XFxufVxcbmVsc2VcXG57XFxudl9jb2xvciA9IGNvbG9yICogb3BhY2l0eTtcXG5oYWxvX3dpZHRoID0gMC4wO1xcbmhhbG9fYmx1ciA9IDAuMDtcXG59XFxuZmxvYXQgbW9kZGVkID0gbW9kKGFfb3BhY2l0eUluZm8sIDEyOC4wKTtcXG5mbG9hdCB0YXJnZXRPcGFjaXR5ID0gKGFfb3BhY2l0eUluZm8gLSBtb2RkZWQpIC8gMTI4LjA7XFxuZmxvYXQgc3RhcnRPcGFjaXR5ID0gbW9kZGVkIC8gMTI3LjA7XFxuZmxvYXQgaW50ZXJwb2xhdGVkT3BhY2l0eSA9IGNsYW1wKHN0YXJ0T3BhY2l0eSArIDIuMCAqICh0YXJnZXRPcGFjaXR5IC0gMC41KSAqIHVfdGltZSAvIHVfZmFkZUR1cmF0aW9uLCAwLjAsIDEuMCk7XFxudl9jb2xvciAqPSBpbnRlcnBvbGF0ZWRPcGFjaXR5O1xcbm1lZGl1bXAgZmxvYXQgYV9hbmdsZSAgICAgICA9IGFfbGV2ZWxJbmZvWzFdO1xcbm1lZGl1bXAgZmxvYXQgYV9taW5MZXZlbCAgICA9IGFfbGV2ZWxJbmZvWzJdO1xcbm1lZGl1bXAgZmxvYXQgYV9tYXhMZXZlbCAgICA9IGFfbGV2ZWxJbmZvWzNdO1xcbm1lZGl1bXAgdmVjMiBhX3RleCAgICAgICAgICA9IGFfdGV4QW5nbGVSYW5nZS54eTtcXG5tZWRpdW1wIGZsb2F0IGFfdmlzTWluQW5nbGUgICAgPSBhX3RleEFuZ2xlUmFuZ2UuejtcXG5tZWRpdW1wIGZsb2F0IGFfdmlzTWF4QW5nbGUgICAgPSBhX3RleEFuZ2xlUmFuZ2UudztcXG5tZWRpdW1wIGZsb2F0IGRlbHRhX3ogPSAwLjA7XFxubWVkaXVtcCBmbG9hdCBhbmdsZSA9IG1vZChhX2FuZ2xlICsgdV9tYXBSb3RhdGlvbiwgMjU2LjApO1xcbmlmIChhX3Zpc01pbkFuZ2xlIDwgYV92aXNNYXhBbmdsZSlcXG57XFxuZGVsdGFfeiArPSAoMS4wIC0gc3RlcCh1X2tlZXBVcHJpZ2h0LCAwLjApKSAqIChzdGVwKGFfdmlzTWF4QW5nbGUsIGFuZ2xlKSArICgxLjAgLSBzdGVwKGFfdmlzTWluQW5nbGUsIGFuZ2xlKSkpO1xcbn1cXG5lbHNlXFxue1xcbmRlbHRhX3ogKz0gKDEuMCAtIHN0ZXAodV9rZWVwVXByaWdodCwgMC4wKSkgKiAoc3RlcChhX3Zpc01heEFuZ2xlLCBhbmdsZSkgKiAoMS4wIC0gc3RlcChhX3Zpc01pbkFuZ2xlLCBhbmdsZSkpKTtcXG59XFxuZGVsdGFfeiArPSAxLjAgLSBzdGVwKGFfbWluTGV2ZWwsIHVfbGV2ZWwpO1xcbmRlbHRhX3ogKz0gc3RlcChhX21heExldmVsLCB1X2xldmVsKTtcXG5kZWx0YV96ICs9IHN0ZXAodl9jb2xvclszXSwgMC4wKTtcXG52X3RleCA9IGFfdGV4Lnh5IC8gdV9tb3NhaWNTaXplO1xcbnZfZWRnZURpc3RhbmNlID0gZWRnZVBvcyAtIGhhbG9fd2lkdGggLyBzaXplO1xcbnZfZWRnZVdpZHRoID0gKHVfYW50aWFsaWFzaW5nV2lkdGggKyBoYWxvX2JsdXIpIC8gc2l6ZTtcXG5tZWRpdW1wIHZlYzMgcG9zID0gdV9kdnNNYXQzICogdmVjMyhhX3BvcywgMS4wKSArIHNkZkZvbnRTY2FsZSAqIHVfZGlzcGxheVZpZXdNYXQzICogdmVjMyhvZmZzZXRQcmVjaXNpb24gKiBzaXplICogYV92ZXJ0ZXhPZmZzZXQsIDAuMCkgKyB1X2Rpc3BsYXlNYXQzICogdmVjMyh1X3RleHRUcmFuc2xhdGlvbiwgMC4wKTtcXG5nbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCB1X2RlcHRoICsgZGVsdGFfeiwgMS4wKTtcXG59XCJ9LHV0aWw6e1wiZW5jb2RpbmcuZ2xzbFwiOlwiY29uc3QgdmVjNCByZ2JhMmZsb2F0X2ZhY3RvcnMgPSB2ZWM0KFxcbjI1NS4wIC8gKDI1Ni4wKSxcXG4yNTUuMCAvICgyNTYuMCAqIDI1Ni4wKSxcXG4yNTUuMCAvICgyNTYuMCAqIDI1Ni4wICogMjU2LjApLFxcbjI1NS4wIC8gKDI1Ni4wICogMjU2LjAgKiAyNTYuMCAqIDI1Ni4wKVxcbik7XFxuZmxvYXQgcmdiYTJmbG9hdCh2ZWM0IHJnYmEpIHtcXG5yZXR1cm4gZG90KHJnYmEsIHJnYmEyZmxvYXRfZmFjdG9ycyk7XFxufVwiLFwidXRpbC5nbHNsXCI6XCJmbG9hdCBuZXh0UE9UKGluIGZsb2F0IHgpIHtcXG5yZXR1cm4gcG93KDIuMCwgY2VpbChsb2cyKGFicyh4KSkpKTtcXG59XCJ9fTtleHBvcnR7ZSBhcyBkZWZhdWx0fTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjMzL2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5mdW5jdGlvbiBlKGUpe2NvbnN0e29wdGlvbnM6bix2YWx1ZTpvfT1lO3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBuW29dfWZ1bmN0aW9uIG4obil7bGV0IG89XCJcIjtmb3IoY29uc3QgdCBpbiBuKXtjb25zdCBpPW5bdF07aWYoXCJib29sZWFuXCI9PXR5cGVvZiBpKWkmJihvKz1gI2RlZmluZSAke3R9XFxuYCk7ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgaSlvKz1gI2RlZmluZSAke3R9ICR7aS50b0ZpeGVkKCl9XFxuYDtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBpKWlmKGUoaSkpe2NvbnN0e3ZhbHVlOmUsb3B0aW9uczpuLG5hbWVzcGFjZTpmfT1pLHM9Zj9gJHtmfV9gOlwiXCI7Zm9yKGNvbnN0IHQgaW4gbilvKz1gI2RlZmluZSAke3N9JHt0fSAke25bdF0udG9GaXhlZCgpfVxcbmA7bys9YCNkZWZpbmUgJHt0fSAke3N9JHtlfVxcbmB9ZWxzZXtjb25zdCBlPWkub3B0aW9ucztsZXQgbj0wO2Zvcihjb25zdCB0IGluIGUpbys9YCNkZWZpbmUgJHtlW3RdfSAkeyhuKyspLnRvRml4ZWQoKX1cXG5gO28rPWAjZGVmaW5lICR7dH0gJHtlW2kudmFsdWVdfVxcbmB9fXJldHVybiBvfWV4cG9ydHtuIGFzIGdsc2xpZnlEZWZpbmVNYXB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9