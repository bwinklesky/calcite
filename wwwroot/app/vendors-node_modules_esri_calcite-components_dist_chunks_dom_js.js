export const __webpack_id__ = "vendors-node_modules_esri_calcite-components_dist_chunks_dom_js";
export const __webpack_ids__ = ["vendors-node_modules_esri_calcite-components_dist_chunks_dom_js"];
export const __webpack_modules__ = {

/***/ "./node_modules/@esri/calcite-components/dist/chunks/dom.js":
/*!******************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/chunks/dom.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getTextWidth),
/* harmony export */   B: () => (/* binding */ getElementWidth),
/* harmony export */   C: () => (/* binding */ getModeName),
/* harmony export */   D: () => (/* binding */ hasVisibleContent),
/* harmony export */   a: () => (/* binding */ slotChangeHasAssignedElement),
/* harmony export */   b: () => (/* binding */ focusElement),
/* harmony export */   c: () => (/* binding */ getShadowRootNode),
/* harmony export */   d: () => (/* binding */ focusElementInGroup),
/* harmony export */   e: () => (/* binding */ getSlotAssignedElements),
/* harmony export */   f: () => (/* binding */ filterDirectChildren),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   h: () => (/* binding */ slotChangeHasContent),
/* harmony export */   i: () => (/* binding */ isPrimaryPointerButton),
/* harmony export */   j: () => (/* binding */ intersects),
/* harmony export */   k: () => (/* binding */ getRootNode),
/* harmony export */   l: () => (/* binding */ closestElementCrossShadowBoundary),
/* harmony export */   m: () => (/* binding */ isBefore),
/* harmony export */   n: () => (/* binding */ nodeListToArray),
/* harmony export */   o: () => (/* binding */ getStylePixelValue),
/* harmony export */   p: () => (/* binding */ ensureId),
/* harmony export */   q: () => (/* binding */ queryElementRoots),
/* harmony export */   r: () => (/* binding */ tabbableOptions),
/* harmony export */   s: () => (/* binding */ slotChangeGetAssignedElements),
/* harmony export */   t: () => (/* binding */ toAriaBoolean),
/* harmony export */   u: () => (/* binding */ isKeyboardTriggeredClick),
/* harmony export */   v: () => (/* binding */ setRequestedIcon),
/* harmony export */   w: () => (/* binding */ whenTransitionDone),
/* harmony export */   x: () => (/* binding */ getFirstTabbable),
/* harmony export */   y: () => (/* binding */ whenAnimationDone),
/* harmony export */   z: () => (/* binding */ nextFrame)
/* harmony export */ });
/* harmony import */ var _guid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./guid.js */ "./node_modules/@esri/calcite-components/dist/chunks/guid.js");
/* harmony import */ var _runtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runtime.js */ "./node_modules/@esri/calcite-components/dist/chunks/runtime.js");
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */


/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode$1 = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode$1(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode$1(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode$1(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode$1(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
const tabbableOptions = {
  getShadowRoot: true
};
function ensureId(el) {
  if (!el) {
    return "";
  }
  return el.id = el.id || `${el.tagName.toLowerCase()}-${(0,_guid_js__WEBPACK_IMPORTED_MODULE_0__.g)()}`;
}
function nodeListToArray(nodeList) {
  return Array.isArray(nodeList) ? nodeList : Array.from(nodeList);
}
function getModeName(el) {
  const closestElWithMode = closestElementCrossShadowBoundary(
    el,
    `.${_runtime_js__WEBPACK_IMPORTED_MODULE_1__.C.darkMode}, .${_runtime_js__WEBPACK_IMPORTED_MODULE_1__.C.lightMode}, .${_runtime_js__WEBPACK_IMPORTED_MODULE_1__.C.autoMode}`
  );
  return closestElWithMode?.classList.contains("calcite-mode-dark") || closestElWithMode?.classList.contains("calcite-mode-auto") && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}
function getElementDir(el) {
  const prop = "dir";
  const selector = `[${prop}]`;
  const closest = closestElementCrossShadowBoundary(el, selector);
  return closest ? closest.getAttribute(prop) : "ltr";
}
function getElementWidth(el) {
  if (!el) {
    return 0;
  }
  return parseFloat(getComputedStyle(el).inlineSize);
}
function getRootNode(el) {
  return el.getRootNode();
}
function getShadowRootNode(el) {
  const rootNode = getRootNode(el);
  return "host" in rootNode ? rootNode : null;
}
function getTextWidth(text, font) {
  if (!text) {
    return 0;
  }
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  context.font = font;
  return context.measureText(text).width;
}
function getHost(root) {
  return root.host || null;
}
function queryElementRoots(el, {
  selector,
  id
}) {
  if (!el) {
    return null;
  }
  if (el.assignedSlot) {
    el = el.assignedSlot;
  }
  const rootNode = getRootNode(el);
  const found = id ? "getElementById" in rootNode ? (
    /*
      Check to make sure 'getElementById' exists in cases where element is no longer connected to the DOM and getRootNode() returns the element.
      https://github.com/Esri/calcite-design-system/pull/4280
       */
    rootNode.getElementById(id)
  ) : null : selector ? rootNode.querySelector(selector) : null;
  return found || queryElementRoots(getHost(rootNode), { selector, id });
}
function closestElementCrossShadowBoundary(element, selector) {
  return element ? element.closest(selector) || closestElementCrossShadowBoundary(getHost(getRootNode(element)), selector) : null;
}
function isCalciteFocusable(el) {
  return typeof el?.setFocus === "function";
}
async function focusElement(el, includeContainer = false, strategy = "tabbable", context, options) {
  if (!el) {
    return;
  }
  if (isCalciteFocusable(el) && context !== el) {
    return el.setFocus(options);
  }
  const firstFocusFunction = strategy === "tabbable" ? focusFirstTabbable : focusFirstFocusable;
  return firstFocusFunction(el, includeContainer, options);
}
function getFirstTabbable(element, includeContainer) {
  if (!element) {
    return;
  }
  return tabbable(element, { ...tabbableOptions, includeContainer })[0] ?? element;
}
function focusFirstTabbable(element, includeContainer, options) {
  getFirstTabbable(element, includeContainer)?.focus(options);
}
function getFirstFocusable(element, includeContainer) {
  if (!element) {
    return;
  }
  return focusable(element, { ...tabbableOptions, includeContainer })[0] ?? element;
}
function focusFirstFocusable(element, includeContainer, options) {
  getFirstFocusable(element, includeContainer)?.focus(options);
}
function filterDirectChildren(el, selector) {
  return Array.from(el.children).filter((child) => child.matches(selector));
}
function filterElementsBySelector(elements, selector) {
  return elements.filter((element) => element.matches(selector));
}
function setRequestedIcon(iconObject, iconValue, matchedValue) {
  if (typeof iconValue === "string" && iconValue !== "") {
    return iconValue;
  } else if (iconValue === "" || iconValue === true) {
    return iconObject[matchedValue];
  }
}
function intersects(rect1, rect2) {
  return !(rect2.left > rect1.right || rect2.right < rect1.left || rect2.top > rect1.bottom || rect2.bottom < rect1.top);
}
function toAriaBoolean(value) {
  return Boolean(value).toString();
}
function slotChangeHasContent(event) {
  return slotChangeHasAssignedElement(event) || slotChangeHasTextContent(event);
}
function slotChangeGetTextContent(event) {
  return slotChangeGetAssignedNodes(event).filter((node) => node.nodeType === Node.TEXT_NODE).map((node) => node.textContent).join("").trim();
}
function hasVisibleContent(element) {
  for (const node of element.childNodes) {
    if (node.nodeType === Node.TEXT_NODE && node.textContent?.trim() !== "" || node.nodeType === Node.ELEMENT_NODE) {
      return true;
    }
  }
  return false;
}
function slotChangeHasTextContent(event) {
  return !!slotChangeGetTextContent(event);
}
function slotChangeGetAssignedNodes(event) {
  return event.currentTarget.assignedNodes({
    flatten: true
  });
}
function slotChangeHasAssignedElement(event) {
  return !!slotChangeGetAssignedElements(event).length;
}
function slotChangeGetAssignedElements(event, selector) {
  return getSlotAssignedElements(event.currentTarget, selector);
}
function getSlotAssignedElements(slot, selector) {
  const assignedElements = slot.assignedElements({
    flatten: true
  });
  return selector ? filterElementsBySelector(assignedElements, selector) : assignedElements;
}
function isPrimaryPointerButton(event) {
  return !!(event.isPrimary && event.button === 0);
}
function isKeyboardTriggeredClick(event) {
  return event.detail === 0;
}
const focusElementInGroup = (elements, currentElement, destination, cycle = true, includeContainer = true, targetAsContext = false) => {
  const currentIndex = elements.indexOf(currentElement);
  const isFirstItem = currentIndex === 0;
  const isLastItem = currentIndex === elements.length - 1;
  if (cycle) {
    destination = destination === "previous" && isFirstItem ? "last" : destination === "next" && isLastItem ? "first" : destination;
  }
  let focusTarget;
  if (destination === "previous") {
    focusTarget = elements[currentIndex - 1] || elements[cycle ? elements.length - 1 : currentIndex];
  } else if (destination === "next") {
    focusTarget = elements[currentIndex + 1] || elements[cycle ? 0 : currentIndex];
  } else if (destination === "last") {
    focusTarget = elements[elements.length - 1];
  } else {
    focusTarget = elements[0];
  }
  focusElement(focusTarget, includeContainer, "tabbable", targetAsContext ? focusTarget : void 0);
  return focusTarget;
};
function isBefore(a, b) {
  if (a.parentNode !== b.parentNode) {
    return false;
  }
  const children = Array.from(a.parentNode.children);
  return children.indexOf(a) < children.indexOf(b);
}
async function whenAnimationDone(targetEl, animationName) {
  return whenTransitionOrAnimationDone(targetEl, animationName, "animation");
}
async function whenTransitionDone(targetEl, transitionProp) {
  return whenTransitionOrAnimationDone(targetEl, transitionProp, "transition");
}
function findAnimation(targetEl, type, transitionPropOrAnimationName) {
  const targetProp = type === "transition" ? "transitionProperty" : "animationName";
  return targetEl.getAnimations().find((anim) => anim[targetProp] === transitionPropOrAnimationName);
}
async function whenTransitionOrAnimationDone(targetEl, transitionPropOrAnimationName, type) {
  let anim = findAnimation(targetEl, type, transitionPropOrAnimationName);
  if (!anim) {
    await nextFrame();
    anim = findAnimation(targetEl, type, transitionPropOrAnimationName);
  }
  if (!anim) {
    return;
  }
  try {
    await anim.finished;
  } catch {
  }
}
async function nextFrame() {
  await new Promise((resolve) => requestAnimationFrame(() => resolve()));
}
function getStylePixelValue(value) {
  if (value.endsWith("px")) {
    return parseFloat(value);
  } else if (value.endsWith("vw")) {
    return viewportUnitToPixel(parseFloat(value), window.innerWidth);
  } else if (value.endsWith("vh")) {
    return viewportUnitToPixel(parseFloat(value), window.innerHeight);
  }
  return 0;
}
function viewportUnitToPixel(value, viewportSize) {
  return value * viewportSize / 100;
}



/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/chunks/guid.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/chunks/guid.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ guid)
/* harmony export */ });
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.3.3 */
function gen(counts) {
  return counts.map((count) => {
    let out = "";
    for (let i = 0; i < count; i++) {
      out += ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
    }
    return out;
  }).join("-");
}
const guid = () => gen([2, 1, 1, 1, 3]);



/***/ })

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZXNyaV9jYWxjaXRlLWNvbXBvbmVudHNfZGlzdF9jaHVua3NfZG9tX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNzQztBQUNVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUIsR0FBRywyQ0FBSSxHQUFHO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQ0FBVyxVQUFVLEtBQUssMENBQVcsV0FBVyxLQUFLLDBDQUFXLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZ0NFOzs7Ozs7Ozs7Ozs7Ozs7QUNsa0JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVjaXNpb25mYXJtcy8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jaHVua3MvZG9tLmpzIiwid2VicGFjazovL3ByZWNpc2lvbmZhcm1zLy4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2NodW5rcy9ndWlkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL2Rldi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxudjMuMy4zICovXG5pbXBvcnQgeyBnIGFzIGd1aWQgfSBmcm9tIFwiLi9ndWlkLmpzXCI7XG5pbXBvcnQgeyBDIGFzIENTU19VVElMSVRZIH0gZnJvbSBcIi4vcnVudGltZS5qc1wiO1xuLyohXG4qIHRhYmJhYmxlIDYuMi4wXG4qIEBsaWNlbnNlIE1JVCwgaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvdGFiYmFibGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cbnZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbXCJpbnB1dDpub3QoW2luZXJ0XSlcIiwgXCJzZWxlY3Q6bm90KFtpbmVydF0pXCIsIFwidGV4dGFyZWE6bm90KFtpbmVydF0pXCIsIFwiYVtocmVmXTpub3QoW2luZXJ0XSlcIiwgXCJidXR0b246bm90KFtpbmVydF0pXCIsIFwiW3RhYmluZGV4XTpub3Qoc2xvdCk6bm90KFtpbmVydF0pXCIsIFwiYXVkaW9bY29udHJvbHNdOm5vdChbaW5lcnRdKVwiLCBcInZpZGVvW2NvbnRyb2xzXTpub3QoW2luZXJ0XSlcIiwgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0pOm5vdChbaW5lcnRdKScsIFwiZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGU6bm90KFtpbmVydF0pXCIsIFwiZGV0YWlsczpub3QoW2luZXJ0XSlcIl07XG52YXIgY2FuZGlkYXRlU2VsZWN0b3IgPSAvKiBAX19QVVJFX18gKi8gY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oXCIsXCIpO1xudmFyIE5vRWxlbWVudCA9IHR5cGVvZiBFbGVtZW50ID09PSBcInVuZGVmaW5lZFwiO1xudmFyIG1hdGNoZXMgPSBOb0VsZW1lbnQgPyBmdW5jdGlvbigpIHtcbn0gOiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcbnZhciBnZXRSb290Tm9kZSQxID0gIU5vRWxlbWVudCAmJiBFbGVtZW50LnByb3RvdHlwZS5nZXRSb290Tm9kZSA/IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JGdldFJvb3ROb2RlO1xuICByZXR1cm4gZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2VsZW1lbnQkZ2V0Um9vdE5vZGUgPSBlbGVtZW50LmdldFJvb3ROb2RlKSA9PT0gbnVsbCB8fCBfZWxlbWVudCRnZXRSb290Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsZW1lbnQkZ2V0Um9vdE5vZGUuY2FsbChlbGVtZW50KTtcbn0gOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbn07XG52YXIgaXNJbmVydCA9IGZ1bmN0aW9uIGlzSW5lcnQyKG5vZGUsIGxvb2tVcCkge1xuICB2YXIgX25vZGUkZ2V0QXR0cmlidXRlO1xuICBpZiAobG9va1VwID09PSB2b2lkIDApIHtcbiAgICBsb29rVXAgPSB0cnVlO1xuICB9XG4gIHZhciBpbmVydEF0dCA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGdldEF0dHJpYnV0ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRnZXRBdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGdldEF0dHJpYnV0ZS5jYWxsKG5vZGUsIFwiaW5lcnRcIik7XG4gIHZhciBpbmVydCA9IGluZXJ0QXR0ID09PSBcIlwiIHx8IGluZXJ0QXR0ID09PSBcInRydWVcIjtcbiAgdmFyIHJlc3VsdCA9IGluZXJ0IHx8IGxvb2tVcCAmJiBub2RlICYmIGlzSW5lcnQyKG5vZGUucGFyZW50Tm9kZSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIGlzQ29udGVudEVkaXRhYmxlID0gZnVuY3Rpb24gaXNDb250ZW50RWRpdGFibGUyKG5vZGUpIHtcbiAgdmFyIF9ub2RlJGdldEF0dHJpYnV0ZTI7XG4gIHZhciBhdHRWYWx1ZSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGdldEF0dHJpYnV0ZTIgPSBub2RlLmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX25vZGUkZ2V0QXR0cmlidXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkZ2V0QXR0cmlidXRlMi5jYWxsKG5vZGUsIFwiY29udGVudGVkaXRhYmxlXCIpO1xuICByZXR1cm4gYXR0VmFsdWUgPT09IFwiXCIgfHwgYXR0VmFsdWUgPT09IFwidHJ1ZVwiO1xufTtcbnZhciBnZXRDYW5kaWRhdGVzID0gZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlczIoZWwsIGluY2x1ZGVDb250YWluZXIsIGZpbHRlcikge1xuICBpZiAoaXNJbmVydChlbCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3RvcikpO1xuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcbnZhciBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkgPSBmdW5jdGlvbiBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkyKGVsZW1lbnRzLCBpbmNsdWRlQ29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHZhciBjYW5kaWRhdGVzID0gW107XG4gIHZhciBlbGVtZW50c1RvQ2hlY2sgPSBBcnJheS5mcm9tKGVsZW1lbnRzKTtcbiAgd2hpbGUgKGVsZW1lbnRzVG9DaGVjay5sZW5ndGgpIHtcbiAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzVG9DaGVjay5zaGlmdCgpO1xuICAgIGlmIChpc0luZXJ0KGVsZW1lbnQsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09IFwiU0xPVFwiKSB7XG4gICAgICB2YXIgYXNzaWduZWQgPSBlbGVtZW50LmFzc2lnbmVkRWxlbWVudHMoKTtcbiAgICAgIHZhciBjb250ZW50ID0gYXNzaWduZWQubGVuZ3RoID8gYXNzaWduZWQgOiBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgdmFyIG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkyKGNvbnRlbnQsIHRydWUsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2guYXBwbHkoY2FuZGlkYXRlcywgbmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgIHNjb3BlUGFyZW50OiBlbGVtZW50LFxuICAgICAgICAgIGNhbmRpZGF0ZXM6IG5lc3RlZENhbmRpZGF0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWxpZENhbmRpZGF0ZSA9IG1hdGNoZXMuY2FsbChlbGVtZW50LCBjYW5kaWRhdGVTZWxlY3Rvcik7XG4gICAgICBpZiAodmFsaWRDYW5kaWRhdGUgJiYgb3B0aW9ucy5maWx0ZXIoZWxlbWVudCkgJiYgKGluY2x1ZGVDb250YWluZXIgfHwgIWVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKSkge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgICB2YXIgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdCB8fCAvLyBjaGVjayBmb3IgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICB0eXBlb2Ygb3B0aW9ucy5nZXRTaGFkb3dSb290ID09PSBcImZ1bmN0aW9uXCIgJiYgb3B0aW9ucy5nZXRTaGFkb3dSb290KGVsZW1lbnQpO1xuICAgICAgdmFyIHZhbGlkU2hhZG93Um9vdCA9ICFpc0luZXJ0KHNoYWRvd1Jvb3QsIGZhbHNlKSAmJiAoIW9wdGlvbnMuc2hhZG93Um9vdEZpbHRlciB8fCBvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIoZWxlbWVudCkpO1xuICAgICAgaWYgKHNoYWRvd1Jvb3QgJiYgdmFsaWRTaGFkb3dSb290KSB7XG4gICAgICAgIHZhciBfbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseTIoc2hhZG93Um9vdCA9PT0gdHJ1ZSA/IGVsZW1lbnQuY2hpbGRyZW4gOiBzaGFkb3dSb290LmNoaWxkcmVuLCB0cnVlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaC5hcHBseShjYW5kaWRhdGVzLCBfbmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3BlUGFyZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgY2FuZGlkYXRlczogX25lc3RlZENhbmRpZGF0ZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudHNUb0NoZWNrLnVuc2hpZnQuYXBwbHkoZWxlbWVudHNUb0NoZWNrLCBlbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xudmFyIGhhc1RhYkluZGV4ID0gZnVuY3Rpb24gaGFzVGFiSW5kZXgyKG5vZGUpIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpLCAxMCkpO1xufTtcbnZhciBnZXRUYWJJbmRleCA9IGZ1bmN0aW9uIGdldFRhYkluZGV4Mihub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG5vZGUgcHJvdmlkZWRcIik7XG4gIH1cbiAgaWYgKG5vZGUudGFiSW5kZXggPCAwKSB7XG4gICAgaWYgKCgvXihBVURJT3xWSURFT3xERVRBSUxTKSQvLnRlc3Qobm9kZS50YWdOYW1lKSB8fCBpc0NvbnRlbnRFZGl0YWJsZShub2RlKSkgJiYgIWhhc1RhYkluZGV4KG5vZGUpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGUudGFiSW5kZXg7XG59O1xudmFyIGdldFNvcnRPcmRlclRhYkluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydE9yZGVyVGFiSW5kZXgyKG5vZGUsIGlzU2NvcGUpIHtcbiAgdmFyIHRhYkluZGV4ID0gZ2V0VGFiSW5kZXgobm9kZSk7XG4gIGlmICh0YWJJbmRleCA8IDAgJiYgaXNTY29wZSAmJiAhaGFzVGFiSW5kZXgobm9kZSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gdGFiSW5kZXg7XG59O1xudmFyIHNvcnRPcmRlcmVkVGFiYmFibGVzID0gZnVuY3Rpb24gc29ydE9yZGVyZWRUYWJiYWJsZXMyKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXIgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn07XG52YXIgaXNJbnB1dCA9IGZ1bmN0aW9uIGlzSW5wdXQyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gXCJJTlBVVFwiO1xufTtcbnZhciBpc0hpZGRlbklucHV0ID0gZnVuY3Rpb24gaXNIaWRkZW5JbnB1dDIobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09IFwiaGlkZGVuXCI7XG59O1xudmFyIGlzRGV0YWlsc1dpdGhTdW1tYXJ5ID0gZnVuY3Rpb24gaXNEZXRhaWxzV2l0aFN1bW1hcnkyKG5vZGUpIHtcbiAgdmFyIHIgPSBub2RlLnRhZ05hbWUgPT09IFwiREVUQUlMU1wiICYmIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkcmVuKS5zb21lKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLnRhZ05hbWUgPT09IFwiU1VNTUFSWVwiO1xuICB9KTtcbiAgcmV0dXJuIHI7XG59O1xudmFyIGdldENoZWNrZWRSYWRpbyA9IGZ1bmN0aW9uIGdldENoZWNrZWRSYWRpbzIobm9kZXMsIGZvcm0pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbn07XG52YXIgaXNUYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gaXNUYWJiYWJsZVJhZGlvMihub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHJhZGlvU2NvcGUgPSBub2RlLmZvcm0gfHwgZ2V0Um9vdE5vZGUkMShub2RlKTtcbiAgdmFyIHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gcXVlcnlSYWRpb3MyKG5hbWUpIHtcbiAgICByZXR1cm4gcmFkaW9TY29wZS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXScpO1xuICB9O1xuICB2YXIgcmFkaW9TZXQ7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuQ1NTICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuQ1NTLmVzY2FwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkxvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXNcIiwgZXJyLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB2YXIgY2hlY2tlZCA9IGdldENoZWNrZWRSYWRpbyhyYWRpb1NldCwgbm9kZS5mb3JtKTtcbiAgcmV0dXJuICFjaGVja2VkIHx8IGNoZWNrZWQgPT09IG5vZGU7XG59O1xudmFyIGlzUmFkaW8gPSBmdW5jdGlvbiBpc1JhZGlvMihub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gXCJyYWRpb1wiO1xufTtcbnZhciBpc05vblRhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiBpc05vblRhYmJhYmxlUmFkaW8yKG5vZGUpIHtcbiAgcmV0dXJuIGlzUmFkaW8obm9kZSkgJiYgIWlzVGFiYmFibGVSYWRpbyhub2RlKTtcbn07XG52YXIgaXNOb2RlQXR0YWNoZWQgPSBmdW5jdGlvbiBpc05vZGVBdHRhY2hlZDIobm9kZSkge1xuICB2YXIgX25vZGVSb290O1xuICB2YXIgbm9kZVJvb3QgPSBub2RlICYmIGdldFJvb3ROb2RlJDEobm9kZSk7XG4gIHZhciBub2RlUm9vdEhvc3QgPSAoX25vZGVSb290ID0gbm9kZVJvb3QpID09PSBudWxsIHx8IF9ub2RlUm9vdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGVSb290Lmhvc3Q7XG4gIHZhciBhdHRhY2hlZCA9IGZhbHNlO1xuICBpZiAobm9kZVJvb3QgJiYgbm9kZVJvb3QgIT09IG5vZGUpIHtcbiAgICB2YXIgX25vZGVSb290SG9zdCwgX25vZGVSb290SG9zdCRvd25lckRvLCBfbm9kZSRvd25lckRvY3VtZW50O1xuICAgIGF0dGFjaGVkID0gISEoKF9ub2RlUm9vdEhvc3QgPSBub2RlUm9vdEhvc3QpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3QgIT09IHZvaWQgMCAmJiAoX25vZGVSb290SG9zdCRvd25lckRvID0gX25vZGVSb290SG9zdC5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfbm9kZVJvb3RIb3N0JG93bmVyRG8gIT09IHZvaWQgMCAmJiBfbm9kZVJvb3RIb3N0JG93bmVyRG8uY29udGFpbnMobm9kZVJvb3RIb3N0KSB8fCBub2RlICE9PSBudWxsICYmIG5vZGUgIT09IHZvaWQgMCAmJiAoX25vZGUkb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgX25vZGUkb3duZXJEb2N1bWVudCAhPT0gdm9pZCAwICYmIF9ub2RlJG93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZSkpO1xuICAgIHdoaWxlICghYXR0YWNoZWQgJiYgbm9kZVJvb3RIb3N0KSB7XG4gICAgICB2YXIgX25vZGVSb290MiwgX25vZGVSb290SG9zdDIsIF9ub2RlUm9vdEhvc3QyJG93bmVyRDtcbiAgICAgIG5vZGVSb290ID0gZ2V0Um9vdE5vZGUkMShub2RlUm9vdEhvc3QpO1xuICAgICAgbm9kZVJvb3RIb3N0ID0gKF9ub2RlUm9vdDIgPSBub2RlUm9vdCkgPT09IG51bGwgfHwgX25vZGVSb290MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGVSb290Mi5ob3N0O1xuICAgICAgYXR0YWNoZWQgPSAhISgoX25vZGVSb290SG9zdDIgPSBub2RlUm9vdEhvc3QpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3QyICE9PSB2b2lkIDAgJiYgKF9ub2RlUm9vdEhvc3QyJG93bmVyRCA9IF9ub2RlUm9vdEhvc3QyLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3QyJG93bmVyRCAhPT0gdm9pZCAwICYmIF9ub2RlUm9vdEhvc3QyJG93bmVyRC5jb250YWlucyhub2RlUm9vdEhvc3QpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGF0dGFjaGVkO1xufTtcbnZhciBpc1plcm9BcmVhID0gZnVuY3Rpb24gaXNaZXJvQXJlYTIobm9kZSkge1xuICB2YXIgX25vZGUkZ2V0Qm91bmRpbmdDbGllID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUud2lkdGgsIGhlaWdodCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS5oZWlnaHQ7XG4gIHJldHVybiB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDA7XG59O1xudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gaXNIaWRkZW4yKG5vZGUsIF9yZWYpIHtcbiAgdmFyIGRpc3BsYXlDaGVjayA9IF9yZWYuZGlzcGxheUNoZWNrLCBnZXRTaGFkb3dSb290ID0gX3JlZi5nZXRTaGFkb3dSb290O1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGlzRGlyZWN0U3VtbWFyeSA9IG1hdGNoZXMuY2FsbChub2RlLCBcImRldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlXCIpO1xuICB2YXIgbm9kZVVuZGVyRGV0YWlscyA9IGlzRGlyZWN0U3VtbWFyeSA/IG5vZGUucGFyZW50RWxlbWVudCA6IG5vZGU7XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZVVuZGVyRGV0YWlscywgXCJkZXRhaWxzOm5vdChbb3Blbl0pICpcIikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWRpc3BsYXlDaGVjayB8fCBkaXNwbGF5Q2hlY2sgPT09IFwiZnVsbFwiIHx8IGRpc3BsYXlDaGVjayA9PT0gXCJsZWdhY3ktZnVsbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBnZXRTaGFkb3dSb290ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhciBvcmlnaW5hbE5vZGUgPSBub2RlO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHZhciByb290Tm9kZSA9IGdldFJvb3ROb2RlJDEobm9kZSk7XG4gICAgICAgIGlmIChwYXJlbnRFbGVtZW50ICYmICFwYXJlbnRFbGVtZW50LnNoYWRvd1Jvb3QgJiYgZ2V0U2hhZG93Um9vdChwYXJlbnRFbGVtZW50KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90O1xuICAgICAgICB9IGVsc2UgaWYgKCFwYXJlbnRFbGVtZW50ICYmIHJvb3ROb2RlICE9PSBub2RlLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICBub2RlID0gcm9vdE5vZGUuaG9zdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZSA9IG9yaWdpbmFsTm9kZTtcbiAgICB9XG4gICAgaWYgKGlzTm9kZUF0dGFjaGVkKG5vZGUpKSB7XG4gICAgICByZXR1cm4gIW5vZGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5Q2hlY2sgIT09IFwibGVnYWN5LWZ1bGxcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BsYXlDaGVjayA9PT0gXCJub24temVyby1hcmVhXCIpIHtcbiAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQgPSBmdW5jdGlvbiBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0Mihub2RlKSB7XG4gIGlmICgvXihJTlBVVHxCVVRUT058U0VMRUNUfFRFWFRBUkVBKSQvLnRlc3Qobm9kZS50YWdOYW1lKSkge1xuICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS50YWdOYW1lID09PSBcIkZJRUxEU0VUXCIgJiYgcGFyZW50Tm9kZS5kaXNhYmxlZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnROb2RlLmNoaWxkcmVuLml0ZW0oaSk7XG4gICAgICAgICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09IFwiTEVHRU5EXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwocGFyZW50Tm9kZSwgXCJmaWVsZHNldFtkaXNhYmxlZF0gKlwiKSA/IHRydWUgOiAhY2hpbGQuY29udGFpbnMobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlID0gZnVuY3Rpb24gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZTIob3B0aW9ucywgbm9kZSkge1xuICBpZiAobm9kZS5kaXNhYmxlZCB8fCAvLyB3ZSBtdXN0IGRvIGFuIGluZXJ0IGxvb2sgdXAgdG8gZmlsdGVyIG91dCBhbnkgZWxlbWVudHMgaW5zaWRlIGFuIGluZXJ0IGFuY2VzdG9yXG4gIC8vICBiZWNhdXNlIHdlJ3JlIGxpbWl0ZWQgaW4gdGhlIHR5cGUgb2Ygc2VsZWN0b3JzIHdlIGNhbiB1c2UgaW4gSlNEb20gKHNlZSByZWxhdGVkXG4gIC8vICBub3RlIHJlbGF0ZWQgdG8gYGNhbmRpZGF0ZVNlbGVjdG9yc2ApXG4gIGlzSW5lcnQobm9kZSkgfHwgaXNIaWRkZW5JbnB1dChub2RlKSB8fCBpc0hpZGRlbihub2RlLCBvcHRpb25zKSB8fCAvLyBGb3IgYSBkZXRhaWxzIGVsZW1lbnQgd2l0aCBhIHN1bW1hcnksIHRoZSBzdW1tYXJ5IGVsZW1lbnQgZ2V0cyB0aGUgZm9jdXNcbiAgaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkgfHwgaXNEaXNhYmxlZEZyb21GaWVsZHNldChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlID0gZnVuY3Rpb24gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlMihvcHRpb25zLCBub2RlKSB7XG4gIGlmIChpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHwgZ2V0VGFiSW5kZXgobm9kZSkgPCAwIHx8ICFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlID0gZnVuY3Rpb24gaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZTIoc2hhZG93SG9zdE5vZGUpIHtcbiAgdmFyIHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiksIDEwKTtcbiAgaWYgKGlzTmFOKHRhYkluZGV4KSB8fCB0YWJJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBzb3J0QnlPcmRlciA9IGZ1bmN0aW9uIHNvcnRCeU9yZGVyMihjYW5kaWRhdGVzKSB7XG4gIHZhciByZWd1bGFyVGFiYmFibGVzID0gW107XG4gIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpKSB7XG4gICAgdmFyIGlzU2NvcGUgPSAhIWl0ZW0uc2NvcGVQYXJlbnQ7XG4gICAgdmFyIGVsZW1lbnQgPSBpc1Njb3BlID8gaXRlbS5zY29wZVBhcmVudCA6IGl0ZW07XG4gICAgdmFyIGNhbmRpZGF0ZVRhYmluZGV4ID0gZ2V0U29ydE9yZGVyVGFiSW5kZXgoZWxlbWVudCwgaXNTY29wZSk7XG4gICAgdmFyIGVsZW1lbnRzID0gaXNTY29wZSA/IHNvcnRCeU9yZGVyMihpdGVtLmNhbmRpZGF0ZXMpIDogZWxlbWVudDtcbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcbiAgICAgIGlzU2NvcGUgPyByZWd1bGFyVGFiYmFibGVzLnB1c2guYXBwbHkocmVndWxhclRhYmJhYmxlcywgZWxlbWVudHMpIDogcmVndWxhclRhYmJhYmxlcy5wdXNoKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICB0YWJJbmRleDogY2FuZGlkYXRlVGFiaW5kZXgsXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIGlzU2NvcGUsXG4gICAgICAgIGNvbnRlbnQ6IGVsZW1lbnRzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3JkZXJlZFRhYmJhYmxlcy5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBzb3J0YWJsZSkge1xuICAgIHNvcnRhYmxlLmlzU2NvcGUgPyBhY2MucHVzaC5hcHBseShhY2MsIHNvcnRhYmxlLmNvbnRlbnQpIDogYWNjLnB1c2goc29ydGFibGUuY29udGVudCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pLmNvbmNhdChyZWd1bGFyVGFiYmFibGVzKTtcbn07XG52YXIgdGFiYmFibGUgPSBmdW5jdGlvbiB0YWJiYWJsZTIoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2NvbnRhaW5lcl0sIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwge1xuICAgICAgZmlsdGVyOiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IGZhbHNlLFxuICAgICAgZ2V0U2hhZG93Um9vdDogb3B0aW9ucy5nZXRTaGFkb3dSb290LFxuICAgICAgc2hhZG93Um9vdEZpbHRlcjogaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGNvbnRhaW5lciwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKSk7XG4gIH1cbiAgcmV0dXJuIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpO1xufTtcbnZhciBmb2N1c2FibGUgPSBmdW5jdGlvbiBmb2N1c2FibGUyKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtjb250YWluZXJdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGNvbnRhaW5lciwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcbmNvbnN0IHRhYmJhYmxlT3B0aW9ucyA9IHtcbiAgZ2V0U2hhZG93Um9vdDogdHJ1ZVxufTtcbmZ1bmN0aW9uIGVuc3VyZUlkKGVsKSB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICByZXR1cm4gZWwuaWQgPSBlbC5pZCB8fCBgJHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9LSR7Z3VpZCgpfWA7XG59XG5mdW5jdGlvbiBub2RlTGlzdFRvQXJyYXkobm9kZUxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobm9kZUxpc3QpID8gbm9kZUxpc3QgOiBBcnJheS5mcm9tKG5vZGVMaXN0KTtcbn1cbmZ1bmN0aW9uIGdldE1vZGVOYW1lKGVsKSB7XG4gIGNvbnN0IGNsb3Nlc3RFbFdpdGhNb2RlID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KFxuICAgIGVsLFxuICAgIGAuJHtDU1NfVVRJTElUWS5kYXJrTW9kZX0sIC4ke0NTU19VVElMSVRZLmxpZ2h0TW9kZX0sIC4ke0NTU19VVElMSVRZLmF1dG9Nb2RlfWBcbiAgKTtcbiAgcmV0dXJuIGNsb3Nlc3RFbFdpdGhNb2RlPy5jbGFzc0xpc3QuY29udGFpbnMoXCJjYWxjaXRlLW1vZGUtZGFya1wiKSB8fCBjbG9zZXN0RWxXaXRoTW9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKFwiY2FsY2l0ZS1tb2RlLWF1dG9cIikgJiYgd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIpLm1hdGNoZXMgPyBcImRhcmtcIiA6IFwibGlnaHRcIjtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnREaXIoZWwpIHtcbiAgY29uc3QgcHJvcCA9IFwiZGlyXCI7XG4gIGNvbnN0IHNlbGVjdG9yID0gYFske3Byb3B9XWA7XG4gIGNvbnN0IGNsb3Nlc3QgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWwsIHNlbGVjdG9yKTtcbiAgcmV0dXJuIGNsb3Nlc3QgPyBjbG9zZXN0LmdldEF0dHJpYnV0ZShwcm9wKSA6IFwibHRyXCI7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50V2lkdGgoZWwpIHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZWwpLmlubGluZVNpemUpO1xufVxuZnVuY3Rpb24gZ2V0Um9vdE5vZGUoZWwpIHtcbiAgcmV0dXJuIGVsLmdldFJvb3ROb2RlKCk7XG59XG5mdW5jdGlvbiBnZXRTaGFkb3dSb290Tm9kZShlbCkge1xuICBjb25zdCByb290Tm9kZSA9IGdldFJvb3ROb2RlKGVsKTtcbiAgcmV0dXJuIFwiaG9zdFwiIGluIHJvb3ROb2RlID8gcm9vdE5vZGUgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGV4dFdpZHRoKHRleHQsIGZvbnQpIHtcbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gIHJldHVybiBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xufVxuZnVuY3Rpb24gZ2V0SG9zdChyb290KSB7XG4gIHJldHVybiByb290Lmhvc3QgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIHF1ZXJ5RWxlbWVudFJvb3RzKGVsLCB7XG4gIHNlbGVjdG9yLFxuICBpZFxufSkge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGVsLmFzc2lnbmVkU2xvdCkge1xuICAgIGVsID0gZWwuYXNzaWduZWRTbG90O1xuICB9XG4gIGNvbnN0IHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUoZWwpO1xuICBjb25zdCBmb3VuZCA9IGlkID8gXCJnZXRFbGVtZW50QnlJZFwiIGluIHJvb3ROb2RlID8gKFxuICAgIC8qXG4gICAgICBDaGVjayB0byBtYWtlIHN1cmUgJ2dldEVsZW1lbnRCeUlkJyBleGlzdHMgaW4gY2FzZXMgd2hlcmUgZWxlbWVudCBpcyBubyBsb25nZXIgY29ubmVjdGVkIHRvIHRoZSBET00gYW5kIGdldFJvb3ROb2RlKCkgcmV0dXJucyB0aGUgZWxlbWVudC5cbiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9wdWxsLzQyODBcbiAgICAgICAqL1xuICAgIHJvb3ROb2RlLmdldEVsZW1lbnRCeUlkKGlkKVxuICApIDogbnVsbCA6IHNlbGVjdG9yID8gcm9vdE5vZGUucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBudWxsO1xuICByZXR1cm4gZm91bmQgfHwgcXVlcnlFbGVtZW50Um9vdHMoZ2V0SG9zdChyb290Tm9kZSksIHsgc2VsZWN0b3IsIGlkIH0pO1xufVxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5jbG9zZXN0KHNlbGVjdG9yKSB8fCBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZ2V0SG9zdChnZXRSb290Tm9kZShlbGVtZW50KSksIHNlbGVjdG9yKSA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0NhbGNpdGVGb2N1c2FibGUoZWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBlbD8uc2V0Rm9jdXMgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZvY3VzRWxlbWVudChlbCwgaW5jbHVkZUNvbnRhaW5lciA9IGZhbHNlLCBzdHJhdGVneSA9IFwidGFiYmFibGVcIiwgY29udGV4dCwgb3B0aW9ucykge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc0NhbGNpdGVGb2N1c2FibGUoZWwpICYmIGNvbnRleHQgIT09IGVsKSB7XG4gICAgcmV0dXJuIGVsLnNldEZvY3VzKG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IGZpcnN0Rm9jdXNGdW5jdGlvbiA9IHN0cmF0ZWd5ID09PSBcInRhYmJhYmxlXCIgPyBmb2N1c0ZpcnN0VGFiYmFibGUgOiBmb2N1c0ZpcnN0Rm9jdXNhYmxlO1xuICByZXR1cm4gZmlyc3RGb2N1c0Z1bmN0aW9uKGVsLCBpbmNsdWRlQ29udGFpbmVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0VGFiYmFibGUoZWxlbWVudCwgaW5jbHVkZUNvbnRhaW5lcikge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHRhYmJhYmxlKGVsZW1lbnQsIHsgLi4udGFiYmFibGVPcHRpb25zLCBpbmNsdWRlQ29udGFpbmVyIH0pWzBdID8/IGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBmb2N1c0ZpcnN0VGFiYmFibGUoZWxlbWVudCwgaW5jbHVkZUNvbnRhaW5lciwgb3B0aW9ucykge1xuICBnZXRGaXJzdFRhYmJhYmxlKGVsZW1lbnQsIGluY2x1ZGVDb250YWluZXIpPy5mb2N1cyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0Rm9jdXNhYmxlKGVsZW1lbnQsIGluY2x1ZGVDb250YWluZXIpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBmb2N1c2FibGUoZWxlbWVudCwgeyAuLi50YWJiYWJsZU9wdGlvbnMsIGluY2x1ZGVDb250YWluZXIgfSlbMF0gPz8gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGZvY3VzRmlyc3RGb2N1c2FibGUoZWxlbWVudCwgaW5jbHVkZUNvbnRhaW5lciwgb3B0aW9ucykge1xuICBnZXRGaXJzdEZvY3VzYWJsZShlbGVtZW50LCBpbmNsdWRlQ29udGFpbmVyKT8uZm9jdXMob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBmaWx0ZXJEaXJlY3RDaGlsZHJlbihlbCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWwuY2hpbGRyZW4pLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkLm1hdGNoZXMoc2VsZWN0b3IpKTtcbn1cbmZ1bmN0aW9uIGZpbHRlckVsZW1lbnRzQnlTZWxlY3RvcihlbGVtZW50cywgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcigoZWxlbWVudCkgPT4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSk7XG59XG5mdW5jdGlvbiBzZXRSZXF1ZXN0ZWRJY29uKGljb25PYmplY3QsIGljb25WYWx1ZSwgbWF0Y2hlZFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaWNvblZhbHVlID09PSBcInN0cmluZ1wiICYmIGljb25WYWx1ZSAhPT0gXCJcIikge1xuICAgIHJldHVybiBpY29uVmFsdWU7XG4gIH0gZWxzZSBpZiAoaWNvblZhbHVlID09PSBcIlwiIHx8IGljb25WYWx1ZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBpY29uT2JqZWN0W21hdGNoZWRWYWx1ZV07XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVyc2VjdHMocmVjdDEsIHJlY3QyKSB7XG4gIHJldHVybiAhKHJlY3QyLmxlZnQgPiByZWN0MS5yaWdodCB8fCByZWN0Mi5yaWdodCA8IHJlY3QxLmxlZnQgfHwgcmVjdDIudG9wID4gcmVjdDEuYm90dG9tIHx8IHJlY3QyLmJvdHRvbSA8IHJlY3QxLnRvcCk7XG59XG5mdW5jdGlvbiB0b0FyaWFCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gc2xvdENoYW5nZUhhc0NvbnRlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIHNsb3RDaGFuZ2VIYXNBc3NpZ25lZEVsZW1lbnQoZXZlbnQpIHx8IHNsb3RDaGFuZ2VIYXNUZXh0Q29udGVudChldmVudCk7XG59XG5mdW5jdGlvbiBzbG90Q2hhbmdlR2V0VGV4dENvbnRlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIHNsb3RDaGFuZ2VHZXRBc3NpZ25lZE5vZGVzKGV2ZW50KS5maWx0ZXIoKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKS5tYXAoKG5vZGUpID0+IG5vZGUudGV4dENvbnRlbnQpLmpvaW4oXCJcIikudHJpbSgpO1xufVxuZnVuY3Rpb24gaGFzVmlzaWJsZUNvbnRlbnQoZWxlbWVudCkge1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgZWxlbWVudC5jaGlsZE5vZGVzKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKSAhPT0gXCJcIiB8fCBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNsb3RDaGFuZ2VIYXNUZXh0Q29udGVudChldmVudCkge1xuICByZXR1cm4gISFzbG90Q2hhbmdlR2V0VGV4dENvbnRlbnQoZXZlbnQpO1xufVxuZnVuY3Rpb24gc2xvdENoYW5nZUdldEFzc2lnbmVkTm9kZXMoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmN1cnJlbnRUYXJnZXQuYXNzaWduZWROb2Rlcyh7XG4gICAgZmxhdHRlbjogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNsb3RDaGFuZ2VIYXNBc3NpZ25lZEVsZW1lbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhc2xvdENoYW5nZUdldEFzc2lnbmVkRWxlbWVudHMoZXZlbnQpLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHNsb3RDaGFuZ2VHZXRBc3NpZ25lZEVsZW1lbnRzKGV2ZW50LCBzZWxlY3Rvcikge1xuICByZXR1cm4gZ2V0U2xvdEFzc2lnbmVkRWxlbWVudHMoZXZlbnQuY3VycmVudFRhcmdldCwgc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gZ2V0U2xvdEFzc2lnbmVkRWxlbWVudHMoc2xvdCwgc2VsZWN0b3IpIHtcbiAgY29uc3QgYXNzaWduZWRFbGVtZW50cyA9IHNsb3QuYXNzaWduZWRFbGVtZW50cyh7XG4gICAgZmxhdHRlbjogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIHNlbGVjdG9yID8gZmlsdGVyRWxlbWVudHNCeVNlbGVjdG9yKGFzc2lnbmVkRWxlbWVudHMsIHNlbGVjdG9yKSA6IGFzc2lnbmVkRWxlbWVudHM7XG59XG5mdW5jdGlvbiBpc1ByaW1hcnlQb2ludGVyQnV0dG9uKGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5pc1ByaW1hcnkgJiYgZXZlbnQuYnV0dG9uID09PSAwKTtcbn1cbmZ1bmN0aW9uIGlzS2V5Ym9hcmRUcmlnZ2VyZWRDbGljayhldmVudCkge1xuICByZXR1cm4gZXZlbnQuZGV0YWlsID09PSAwO1xufVxuY29uc3QgZm9jdXNFbGVtZW50SW5Hcm91cCA9IChlbGVtZW50cywgY3VycmVudEVsZW1lbnQsIGRlc3RpbmF0aW9uLCBjeWNsZSA9IHRydWUsIGluY2x1ZGVDb250YWluZXIgPSB0cnVlLCB0YXJnZXRBc0NvbnRleHQgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBjdXJyZW50SW5kZXggPSBlbGVtZW50cy5pbmRleE9mKGN1cnJlbnRFbGVtZW50KTtcbiAgY29uc3QgaXNGaXJzdEl0ZW0gPSBjdXJyZW50SW5kZXggPT09IDA7XG4gIGNvbnN0IGlzTGFzdEl0ZW0gPSBjdXJyZW50SW5kZXggPT09IGVsZW1lbnRzLmxlbmd0aCAtIDE7XG4gIGlmIChjeWNsZSkge1xuICAgIGRlc3RpbmF0aW9uID0gZGVzdGluYXRpb24gPT09IFwicHJldmlvdXNcIiAmJiBpc0ZpcnN0SXRlbSA/IFwibGFzdFwiIDogZGVzdGluYXRpb24gPT09IFwibmV4dFwiICYmIGlzTGFzdEl0ZW0gPyBcImZpcnN0XCIgOiBkZXN0aW5hdGlvbjtcbiAgfVxuICBsZXQgZm9jdXNUYXJnZXQ7XG4gIGlmIChkZXN0aW5hdGlvbiA9PT0gXCJwcmV2aW91c1wiKSB7XG4gICAgZm9jdXNUYXJnZXQgPSBlbGVtZW50c1tjdXJyZW50SW5kZXggLSAxXSB8fCBlbGVtZW50c1tjeWNsZSA/IGVsZW1lbnRzLmxlbmd0aCAtIDEgOiBjdXJyZW50SW5kZXhdO1xuICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uID09PSBcIm5leHRcIikge1xuICAgIGZvY3VzVGFyZ2V0ID0gZWxlbWVudHNbY3VycmVudEluZGV4ICsgMV0gfHwgZWxlbWVudHNbY3ljbGUgPyAwIDogY3VycmVudEluZGV4XTtcbiAgfSBlbHNlIGlmIChkZXN0aW5hdGlvbiA9PT0gXCJsYXN0XCIpIHtcbiAgICBmb2N1c1RhcmdldCA9IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIGZvY3VzVGFyZ2V0ID0gZWxlbWVudHNbMF07XG4gIH1cbiAgZm9jdXNFbGVtZW50KGZvY3VzVGFyZ2V0LCBpbmNsdWRlQ29udGFpbmVyLCBcInRhYmJhYmxlXCIsIHRhcmdldEFzQ29udGV4dCA/IGZvY3VzVGFyZ2V0IDogdm9pZCAwKTtcbiAgcmV0dXJuIGZvY3VzVGFyZ2V0O1xufTtcbmZ1bmN0aW9uIGlzQmVmb3JlKGEsIGIpIHtcbiAgaWYgKGEucGFyZW50Tm9kZSAhPT0gYi5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShhLnBhcmVudE5vZGUuY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW4uaW5kZXhPZihhKSA8IGNoaWxkcmVuLmluZGV4T2YoYik7XG59XG5hc3luYyBmdW5jdGlvbiB3aGVuQW5pbWF0aW9uRG9uZSh0YXJnZXRFbCwgYW5pbWF0aW9uTmFtZSkge1xuICByZXR1cm4gd2hlblRyYW5zaXRpb25PckFuaW1hdGlvbkRvbmUodGFyZ2V0RWwsIGFuaW1hdGlvbk5hbWUsIFwiYW5pbWF0aW9uXCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gd2hlblRyYW5zaXRpb25Eb25lKHRhcmdldEVsLCB0cmFuc2l0aW9uUHJvcCkge1xuICByZXR1cm4gd2hlblRyYW5zaXRpb25PckFuaW1hdGlvbkRvbmUodGFyZ2V0RWwsIHRyYW5zaXRpb25Qcm9wLCBcInRyYW5zaXRpb25cIik7XG59XG5mdW5jdGlvbiBmaW5kQW5pbWF0aW9uKHRhcmdldEVsLCB0eXBlLCB0cmFuc2l0aW9uUHJvcE9yQW5pbWF0aW9uTmFtZSkge1xuICBjb25zdCB0YXJnZXRQcm9wID0gdHlwZSA9PT0gXCJ0cmFuc2l0aW9uXCIgPyBcInRyYW5zaXRpb25Qcm9wZXJ0eVwiIDogXCJhbmltYXRpb25OYW1lXCI7XG4gIHJldHVybiB0YXJnZXRFbC5nZXRBbmltYXRpb25zKCkuZmluZCgoYW5pbSkgPT4gYW5pbVt0YXJnZXRQcm9wXSA9PT0gdHJhbnNpdGlvblByb3BPckFuaW1hdGlvbk5hbWUpO1xufVxuYXN5bmMgZnVuY3Rpb24gd2hlblRyYW5zaXRpb25PckFuaW1hdGlvbkRvbmUodGFyZ2V0RWwsIHRyYW5zaXRpb25Qcm9wT3JBbmltYXRpb25OYW1lLCB0eXBlKSB7XG4gIGxldCBhbmltID0gZmluZEFuaW1hdGlvbih0YXJnZXRFbCwgdHlwZSwgdHJhbnNpdGlvblByb3BPckFuaW1hdGlvbk5hbWUpO1xuICBpZiAoIWFuaW0pIHtcbiAgICBhd2FpdCBuZXh0RnJhbWUoKTtcbiAgICBhbmltID0gZmluZEFuaW1hdGlvbih0YXJnZXRFbCwgdHlwZSwgdHJhbnNpdGlvblByb3BPckFuaW1hdGlvbk5hbWUpO1xuICB9XG4gIGlmICghYW5pbSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IGFuaW0uZmluaXNoZWQ7XG4gIH0gY2F0Y2gge1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBuZXh0RnJhbWUoKSB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gcmVzb2x2ZSgpKSk7XG59XG5mdW5jdGlvbiBnZXRTdHlsZVBpeGVsVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmVuZHNXaXRoKFwicHhcIikpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUuZW5kc1dpdGgoXCJ2d1wiKSkge1xuICAgIHJldHVybiB2aWV3cG9ydFVuaXRUb1BpeGVsKHBhcnNlRmxvYXQodmFsdWUpLCB3aW5kb3cuaW5uZXJXaWR0aCk7XG4gIH0gZWxzZSBpZiAodmFsdWUuZW5kc1dpdGgoXCJ2aFwiKSkge1xuICAgIHJldHVybiB2aWV3cG9ydFVuaXRUb1BpeGVsKHBhcnNlRmxvYXQodmFsdWUpLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gdmlld3BvcnRVbml0VG9QaXhlbCh2YWx1ZSwgdmlld3BvcnRTaXplKSB7XG4gIHJldHVybiB2YWx1ZSAqIHZpZXdwb3J0U2l6ZSAvIDEwMDtcbn1cbmV4cG9ydCB7XG4gIGdldFRleHRXaWR0aCBhcyBBLFxuICBnZXRFbGVtZW50V2lkdGggYXMgQixcbiAgZ2V0TW9kZU5hbWUgYXMgQyxcbiAgaGFzVmlzaWJsZUNvbnRlbnQgYXMgRCxcbiAgc2xvdENoYW5nZUhhc0Fzc2lnbmVkRWxlbWVudCBhcyBhLFxuICBmb2N1c0VsZW1lbnQgYXMgYixcbiAgZ2V0U2hhZG93Um9vdE5vZGUgYXMgYyxcbiAgZm9jdXNFbGVtZW50SW5Hcm91cCBhcyBkLFxuICBnZXRTbG90QXNzaWduZWRFbGVtZW50cyBhcyBlLFxuICBmaWx0ZXJEaXJlY3RDaGlsZHJlbiBhcyBmLFxuICBnZXRFbGVtZW50RGlyIGFzIGcsXG4gIHNsb3RDaGFuZ2VIYXNDb250ZW50IGFzIGgsXG4gIGlzUHJpbWFyeVBvaW50ZXJCdXR0b24gYXMgaSxcbiAgaW50ZXJzZWN0cyBhcyBqLFxuICBnZXRSb290Tm9kZSBhcyBrLFxuICBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgYXMgbCxcbiAgaXNCZWZvcmUgYXMgbSxcbiAgbm9kZUxpc3RUb0FycmF5IGFzIG4sXG4gIGdldFN0eWxlUGl4ZWxWYWx1ZSBhcyBvLFxuICBlbnN1cmVJZCBhcyBwLFxuICBxdWVyeUVsZW1lbnRSb290cyBhcyBxLFxuICB0YWJiYWJsZU9wdGlvbnMgYXMgcixcbiAgc2xvdENoYW5nZUdldEFzc2lnbmVkRWxlbWVudHMgYXMgcyxcbiAgdG9BcmlhQm9vbGVhbiBhcyB0LFxuICBpc0tleWJvYXJkVHJpZ2dlcmVkQ2xpY2sgYXMgdSxcbiAgc2V0UmVxdWVzdGVkSWNvbiBhcyB2LFxuICB3aGVuVHJhbnNpdGlvbkRvbmUgYXMgdyxcbiAgZ2V0Rmlyc3RUYWJiYWJsZSBhcyB4LFxuICB3aGVuQW5pbWF0aW9uRG9uZSBhcyB5LFxuICBuZXh0RnJhbWUgYXMgelxufTtcbiIsIi8qISBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL2Rldi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxudjMuMy4zICovXG5mdW5jdGlvbiBnZW4oY291bnRzKSB7XG4gIHJldHVybiBjb3VudHMubWFwKChjb3VudCkgPT4ge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgb3V0ICs9ICgoMSArIE1hdGgucmFuZG9tKCkpICogNjU1MzYgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9KS5qb2luKFwiLVwiKTtcbn1cbmNvbnN0IGd1aWQgPSAoKSA9PiBnZW4oWzIsIDEsIDEsIDEsIDNdKTtcbmV4cG9ydCB7XG4gIGd1aWQgYXMgZ1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==